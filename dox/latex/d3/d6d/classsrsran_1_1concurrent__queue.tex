\doxysection{srsran\+::concurrent\+\_\+queue\texorpdfstring{$<$}{<} T, Policy, Blocking\+Policy \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classsrsran_1_1concurrent__queue}{}\label{classsrsran_1_1concurrent__queue}\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}


A concurrent queue that can be used to pass objects between threads. Different policies are supported\+:  




{\ttfamily \#include $<$concurrent\+\_\+queue.\+h$>$}



Inheritance diagram for srsran\+::concurrent\+\_\+queue\texorpdfstring{$<$}{<} T, Policy, Blocking\+Policy \texorpdfstring{$>$}{>}\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{de/d2e/classsrsran_1_1concurrent__queue__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for srsran\+::concurrent\+\_\+queue\texorpdfstring{$<$}{<} T, Policy, Blocking\+Policy \texorpdfstring{$>$}{>}\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{df/daf/classsrsran_1_1concurrent__queue__coll__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1concurrent__queue_a721c1dfd4a66c8ba57233f44b2df67f6}\label{classsrsran_1_1concurrent__queue_a721c1dfd4a66c8ba57233f44b2df67f6} 
\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{using}} {\bfseries value\+\_\+type} = T
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename... Args$>$ }\\\mbox{\hyperlink{classsrsran_1_1concurrent__queue_a3e7457bd8aadcab730a61df43a4ecd49}{concurrent\+\_\+queue}} (size\+\_\+t \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{minimum\+\_\+q\+\_\+size}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Args}} \&\&... args)
\item 
{\footnotesize template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} U $>$ }\\\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a83c3ee3074579631ed08e3414377a541}{try\+\_\+push}} (U \&\&\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{elem}}) \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{noexcept}}
\item 
{\footnotesize template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} U , \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Q = Blocking\+Policy, std\+::enable\+\_\+if\+\_\+t$<$ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Q}} !=concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::non\+\_\+blocking, \mbox{\hyperlink{classint}{int}} $>$  = 0$>$ }\\\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue_acc0043f182b8d55c7cd432047fe15179}{push\+\_\+blocking}} (U \&\&\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{elem}}) \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{noexcept}}
\item 
\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue_af92570524955aa703c2946900d7741b2}{try\+\_\+pop}} (T \&\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{elem}})
\begin{DoxyCompactList}\small\item\em Pops an element from the queue in a non-\/blocking fashion. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classsrsran_1_1optional}{optional}}$<$ T $>$ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a6d5638ee10deab90bd30105c580748b5}{try\+\_\+pop}} ()
\begin{DoxyCompactList}\small\item\em Pops an element from the queue in a non-\/blocking fashion. \end{DoxyCompactList}\item 
{\footnotesize template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Call\+On\+Pop}} $>$ }\\\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue_ae9d56f2adcb20bf091a80a29386cce47}{try\+\_\+call\+\_\+on\+\_\+pop}} (\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{const}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Call\+On\+Pop}} \&func)
\begin{DoxyCompactList}\small\item\em Pops an element from the queue and calls the provided function with the popped element. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a9fc2964f0e85797249b5531434c70935}{pop\+\_\+blocking}} (T \&\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{elem}})
\begin{DoxyCompactList}\small\item\em Pops an element from the queue. If the queue is empty, the call blocks, waiting for a new element to be pushed. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classsrsran_1_1optional}{optional}}$<$ T $>$ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a017b9f37c5a0969958ccc13f7b91912a}{pop\+\_\+blocking}} () \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{noexcept}}
\begin{DoxyCompactList}\small\item\em Pops an element from the queue. If the queue is empty, the call blocks, waiting for a new element to be pushed. \end{DoxyCompactList}\item 
{\footnotesize template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Call\+On\+Pop}} $>$ }\\\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a2be0a7a406714c6df59e5f1eb9cdd0fd}{call\+\_\+on\+\_\+pop\+\_\+blocking}} (\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{const}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Call\+On\+Pop}} \&func)
\begin{DoxyCompactList}\small\item\em Pops an element from the queue and calls the provided function with the popped element. If the queue is empty, the function blocks, waiting for a new element to be pushed. It returns false if the queue is closed. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a566b5bcfd15d0a7918eb01571046d952}{capacity}} () \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{const}}
\begin{DoxyCompactList}\small\item\em Maximum capacity of the queue. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a0775474918ef7b6fe6720f89156afd65}{size}} () \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{const}}
\begin{DoxyCompactList}\small\item\em Current size of the queue. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue_ac045142931e78330202b2e62ca79fc19}{empty}} () \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{const}}
\begin{DoxyCompactList}\small\item\em Determines whether the queue is empty. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{void}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue_ae6809193cc3aa228a27b887494b5bae0}{request\+\_\+stop}} ()
\begin{DoxyCompactList}\small\item\em Request any blocking function to be interrupted. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1concurrent__queue_a94c115e9e0551bd43ce0056905010345}\label{classsrsran_1_1concurrent__queue_a94c115e9e0551bd43ce0056905010345} 
\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{static}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{const}} \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} {\bfseries queue\+\_\+policy} = \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}
\item 
\Hypertarget{classsrsran_1_1concurrent__queue_ac0111e20dc65b9b5ee571b19daedd56f}\label{classsrsran_1_1concurrent__queue_ac0111e20dc65b9b5ee571b19daedd56f} 
\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{static}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{const}} \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} {\bfseries wait\+\_\+policy} = \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T, \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$\newline
class srsran\+::concurrent\+\_\+queue$<$ T, Policy, Blocking\+Policy $>$}
A concurrent queue that can be used to pass objects between threads. Different policies are supported\+: 


\begin{DoxyItemize}
\item lockfree\+\_\+spsc\+: a lock-\/free single-\/producer single-\/consumer queue. This is the fastest option.
\item locking\+\_\+mpmc\+: a multi-\/producer multi-\/consumer queue that uses a mutex to protect the queue. This is the most most general queue, but has the highest overhead. The producers and consumers will contend on the access to the mutex.
\item locking\+\_\+mpsc\+: a multi-\/producer single-\/consumer queue that uses a mutex to protect the queue. This queue pops all elements in a batch to minimize the contention on the mutex from the consumer side. 
\end{DoxyItemize}

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classsrsran_1_1concurrent__queue_a3e7457bd8aadcab730a61df43a4ecd49}\label{classsrsran_1_1concurrent__queue_a3e7457bd8aadcab730a61df43a4ecd49} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!concurrent\_queue@{concurrent\_queue}}
\index{concurrent\_queue@{concurrent\_queue}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{concurrent\_queue()}{concurrent\_queue()}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
template$<$typename... Args$>$ \\
\mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::concurrent\+\_\+queue (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{minimum\+\_\+q\+\_\+size,  }\item[{\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Args}} \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00649\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ queue(\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{minimum\_q\_size}},\ std::forward<Args>(args)...)}
\DoxyCodeLine{00650\ \ \ \{}
\DoxyCodeLine{00651\ \ \ \}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\Hypertarget{classsrsran_1_1concurrent__queue_a2be0a7a406714c6df59e5f1eb9cdd0fd}\label{classsrsran_1_1concurrent__queue_a2be0a7a406714c6df59e5f1eb9cdd0fd} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!call\_on\_pop\_blocking@{call\_on\_pop\_blocking}}
\index{call\_on\_pop\_blocking@{call\_on\_pop\_blocking}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{call\_on\_pop\_blocking()}{call\_on\_pop\_blocking()}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Call\+On\+Pop}} $>$ \\
\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::call\+\_\+on\+\_\+pop\+\_\+blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{const}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Call\+On\+Pop}} \&}]{func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pops an element from the queue and calls the provided function with the popped element. If the queue is empty, the function blocks, waiting for a new element to be pushed. It returns false if the queue is closed. 


\begin{DoxyCode}{0}
\DoxyCodeLine{00712\ \ \ \{}
\DoxyCodeLine{00713\ \ \ \ \ \textcolor{keywordflow}{return}\ queue.call\_on\_pop\_blocking(func);}
\DoxyCodeLine{00714\ \ \ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_a566b5bcfd15d0a7918eb01571046d952}\label{classsrsran_1_1concurrent__queue_a566b5bcfd15d0a7918eb01571046d952} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!capacity@{capacity}}
\index{capacity@{capacity}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{capacity()}{capacity()}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
size\+\_\+t \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::capacity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Maximum capacity of the queue. 


\begin{DoxyCode}{0}
\DoxyCodeLine{00717\ \{\ \textcolor{keywordflow}{return}\ queue.capacity();\ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_ac045142931e78330202b2e62ca79fc19}\label{classsrsran_1_1concurrent__queue_ac045142931e78330202b2e62ca79fc19} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!empty@{empty}}
\index{empty@{empty}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Determines whether the queue is empty. 


\begin{DoxyCode}{0}
\DoxyCodeLine{00723\ \{\ \textcolor{keywordflow}{return}\ queue.empty();\ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_a017b9f37c5a0969958ccc13f7b91912a}\label{classsrsran_1_1concurrent__queue_a017b9f37c5a0969958ccc13f7b91912a} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!pop\_blocking@{pop\_blocking}}
\index{pop\_blocking@{pop\_blocking}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{pop\_blocking()}{pop\_blocking()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
\mbox{\hyperlink{classsrsran_1_1optional}{optional}}$<$ T $>$ \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::pop\+\_\+blocking (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Pops an element from the queue. If the queue is empty, the call blocks, waiting for a new element to be pushed. 


\begin{DoxyCode}{0}
\DoxyCodeLine{00702\ \ \ \{}
\DoxyCodeLine{00703\ \ \ \ \ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{optional<T>}}\ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{ret}};}
\DoxyCodeLine{00704\ \ \ \ \ queue.call\_on\_pop\_blocking([\&\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{ret}}](T\&\ t)\ \textcolor{keyword}{mutable}\ \{\ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{ret}}\ =\ std::move(t);\ \});}
\DoxyCodeLine{00705\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{ret}};}
\DoxyCodeLine{00706\ \ \ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_a9fc2964f0e85797249b5531434c70935}\label{classsrsran_1_1concurrent__queue_a9fc2964f0e85797249b5531434c70935} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!pop\_blocking@{pop\_blocking}}
\index{pop\_blocking@{pop\_blocking}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{pop\_blocking()}{pop\_blocking()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::pop\+\_\+blocking (\begin{DoxyParamCaption}\item[{T \&}]{elem }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pops an element from the queue. If the queue is empty, the call blocks, waiting for a new element to be pushed. 


\begin{DoxyCode}{0}
\DoxyCodeLine{00698\ \{\ \textcolor{keywordflow}{return}\ queue.pop\_blocking(\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{elem}});\ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_acc0043f182b8d55c7cd432047fe15179}\label{classsrsran_1_1concurrent__queue_acc0043f182b8d55c7cd432047fe15179} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!push\_blocking@{push\_blocking}}
\index{push\_blocking@{push\_blocking}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{push\_blocking()}{push\_blocking()}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} U , \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Q = Blocking\+Policy, std\+::enable\+\_\+if\+\_\+t$<$ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Q}} !=concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::non\+\_\+blocking, \mbox{\hyperlink{classint}{int}} $>$  = 0$>$ \\
\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::push\+\_\+blocking (\begin{DoxyParamCaption}\item[{U \&\&}]{elem }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Pushes a new element into the queue. If the queue is full, the call blocks, waiting for a new slot to become emptied. \begin{DoxyReturn}{Returns}
true if the element was pushed, false if the queue was closed. 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00668\ \ \ \{}
\DoxyCodeLine{00669\ \ \ \ \ \textcolor{keywordflow}{return}\ queue.push\_blocking(std::forward<U>(\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{elem}}));}
\DoxyCodeLine{00670\ \ \ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_ae6809193cc3aa228a27b887494b5bae0}\label{classsrsran_1_1concurrent__queue_ae6809193cc3aa228a27b887494b5bae0} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!request\_stop@{request\_stop}}
\index{request\_stop@{request\_stop}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{request\_stop()}{request\_stop()}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{void}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::request\+\_\+stop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Request any blocking function to be interrupted. 


\begin{DoxyCode}{0}
\DoxyCodeLine{00726\ \{\ queue.request\_stop();\ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_a0775474918ef7b6fe6720f89156afd65}\label{classsrsran_1_1concurrent__queue_a0775474918ef7b6fe6720f89156afd65} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!size@{size}}
\index{size@{size}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
size\+\_\+t \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Current size of the queue. 


\begin{DoxyCode}{0}
\DoxyCodeLine{00720\ \{\ \textcolor{keywordflow}{return}\ queue.size();\ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_ae9d56f2adcb20bf091a80a29386cce47}\label{classsrsran_1_1concurrent__queue_ae9d56f2adcb20bf091a80a29386cce47} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!try\_call\_on\_pop@{try\_call\_on\_pop}}
\index{try\_call\_on\_pop@{try\_call\_on\_pop}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{try\_call\_on\_pop()}{try\_call\_on\_pop()}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Call\+On\+Pop}} $>$ \\
\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::try\+\_\+call\+\_\+on\+\_\+pop (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{const}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Call\+On\+Pop}} \&}]{func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pops an element from the queue and calls the provided function with the popped element. 

If the queue is empty, the call returns false, and the Call\+On\+Pop function is not called. Otherwise, it returns true. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00693\ \ \ \{}
\DoxyCodeLine{00694\ \ \ \ \ \textcolor{keywordflow}{return}\ queue.try\_call\_on\_pop(func);}
\DoxyCodeLine{00695\ \ \ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_a6d5638ee10deab90bd30105c580748b5}\label{classsrsran_1_1concurrent__queue_a6d5638ee10deab90bd30105c580748b5} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!try\_pop@{try\_pop}}
\index{try\_pop@{try\_pop}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{try\_pop()}{try\_pop()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
\mbox{\hyperlink{classsrsran_1_1optional}{optional}}$<$ T $>$ \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::try\+\_\+pop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pops an element from the queue in a non-\/blocking fashion. 

If the queue is empty, the call returns an empty optional. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00681\ \ \ \{}
\DoxyCodeLine{00682\ \ \ \ \ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{optional<T>}}\ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{ret}};}
\DoxyCodeLine{00683\ \ \ \ \ queue.try\_call\_on\_pop([\&\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{ret}}](T\&\ t)\ \textcolor{keyword}{mutable}\ \{\ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{ret}}\ =\ std::move(t);\ \});}
\DoxyCodeLine{00684\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{ret}};}
\DoxyCodeLine{00685\ \ \ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_af92570524955aa703c2946900d7741b2}\label{classsrsran_1_1concurrent__queue_af92570524955aa703c2946900d7741b2} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!try\_pop@{try\_pop}}
\index{try\_pop@{try\_pop}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{try\_pop()}{try\_pop()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::try\+\_\+pop (\begin{DoxyParamCaption}\item[{T \&}]{elem }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pops an element from the queue in a non-\/blocking fashion. 

If the queue is empty, the call returns false. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00675\ \{\ \textcolor{keywordflow}{return}\ queue.try\_pop(\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{elem}});\ \}}

\end{DoxyCode}
\Hypertarget{classsrsran_1_1concurrent__queue_a83c3ee3074579631ed08e3414377a541}\label{classsrsran_1_1concurrent__queue_a83c3ee3074579631ed08e3414377a541} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!try\_push@{try\_push}}
\index{try\_push@{try\_push}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{try\_push()}{try\_push()}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
template$<$\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{typename}} U $>$ \\
\mbox{\hyperlink{classbool}{bool}} \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Policy}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{Blocking\+Policy}} $>$\+::try\+\_\+push (\begin{DoxyParamCaption}\item[{U \&\&}]{elem }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Pushes a new element into the queue in a non-\/blocking fashion. If the queue is full, the element is not pushed. \begin{DoxyReturn}{Returns}
true if the element was pushed, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00657\ \ \ \{}
\DoxyCodeLine{00658\ \ \ \ \ \textcolor{keywordflow}{return}\ queue.try\_push(std::forward<U>(\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{elem}}));}
\DoxyCodeLine{00659\ \ \ \}}

\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/srsran/adt/concurrent\+\_\+queue.\+h\end{DoxyCompactItemize}
