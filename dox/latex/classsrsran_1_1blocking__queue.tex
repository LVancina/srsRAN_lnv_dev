\doxysection{srsran\+::blocking\+\_\+queue\texorpdfstring{$<$}{<} T, Pushing\+Callback, Popping\+Callback \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classsrsran_1_1blocking__queue}{}\label{classsrsran_1_1blocking__queue}\index{srsran::blocking\_queue$<$ T, PushingCallback, PoppingCallback $>$@{srsran::blocking\_queue$<$ T, PushingCallback, PoppingCallback $>$}}


{\ttfamily \#include $<$blocking\+\_\+queue.\+h$>$}

Inheritance diagram for srsran\+::blocking\+\_\+queue\texorpdfstring{$<$}{<} T, Pushing\+Callback, Popping\+Callback \texorpdfstring{$>$}{>}\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.763780cm]{classsrsran_1_1blocking__queue}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1blocking__queue_a3cb6d059f4bacebb572f926c5c764ad5}\label{classsrsran_1_1blocking__queue_a3cb6d059f4bacebb572f926c5c764ad5} 
{\bfseries blocking\+\_\+queue} (size\+\_\+t \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a131d9f4665c962a96394b9e880df37c2}{size}}, Pushing\+Callback push\+\_\+callback=\{\}, Popping\+Callback pop\+\_\+callback=\{\})
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{srsran\+::detail\+::base\+\_\+blocking\+\_\+queue$<$ Ring\+Buffer, Pushing\+Func, Popping\+Func $>$}}}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename... Args$>$ }\\\mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a922bdf12d8cbfbf9982109cdb8f588ee}{base\+\_\+blocking\+\_\+queue}} (Pushing\+Func on\+\_\+push\+\_\+func, Popping\+Func on\+\_\+pop\+\_\+func, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Creates a \doxylink{classsrsran_1_1blocking__queue}{blocking\+\_\+queue}. \end{DoxyCompactList}\item 
{\bfseries base\+\_\+blocking\+\_\+queue} (const \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{base\+\_\+blocking\+\_\+queue}} \&)=delete
\item 
{\bfseries base\+\_\+blocking\+\_\+queue} (\mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{base\+\_\+blocking\+\_\+queue}} \&\&)=delete
\item 
\mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{base\+\_\+blocking\+\_\+queue}} \& {\bfseries operator=} (const \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{base\+\_\+blocking\+\_\+queue}} \&)=delete
\item 
\mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{base\+\_\+blocking\+\_\+queue}} \& {\bfseries operator=} (\mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{base\+\_\+blocking\+\_\+queue}} \&\&)=delete
\item 
void {\bfseries stop} ()
\begin{DoxyCompactList}\small\item\em Sets queue state to "{}notify\+\_\+stop"{} and awake any threads currently blocked waiting (either pushing or popping). \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_aa966281db2b3954bd99aff1e587734bd}{try\+\_\+push}} (const T \&t)
\begin{DoxyCompactList}\small\item\em Try to push new element to queue. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classsrsran_1_1expected}{error\+\_\+type}}$<$ T $>$ \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a785d8d33a0eda1618bde8c1662a84dae}{try\+\_\+push}} (T \&\&t)
\begin{DoxyCompactList}\small\item\em Try to push new r-\/value element to queue. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename It $>$ }\\unsigned \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_ab4d38c047d44c20ee681c37da6a771ca}{try\+\_\+push}} (It b, It e)
\begin{DoxyCompactList}\small\item\em Tries to push all elements in a range into the queue. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_adc7b0f5c9331de320d9bef3958854130}{try\+\_\+push}} (\mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ T $>$ t)
\begin{DoxyCompactList}\small\item\em Tries to push all elements in a span into the queue. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_aae5183bdd94e615104a768300ea08dde}{push\+\_\+blocking}} (const T \&t)
\begin{DoxyCompactList}\small\item\em Pushes an element into the queue. If the queue is full, this call {\itshape blocks} waiting for another thread to pop an element from the queue or set the queue as inactive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classsrsran_1_1expected}{error\+\_\+type}}$<$ T $>$ \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a053b44bee890104e315eac947b61d781}{push\+\_\+blocking}} (T \&\&t)
\begin{DoxyCompactList}\small\item\em Pushes an r-\/value element into the queue. If the queue is full, this call {\itshape blocks} waiting for another thread to pop an element from the queue or set the queue as inactive. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename It $>$ }\\unsigned \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_aaaa696a9890690543f59f3547d343cbd}{push\+\_\+blocking}} (It b, It e)
\begin{DoxyCompactList}\small\item\em Pushes all elements in a range into the queue. If the queue becomes full, this call {\itshape blocks} waiting for space to become available or the queue to become inactive. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a958ada6df59899d54584c047c42a88ec}{push\+\_\+blocking}} (\mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ T $>$ t)
\begin{DoxyCompactList}\small\item\em Pushes all elements in a span into the queue. If the queue becomes full, this call {\itshape blocks} waiting for space to become available or the queue to become inactive. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_af1dcbeceaf0fa122c07152441f6fd988}{try\+\_\+pop}} (T \&obj)
\begin{DoxyCompactList}\small\item\em Tries to pop one object from the queue. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename It $>$ }\\unsigned \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_ae0d9537e9c330144a3e08a1c66500bd2}{try\+\_\+pop}} (It b, It e)
\begin{DoxyCompactList}\small\item\em Tries to pop a range of elements from the queue. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a909c6923abf21abcc9d401f1e1aef588}{try\+\_\+pop}} (\mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ T $>$ t)
\begin{DoxyCompactList}\small\item\em Tries to pop a range of elements from the queue into a span. \end{DoxyCompactList}\item 
T \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_aeb5f0b7529a67726f27998a53eebac25}{pop\+\_\+blocking}} (bool \texorpdfstring{$\ast$}{*}success=nullptr)
\begin{DoxyCompactList}\small\item\em Pops element from the queue. If queue is empty, this call {\itshape blocks} waiting for another thread to push an new element to the queue or that the queue is set to inactive. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename It $>$ }\\unsigned \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_ade46e2fcb56b0e2d229a426331669e95}{pop\+\_\+blocking}} (It b, It e)
\begin{DoxyCompactList}\small\item\em Pops a range of elements from the queue. If queue is empty, this call {\itshape blocks} waiting for another thread to push a new element to the queue or that the queue is set to inactive. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a9629e8d8c25c557d0c60c36bd976cb96}{pop\+\_\+blocking}} (\mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ T $>$ t)
\begin{DoxyCompactList}\small\item\em Pops a span of elements from the queue. If queue is empty, this call {\itshape blocks} waiting for another thread to push a new element to the queue or that the queue is set to inactive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a920951341bb550f1638186c6c82b14d1}{result}} \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a60be2483f5e33466add8cb72d4f2bf7c}{pop\+\_\+wait\+\_\+for}} (T \&obj, std\+::chrono\+::microseconds duration)
\begin{DoxyCompactList}\small\item\em Pops an element from the queue. If the queue is empty, this call {\itshape blocks} waiting an element to be pushed to the queue or that the queue becomes inactive. This wait is bounded by {\ttfamily duration}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a920951341bb550f1638186c6c82b14d1}{result}} \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a05b6f6c8bf774466560f20cded038696}{pop\+\_\+wait\+\_\+until}} (T \&obj, std\+::chrono\+::steady\+\_\+clock\+::time\+\_\+point until)
\begin{DoxyCompactList}\small\item\em Pops an element from the queue. If the queue is empty, this call {\itshape blocks} waiting an element to be pushed to the queue or that the queue becomes inactive. This wait is bounded by {\ttfamily until}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Stop\+Condition $>$ }\\\mbox{\hyperlink{classsrsran_1_1optional}{optional}}$<$ T $>$ \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a38457312d2aaba0c8cb64e9823bec6f8}{pop\+\_\+and\+\_\+discard\+\_\+until}} (const Stop\+Condition \&stop\+\_\+condition)
\begin{DoxyCompactList}\small\item\em Keeps popping and discarding elements until the {\ttfamily stop\+\_\+condition} returns true. \end{DoxyCompactList}\item 
void {\bfseries clear} ()
\begin{DoxyCompactList}\small\item\em Clear all elements of the queue. \end{DoxyCompactList}\item 
size\+\_\+t {\bfseries size} () const
\begin{DoxyCompactList}\small\item\em Returns the number of elements stored in the queue. \end{DoxyCompactList}\item 
bool {\bfseries empty} () const
\begin{DoxyCompactList}\small\item\em Checks whether the queue is empty. \end{DoxyCompactList}\item 
bool {\bfseries full} () const
\begin{DoxyCompactList}\small\item\em Checks whether the queue is full. \end{DoxyCompactList}\item 
size\+\_\+t {\bfseries max\+\_\+size} () const
\begin{DoxyCompactList}\small\item\em Checks the maximum number of elements of the queue. \end{DoxyCompactList}\item 
bool {\bfseries is\+\_\+stopped} () const
\begin{DoxyCompactList}\small\item\em Checks whether the queue is inactive. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename F $>$ }\\bool {\bfseries try\+\_\+call\+\_\+on\+\_\+front} (const F \&f)
\begin{DoxyCompactList}\small\item\em Apply provided callable on first position of the queue. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename F $>$ }\\bool {\bfseries apply\+\_\+first} (const F \&func)
\begin{DoxyCompactList}\small\item\em Apply provided callable on elements of the queue, until the callable returns false. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{srsran\+::detail\+::base\+\_\+blocking\+\_\+queue$<$ Ring\+Buffer, Pushing\+Func, Popping\+Func $>$}}}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1detail_1_1base__blocking__queue_a920951341bb550f1638186c6c82b14d1}\label{classsrsran_1_1detail_1_1base__blocking__queue_a920951341bb550f1638186c6c82b14d1} 
enum class \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a920951341bb550f1638186c6c82b14d1}{result}} \{ {\bfseries failed}
, {\bfseries success}
, {\bfseries timeout}
 \}
\begin{DoxyCompactList}\small\item\em Possible outcomes for pop operation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes inherited from \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{srsran\+::detail\+::base\+\_\+blocking\+\_\+queue$<$ Ring\+Buffer, Pushing\+Func, Popping\+Func $>$}}}
\begin{DoxyCompactItemize}
\item 
Pushing\+Func {\bfseries push\+\_\+func}
\item 
Popping\+Func {\bfseries pop\+\_\+func}
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{srsran\+::detail\+::base\+\_\+blocking\+\_\+queue$<$ Ring\+Buffer, Pushing\+Func, Popping\+Func $>$}}}
\begin{DoxyCompactItemize}
\item 
bool {\bfseries wait\+\_\+push\+\_\+possible} (std\+::unique\+\_\+lock$<$ std\+::mutex $>$ \&lock, blocking\+\_\+tag)
\item 
bool {\bfseries wait\+\_\+push\+\_\+possible} (std\+::unique\+\_\+lock$<$ std\+::mutex $>$ \&, non\+\_\+blocking\+\_\+tag)
\item 
{\footnotesize template$<$typename Blocking\+Mode $>$ }\\bool {\bfseries push\+\_\+} (const T \&t, const Blocking\+Mode \&mode)
\item 
{\footnotesize template$<$typename Blocking\+Mode $>$ }\\\mbox{\hyperlink{classsrsran_1_1expected}{srsran\+::error\+\_\+type}}$<$ T $>$ {\bfseries push\+\_\+} (T \&\&t, const Blocking\+Mode \&mode)
\item 
{\footnotesize template$<$typename It , typename Blocking\+Mode $>$ }\\unsigned {\bfseries push\+\_\+} (It b, It e, const Blocking\+Mode \&mode)
\item 
void {\bfseries wait\+\_\+pop\+\_\+possible\+\_\+} (std\+::unique\+\_\+lock$<$ std\+::mutex $>$ \&lock, const blocking\+\_\+tag \&)
\item 
void {\bfseries wait\+\_\+pop\+\_\+possible\+\_\+} (std\+::unique\+\_\+lock$<$ std\+::mutex $>$ \&lock, const wait\+\_\+for\+\_\+tag \&duration)
\item 
void {\bfseries wait\+\_\+pop\+\_\+possible\+\_\+} (std\+::unique\+\_\+lock$<$ std\+::mutex $>$ \&lock, const wait\+\_\+until\+\_\+tag \&until)
\item 
bool {\bfseries wait\+\_\+pop\+\_\+possible} (std\+::unique\+\_\+lock$<$ std\+::mutex $>$ \&, const non\+\_\+blocking\+\_\+tag \&)
\item 
{\footnotesize template$<$typename Blocking\+Mode $>$ }\\bool {\bfseries wait\+\_\+pop\+\_\+possible} (std\+::unique\+\_\+lock$<$ std\+::mutex $>$ \&lock, const Blocking\+Mode \&mode)
\item 
{\footnotesize template$<$typename Blocking\+Mode $>$ }\\\mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue_a920951341bb550f1638186c6c82b14d1}{result}} {\bfseries pop\+\_\+} (T \&obj, const Blocking\+Mode \&mode)
\item 
{\footnotesize template$<$typename It , typename Blocking\+Mode $>$ }\\unsigned {\bfseries pop\+\_\+} (It b, It e, const Blocking\+Mode \&mode)
\item 
{\footnotesize template$<$typename Stop\+Condition $>$ }\\\mbox{\hyperlink{classsrsran_1_1optional}{optional}}$<$ T $>$ {\bfseries pop\+\_\+and\+\_\+discard\+\_\+until\+\_\+} (const Stop\+Condition \&cond)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \mbox{\hyperlink{classsrsran_1_1detail_1_1base__blocking__queue}{srsran\+::detail\+::base\+\_\+blocking\+\_\+queue$<$ Ring\+Buffer, Pushing\+Func, Popping\+Func $>$}}}
\begin{DoxyCompactItemize}
\item 
bool {\bfseries active} = true
\item 
uint8\+\_\+t {\bfseries nof\+\_\+waiting} = 0
\item 
std\+::mutex {\bfseries mutex}
\item 
std\+::condition\+\_\+variable {\bfseries cvar\+\_\+empty}
\item 
std\+::condition\+\_\+variable {\bfseries cvar\+\_\+full}
\item 
Ring\+Buffer {\bfseries ring\+\_\+buf}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T, typename Pushing\+Callback = detail\+::noop\+\_\+operation, typename Popping\+Callback = detail\+::noop\+\_\+operation$>$\newline
class srsran\+::blocking\+\_\+queue$<$ T, Pushing\+Callback, Popping\+Callback $>$}
Blocking queue with buffer storage represented via a std\+::vector$<$\+T$>$. Features\+:
\begin{DoxyItemize}
\item Blocking push/pop API via push\+\_\+blocking(...) and pop\+\_\+blocking(...) methods
\item Non-\/blocking push/pop API via try\+\_\+push(...) and try\+\_\+pop(...) methods
\item Size can be defined at runtime.
\item thread-\/safe 
\begin{DoxyTemplParams}{Template Parameters}
{\em T} & value type stored by buffer \\
\hline
{\em Pushing\+Callback} & function void(const T\&) called while pushing an element to the queue \\
\hline
{\em Popping\+Callback} & function void(const T\&) called while popping an element from the queue \\
\hline
\end{DoxyTemplParams}

\end{DoxyItemize}

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/srsran/adt/blocking\+\_\+queue.\+h\end{DoxyCompactItemize}
