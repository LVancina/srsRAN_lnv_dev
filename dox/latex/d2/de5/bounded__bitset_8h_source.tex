\doxysection{bounded\+\_\+bitset.\+h}
\hypertarget{bounded__bitset_8h_source}{}\label{bounded__bitset_8h_source}\index{include/srsran/adt/bounded\_bitset.h@{include/srsran/adt/bounded\_bitset.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{/*}}
\DoxyCodeLine{00002\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00003\ \textcolor{comment}{\ *\ Copyright\ 2021-\/2024\ Software\ Radio\ Systems\ Limited}}
\DoxyCodeLine{00004\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00005\ \textcolor{comment}{\ *\ This\ file\ is\ part\ of\ srsRAN.}}
\DoxyCodeLine{00006\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00007\ \textcolor{comment}{\ *\ srsRAN\ is\ free\ software:\ you\ can\ redistribute\ it\ and/or\ modify}}
\DoxyCodeLine{00008\ \textcolor{comment}{\ *\ it\ under\ the\ terms\ of\ the\ GNU\ Affero\ General\ Public\ License\ as}}
\DoxyCodeLine{00009\ \textcolor{comment}{\ *\ published\ by\ the\ Free\ Software\ Foundation,\ either\ version\ 3\ of}}
\DoxyCodeLine{00010\ \textcolor{comment}{\ *\ the\ License,\ or\ (at\ your\ option)\ any\ later\ version.}}
\DoxyCodeLine{00011\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00012\ \textcolor{comment}{\ *\ srsRAN\ is\ distributed\ in\ the\ hope\ that\ it\ will\ be\ useful,}}
\DoxyCodeLine{00013\ \textcolor{comment}{\ *\ but\ WITHOUT\ ANY\ WARRANTY;\ without\ even\ the\ implied\ warranty\ of}}
\DoxyCodeLine{00014\ \textcolor{comment}{\ *\ MERCHANTABILITY\ or\ FITNESS\ FOR\ A\ PARTICULAR\ PURPOSE.\ \ See\ the}}
\DoxyCodeLine{00015\ \textcolor{comment}{\ *\ GNU\ Affero\ General\ Public\ License\ for\ more\ details.}}
\DoxyCodeLine{00016\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00017\ \textcolor{comment}{\ *\ A\ copy\ of\ the\ GNU\ Affero\ General\ Public\ License\ can\ be\ found\ in}}
\DoxyCodeLine{00018\ \textcolor{comment}{\ *\ the\ LICENSE\ file\ in\ the\ top-\/level\ directory\ of\ this\ distribution}}
\DoxyCodeLine{00019\ \textcolor{comment}{\ *\ and\ at\ http://www.gnu.org/licenses/.}}
\DoxyCodeLine{00020\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00021\ \textcolor{comment}{\ */}}
\DoxyCodeLine{00022\ }
\DoxyCodeLine{00023\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{pragma}\ \textcolor{preprocessor}{once}}
\DoxyCodeLine{00024\ }
\DoxyCodeLine{00025\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/adt/span.h"{}}}
\DoxyCodeLine{00026\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/adt/static\_vector.h"{}}}
\DoxyCodeLine{00027\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/support/math\_utils.h"{}}}
\DoxyCodeLine{00028\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/support/srsran\_assert.h"{}}}
\DoxyCodeLine{00029\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}fmt/format.h"{}}}
\DoxyCodeLine{00030\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{<}\textcolor{preprocessor}{cstdint}\textcolor{preprocessor}{>}}
\DoxyCodeLine{00031\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{<}\textcolor{preprocessor}{inttypes}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}}
\DoxyCodeLine{00032\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{>}}
\DoxyCodeLine{00033\ }
\DoxyCodeLine{00034\ \textcolor{keyword}{namespace}\ \mbox{\hyperlink{namespacesrsran}{srsran}}\ \{}
\DoxyCodeLine{00035\ }
\DoxyCodeLine{00036\ \textcolor{comment}{///\ \(\backslash\)brief\ Returns\ an\ unsigned\ integer\ with\ the\ N\ most\ significant\ bits\ (MSB)\ set\ to\ zero,\ and\ the\ remaining\ bits\ set}}
\DoxyCodeLine{00037\ \textcolor{comment}{///\ to\ 1.}}
\DoxyCodeLine{00038\ \textcolor{comment}{///\ \(\backslash\)tparam\ Integer\ Type\ of\ unsigned\ integer\ returned\ by\ the\ function.}}
\DoxyCodeLine{00039\ \textcolor{comment}{///\ \(\backslash\)param[in]\ N\ Number\ of\ MSB\ bits\ set\ to\ zero.}}
\DoxyCodeLine{00040\ \textcolor{comment}{///\ \(\backslash\)return\ Resulting\ integer\ bitmap.}}
\DoxyCodeLine{00041\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer>}
\DoxyCodeLine{00042\ \textcolor{keyword}{constexpr}\ Integer\ \mbox{\hyperlink{namespacesrsran_a18dc114e4ba4bfc1c5631c9366c9377f}{mask\_msb\_zeros}}(size\_t\ N)}
\DoxyCodeLine{00043\ \{}
\DoxyCodeLine{00044\ \ \ \textcolor{keyword}{static\_assert}(std::is\_unsigned<Integer>::value,\ \textcolor{stringliteral}{"{}T\ must\ be\ unsigned\ integer"{}});}
\DoxyCodeLine{00045\ \ \ \textcolor{keywordflow}{return}\ (N\ ==\ 0)\ ?\ \textcolor{keyword}{static\_cast}<Integer>(-\/1)\ :\ (N\ ==\ \textcolor{keyword}{sizeof}(Integer)\ *\ 8U)\ ?\ 0\ :\ (\textcolor{keyword}{static\_cast}<Integer>(-\/1)\ >>\ (N));}
\DoxyCodeLine{00046\ \}}
\DoxyCodeLine{00047\ }
\DoxyCodeLine{00048\ \textcolor{comment}{///\ \(\backslash\)brief\ Returns\ an\ unsigned\ integer\ with\ the\ N\ least\ significant\ bits\ (LSB)\ set\ to\ zero,\ and\ the\ remaining\ bits\ set}}
\DoxyCodeLine{00049\ \textcolor{comment}{///\ to\ 1.}}
\DoxyCodeLine{00050\ \textcolor{comment}{///\ \(\backslash\)tparam\ Integer\ Type\ of\ unsigned\ integer\ returned\ by\ the\ function.}}
\DoxyCodeLine{00051\ \textcolor{comment}{///\ \(\backslash\)param[in]\ N\ Number\ of\ LSB\ bits\ set\ to\ zero.}}
\DoxyCodeLine{00052\ \textcolor{comment}{///\ \(\backslash\)return\ Resulting\ integer\ bitmap.}}
\DoxyCodeLine{00053\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer>}
\DoxyCodeLine{00054\ \textcolor{keyword}{constexpr}\ Integer\ \mbox{\hyperlink{namespacesrsran_a2472015ed75cf4b213db0205062fb54a}{mask\_lsb\_ones}}(size\_t\ N)}
\DoxyCodeLine{00055\ \{}
\DoxyCodeLine{00056\ \ \ \textcolor{keywordflow}{return}\ mask\_msb\_zeros<Integer>(\textcolor{keyword}{sizeof}(Integer)\ *\ 8U\ -\/\ N);}
\DoxyCodeLine{00057\ \}}
\DoxyCodeLine{00058\ }
\DoxyCodeLine{00059\ \textcolor{comment}{///\ \(\backslash\)brief\ Returns\ an\ unsigned\ integer\ with\ the\ N\ most\ significant\ bits\ (MSB)\ set\ to\ one,\ and\ the\ remaining\ bits\ set}}
\DoxyCodeLine{00060\ \textcolor{comment}{///\ to\ zero.}}
\DoxyCodeLine{00061\ \textcolor{comment}{///\ \(\backslash\)tparam\ Integer\ Type\ of\ unsigned\ integer\ returned\ by\ the\ function.}}
\DoxyCodeLine{00062\ \textcolor{comment}{///\ \(\backslash\)param[in]\ N\ Number\ of\ MSB\ bits\ set\ to\ one.}}
\DoxyCodeLine{00063\ \textcolor{comment}{///\ \(\backslash\)return\ Resulting\ integer\ bitmap.}}
\DoxyCodeLine{00064\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer>}
\DoxyCodeLine{00065\ \textcolor{keyword}{constexpr}\ Integer\ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{mask\_msb\_ones}}(size\_t\ N)}
\DoxyCodeLine{00066\ \{}
\DoxyCodeLine{00067\ \ \ \textcolor{keywordflow}{return}\ \string~mask\_msb\_zeros<Integer>(N);}
\DoxyCodeLine{00068\ \}}
\DoxyCodeLine{00069\ }
\DoxyCodeLine{00070\ \textcolor{comment}{///\ \(\backslash\)brief\ Returns\ an\ unsigned\ integer\ with\ the\ N\ least\ significant\ bits\ (LSB)\ set\ to\ one,\ and\ the\ remaining\ bits\ set}}
\DoxyCodeLine{00071\ \textcolor{comment}{///\ to\ zero.}}
\DoxyCodeLine{00072\ \textcolor{comment}{///\ \(\backslash\)tparam\ Integer\ Type\ of\ unsigned\ integer\ returned\ by\ the\ function.}}
\DoxyCodeLine{00073\ \textcolor{comment}{///\ \(\backslash\)param[in]\ N\ Number\ of\ LSB\ bits\ set\ to\ one.}}
\DoxyCodeLine{00074\ \textcolor{comment}{///\ \(\backslash\)return\ Resulting\ integer\ bitmap.}}
\DoxyCodeLine{00075\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer>}
\DoxyCodeLine{00076\ Integer\ \mbox{\hyperlink{namespacesrsran_a85885a2aee853ee4a682bffd9c5fe339}{mask\_lsb\_zeros}}(size\_t\ N)}
\DoxyCodeLine{00077\ \{}
\DoxyCodeLine{00078\ \ \ \textcolor{keywordflow}{return}\ \string~mask\_lsb\_ones<Integer>(N);}
\DoxyCodeLine{00079\ \}}
\DoxyCodeLine{00080\ }
\DoxyCodeLine{00081\ \textcolor{keyword}{namespace}\ detail\ \{}
\DoxyCodeLine{00082\ }
\DoxyCodeLine{00083\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer>}
\DoxyCodeLine{00084\ \textcolor{keyword}{struct}\ \mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper}{bitset\_builtin\_helper}}\ \{}
\DoxyCodeLine{00085\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Returns\ the\ number\ of\ leading\ 0-\/bits\ in\ value,\ starting\ at\ the\ most\ significant\ bit\ position.}}
\DoxyCodeLine{00086\ \ \ \textcolor{comment}{///\ If\ value\ is\ 0,\ the\ result\ is\ number\ of\ bits\ of\ Integer.}}
\DoxyCodeLine{00087\ \ \ \textcolor{keyword}{static}\ Integer\ \mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper_a53595ce349de635eac69aeb81ea2769a}{zero\_msb\_count}}(Integer\ value)}
\DoxyCodeLine{00088\ \ \ \{}
\DoxyCodeLine{00089\ \ \ \ \ \textcolor{keywordflow}{if}\ (value\ ==\ 0)\ \{}
\DoxyCodeLine{00090\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::numeric\_limits<Integer>::digits;}
\DoxyCodeLine{00091\ \ \ \ \ \}}
\DoxyCodeLine{00092\ \ \ \ \ Integer\ ret\ =\ 0;}
\DoxyCodeLine{00093\ \ \ \ \ \textcolor{keywordflow}{for}\ (Integer\ shift\ =\ std::numeric\_limits<Integer>::digits\ >>\ 1;\ shift\ !=\ 0;\ shift\ >>=\ 1)\ \{}
\DoxyCodeLine{00094\ \ \ \ \ \ \ Integer\ tmp\ =\ value\ >>\ shift;}
\DoxyCodeLine{00095\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (tmp\ !=\ 0)\ \{}
\DoxyCodeLine{00096\ \ \ \ \ \ \ \ \ value\ =\ tmp;}
\DoxyCodeLine{00097\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00098\ \ \ \ \ \ \ \ \ ret\ |=\ shift;}
\DoxyCodeLine{00099\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00100\ \ \ \ \ \}}
\DoxyCodeLine{00101\ \ \ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{00102\ \ \ \}}
\DoxyCodeLine{00103\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Returns\ the\ number\ of\ trailing\ 0-\/bits\ in\ value,\ starting\ at\ the\ least\ significant\ bit\ position.}}
\DoxyCodeLine{00104\ \ \ \textcolor{comment}{///\ If\ value\ is\ 0,\ the\ result\ is\ number\ of\ bits\ of\ Integer.}}
\DoxyCodeLine{00105\ \ \ \textcolor{keyword}{static}\ Integer\ \mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper_a25f1d87703cf614e05ce7a0b005e653d}{zero\_lsb\_count}}(Integer\ value)}
\DoxyCodeLine{00106\ \ \ \{}
\DoxyCodeLine{00107\ \ \ \ \ \textcolor{keywordflow}{if}\ (value\ ==\ 0)\ \{}
\DoxyCodeLine{00108\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::numeric\_limits<Integer>::digits;}
\DoxyCodeLine{00109\ \ \ \ \ \}}
\DoxyCodeLine{00110\ \ \ \ \ Integer\ ret\ =\ 0;}
\DoxyCodeLine{00111\ \ \ \ \ \textcolor{keywordflow}{for}\ (Integer\ shift\ =\ std::numeric\_limits<Integer>::digits\ >>\ 1,\ mask\ =\ std::numeric\_limits<Integer>::max()\ >>\ shift;}
\DoxyCodeLine{00112\ \ \ \ \ \ \ \ \ \ shift\ !=\ 0;}
\DoxyCodeLine{00113\ \ \ \ \ \ \ \ \ \ shift\ >>=\ 1,\ mask\ >>=\ shift)\ \{}
\DoxyCodeLine{00114\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((value\ \&\ mask)\ ==\ 0)\ \{}
\DoxyCodeLine{00115\ \ \ \ \ \ \ \ \ value\ >>=\ shift;}
\DoxyCodeLine{00116\ \ \ \ \ \ \ \ \ ret\ |=\ shift;}
\DoxyCodeLine{00117\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00118\ \ \ \ \ \}}
\DoxyCodeLine{00119\ \ \ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{00120\ \ \ \}}
\DoxyCodeLine{00121\ }
\DoxyCodeLine{00122\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Returns\ the\ number\ of\ 1-\/bits\ in\ value.}}
\DoxyCodeLine{00123\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper_a737549eb4251f0ae0e89005ca8db2ace}{count\_ones}}(Integer\ value)}
\DoxyCodeLine{00124\ \ \ \{}
\DoxyCodeLine{00125\ \ \ \ \ \textcolor{comment}{//\ Note:\ use\ an\ "{}int"{}\ for\ count\ triggers\ popcount\ optimization\ if\ SSE\ instructions\ are\ enabled.}}
\DoxyCodeLine{00126\ \ \ \ \ \textcolor{keywordtype}{int}\ c\ =\ 0;}
\DoxyCodeLine{00127\ \ \ \ \ \textcolor{keywordflow}{for}\ (Integer\ w\ =\ value;\ w\ >\ 0;\ c++)\ \{}
\DoxyCodeLine{00128\ \ \ \ \ \ \ w\ \&=\ w\ -\/\ 1;}
\DoxyCodeLine{00129\ \ \ \ \ \}}
\DoxyCodeLine{00130\ \ \ \ \ \textcolor{keywordflow}{return}\ c;}
\DoxyCodeLine{00131\ \ \ \}}
\DoxyCodeLine{00132\ \};}
\DoxyCodeLine{00133\ }
\DoxyCodeLine{00134\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{ifdef}\ \_\_GNUC\_\_\ \textcolor{comment}{//\ clang\ and\ gcc}}
\DoxyCodeLine{00135\ }
\DoxyCodeLine{00136\ \textcolor{comment}{///\ Specializations\ of\ bitset\ operations\ for\ unsigned.}}
\DoxyCodeLine{00137\ \textcolor{keyword}{template}\ <>}
\DoxyCodeLine{00138\ \textcolor{keyword}{struct}\ \mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper}{bitset\_builtin\_helper}}<\textcolor{keywordtype}{unsigned}>\ \{}
\DoxyCodeLine{00139\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{unsigned}\ zero\_msb\_count(\textcolor{keywordtype}{unsigned}\ value)}
\DoxyCodeLine{00140\ \ \ \{}
\DoxyCodeLine{00141\ \ \ \ \ \textcolor{keywordflow}{return}\ (value)\ ?\ \_\_builtin\_clz(value)\ :\ std::numeric\_limits<\textcolor{keywordtype}{unsigned}>::digits;}
\DoxyCodeLine{00142\ \ \ \}}
\DoxyCodeLine{00143\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{unsigned}\ zero\_lsb\_count(\textcolor{keywordtype}{unsigned}\ value)}
\DoxyCodeLine{00144\ \ \ \{}
\DoxyCodeLine{00145\ \ \ \ \ \textcolor{keywordflow}{return}\ (value)\ ?\ \_\_builtin\_ctz(value)\ :\ std::numeric\_limits<\textcolor{keywordtype}{unsigned}>::digits;}
\DoxyCodeLine{00146\ \ \ \}}
\DoxyCodeLine{00147\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{int}\ count\_ones(\textcolor{keywordtype}{unsigned}\ value)\ \{\ \textcolor{keywordflow}{return}\ \_\_builtin\_popcount(value);\ \}}
\DoxyCodeLine{00148\ \};}
\DoxyCodeLine{00149\ }
\DoxyCodeLine{00150\ \textcolor{comment}{///\ Specializations\ of\ bitset\ operations\ for\ unsigned\ long.}}
\DoxyCodeLine{00151\ \textcolor{keyword}{template}\ <>}
\DoxyCodeLine{00152\ \textcolor{keyword}{struct}\ \mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper}{bitset\_builtin\_helper}}<\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}>\ \{}
\DoxyCodeLine{00153\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ zero\_msb\_count(\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ value)}
\DoxyCodeLine{00154\ \ \ \{}
\DoxyCodeLine{00155\ \ \ \ \ \textcolor{keywordflow}{return}\ (value)\ ?\ \_\_builtin\_clzl(value)\ :\ std::numeric\_limits<\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}>::digits;}
\DoxyCodeLine{00156\ \ \ \}}
\DoxyCodeLine{00157\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ zero\_lsb\_count(\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ value)}
\DoxyCodeLine{00158\ \ \ \{}
\DoxyCodeLine{00159\ \ \ \ \ \textcolor{keywordflow}{return}\ (value)\ ?\ \_\_builtin\_ctzl(value)\ :\ std::numeric\_limits<\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}>::digits;}
\DoxyCodeLine{00160\ \ \ \}}
\DoxyCodeLine{00161\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{int}\ count\_ones(\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ value)\ \{\ \textcolor{keywordflow}{return}\ \_\_builtin\_popcountl(value);\ \}}
\DoxyCodeLine{00162\ \};}
\DoxyCodeLine{00163\ }
\DoxyCodeLine{00164\ \textcolor{comment}{///\ Specializations\ of\ bitset\ operations\ for\ unsigned\ long\ long.}}
\DoxyCodeLine{00165\ \textcolor{keyword}{template}\ <>}
\DoxyCodeLine{00166\ \textcolor{keyword}{struct}\ \mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper}{bitset\_builtin\_helper}}<\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}>\ \{}
\DoxyCodeLine{00167\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\ zero\_msb\_count(\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\ value)}
\DoxyCodeLine{00168\ \ \ \{}
\DoxyCodeLine{00169\ \ \ \ \ \textcolor{keywordflow}{return}\ (value)\ ?\ \_\_builtin\_clzll(value)\ :\ std::numeric\_limits<\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}>::digits;}
\DoxyCodeLine{00170\ \ \ \}}
\DoxyCodeLine{00171\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\ zero\_lsb\_count(\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\ value)}
\DoxyCodeLine{00172\ \ \ \{}
\DoxyCodeLine{00173\ \ \ \ \ \textcolor{keywordflow}{return}\ (value)\ ?\ \_\_builtin\_ctzll(value)\ :\ std::numeric\_limits<\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}>::digits;}
\DoxyCodeLine{00174\ \ \ \}}
\DoxyCodeLine{00175\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{int}\ count\_ones(\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\ value)\ \{\ \textcolor{keywordflow}{return}\ \_\_builtin\_popcountll(value);\ \}}
\DoxyCodeLine{00176\ \};}
\DoxyCodeLine{00177\ }
\DoxyCodeLine{00178\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{endif}}
\DoxyCodeLine{00179\ }
\DoxyCodeLine{00180\ \textcolor{comment}{///\ \(\backslash\)brief\ Knuth's\ swap\ of\ upper\ and\ lower\ sections\ of\ a\ bitset.}}
\DoxyCodeLine{00181\ \textcolor{comment}{///\ \(\backslash\)param\ m\ Mask\ of\ bits\ to\ swap.}}
\DoxyCodeLine{00182\ \textcolor{comment}{///\ \(\backslash\)param\ k\ shift\ amount.}}
\DoxyCodeLine{00183\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ T\ m,\ \textcolor{keywordtype}{int}\ k>}
\DoxyCodeLine{00184\ T\ swapbits(T\ p)}
\DoxyCodeLine{00185\ \{}
\DoxyCodeLine{00186\ \ \ T\ q\ =\ ((p\ >>\ k)\ \string^\ p)\ \&\ m;}
\DoxyCodeLine{00187\ \ \ \textcolor{keywordflow}{return}\ p\ \string^\ q\ \string^\ (q\ <<\ k);}
\DoxyCodeLine{00188\ \}}
\DoxyCodeLine{00189\ }
\DoxyCodeLine{00190\ \}\ \textcolor{comment}{//\ namespace\ detail}}
\DoxyCodeLine{00191\ }
\DoxyCodeLine{00192\ \textcolor{comment}{///\ \(\backslash\)brief\ Knuth's\ 64-\/bit\ reverse.\ E.g.\ 0x0000000000000001\ -\/>\ 0x8000000000000000.}}
\DoxyCodeLine{00193\ \textcolor{comment}{///\ For\ more\ information\ see:\ https://matthewarcus.wordpress.com/2012/11/18/reversing-\/a-\/64-\/bit-\/word/}}
\DoxyCodeLine{00194\ \textcolor{comment}{///\ \(\backslash\)param\ n\ Number\ to\ reverse.}}
\DoxyCodeLine{00195\ \textcolor{comment}{///\ \(\backslash\)return\ Reversed\ number.}}
\DoxyCodeLine{00196\ \textcolor{keyword}{inline}\ uint64\_t\ \mbox{\hyperlink{namespacesrsran_a8d6d50503ddb80d596cf9fbeea68bd11}{bit\_reverse}}(uint64\_t\ n)}
\DoxyCodeLine{00197\ \{}
\DoxyCodeLine{00198\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ uint64\_t\ m0\ =\ 0x5555555555555555LLU;}
\DoxyCodeLine{00199\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ uint64\_t\ m1\ =\ 0x0300c0303030c303LLU;}
\DoxyCodeLine{00200\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ uint64\_t\ m2\ =\ 0x00c0300c03f0003fLLU;}
\DoxyCodeLine{00201\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ uint64\_t\ m3\ =\ 0x00000ffc00003fffLLU;}
\DoxyCodeLine{00202\ \ \ n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ ((n\ >>\ 1U)\ \&\ m0)\ |\ (n\ \&\ m0)\ <<\ 1U;}
\DoxyCodeLine{00203\ \ \ n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ detail::swapbits<uint64\_t,\ m1,\ 4>(n);}
\DoxyCodeLine{00204\ \ \ n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ detail::swapbits<uint64\_t,\ m2,\ 8>(n);}
\DoxyCodeLine{00205\ \ \ n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ detail::swapbits<uint64\_t,\ m3,\ 20>(n);}
\DoxyCodeLine{00206\ \ \ n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ (n\ >>\ 34U)\ |\ (n\ <<\ 30U);}
\DoxyCodeLine{00207\ \ \ \textcolor{keywordflow}{return}\ n;}
\DoxyCodeLine{00208\ \}}
\DoxyCodeLine{00209\ }
\DoxyCodeLine{00210\ \textcolor{comment}{///\ \(\backslash\)brief\ Counts\ the\ number\ of\ contiguous\ bits\ set\ to\ zero,\ starting\ from\ the\ MSB.}}
\DoxyCodeLine{00211\ \textcolor{comment}{///\ \(\backslash\)tparam\ Integer\ Integer\ type\ of\ received\ bitmap.}}
\DoxyCodeLine{00212\ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ Integer\ bitmap}}
\DoxyCodeLine{00213\ \textcolor{comment}{///\ \(\backslash\)return\ count\ of\ bits\ set\ to\ zero.}}
\DoxyCodeLine{00214\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer>}
\DoxyCodeLine{00215\ Integer\ \mbox{\hyperlink{namespacesrsran_afa37bb7085b0c703d1f277b3df6535f2}{zero\_msb\_count}}(Integer\ value)}
\DoxyCodeLine{00216\ \{}
\DoxyCodeLine{00217\ \ \ \textcolor{keywordflow}{return}\ (\string~value)\ ?\ detail::\mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper}{bitset\_builtin\_helper}}<Integer>::zero\_msb\_count(value)\ :\ 0;}
\DoxyCodeLine{00218\ \}}
\DoxyCodeLine{00219\ }
\DoxyCodeLine{00220\ \textcolor{comment}{///\ \(\backslash\)brief\ Finds\ the\ position\ of\ the\ first\ bit\ set\ to\ one,\ starting\ from\ the\ MSB.}}
\DoxyCodeLine{00221\ \textcolor{comment}{///\ \(\backslash\)tparam\ Integer\ Integer\ type\ of\ received\ bitmap.}}
\DoxyCodeLine{00222\ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ Integer\ bitmap}}
\DoxyCodeLine{00223\ \textcolor{comment}{///\ \(\backslash\)return\ MSB\ position\ with\ the\ bit\ set\ to\ one.\ The\ MSB\ has\ position\ sizeof(Integer)\ *\ 8\ -\/\ 1.}}
\DoxyCodeLine{00224\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer>}
\DoxyCodeLine{00225\ Integer\ \mbox{\hyperlink{namespacesrsran_a4658449de31232ac5199c4043a51e10f}{find\_first\_msb\_one}}(Integer\ value)}
\DoxyCodeLine{00226\ \{}
\DoxyCodeLine{00227\ \ \ \textcolor{keywordflow}{return}\ (value)\ ?\ (\textcolor{keyword}{sizeof}(Integer)\ *\ 8U\ -\/\ 1\ -\/\ detail::\mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper}{bitset\_builtin\_helper}}<Integer>::zero\_msb\_count(value))}
\DoxyCodeLine{00228\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ std::numeric\_limits<Integer>::digits;}
\DoxyCodeLine{00229\ \}}
\DoxyCodeLine{00230\ }
\DoxyCodeLine{00231\ \textcolor{comment}{///\ \(\backslash\)brief\ Finds\ the\ position\ of\ the\ first\ bit\ set\ to\ one,\ starting\ from\ the\ LSB.}}
\DoxyCodeLine{00232\ \textcolor{comment}{///\ \(\backslash\)tparam\ Integer\ Integer\ type\ of\ received\ bitmap.}}
\DoxyCodeLine{00233\ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ Integer\ bitmap}}
\DoxyCodeLine{00234\ \textcolor{comment}{///\ \(\backslash\)return\ LSB\ position\ with\ the\ bit\ set\ to\ one.\ The\ LSB\ has\ position\ zero.}}
\DoxyCodeLine{00235\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer>}
\DoxyCodeLine{00236\ Integer\ \mbox{\hyperlink{namespacesrsran_afbd54bf8abd1c6764052dc25dc6a29ca}{find\_first\_lsb\_one}}(Integer\ value)}
\DoxyCodeLine{00237\ \{}
\DoxyCodeLine{00238\ \ \ \textcolor{keywordflow}{return}\ detail::\mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper}{bitset\_builtin\_helper}}<Integer>::zero\_lsb\_count(value);}
\DoxyCodeLine{00239\ \}}
\DoxyCodeLine{00240\ }
\DoxyCodeLine{00241\ \textcolor{comment}{///\ \(\backslash\)brief\ Counts\ the\ number\ of\ bits\ set\ to\ one\ in\ an\ integer.}}
\DoxyCodeLine{00242\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer>}
\DoxyCodeLine{00243\ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{namespacesrsran_a96f5121e3f7239682263eb7f0c798457}{count\_ones}}(Integer\ value)}
\DoxyCodeLine{00244\ \{}
\DoxyCodeLine{00245\ \ \ \textcolor{keywordflow}{return}\ detail::\mbox{\hyperlink{structsrsran_1_1detail_1_1bitset__builtin__helper}{bitset\_builtin\_helper}}<Integer>::count\_ones(value);}
\DoxyCodeLine{00246\ \}}
\DoxyCodeLine{00247\ }
\DoxyCodeLine{00248\ \textcolor{comment}{///\ \(\backslash\)brief\ Represents\ a\ dynamically-\/sized\ bitset\ with\ an\ upper\ bound\ capacity\ of\ N\ bits.}}
\DoxyCodeLine{00249\ \textcolor{comment}{///}}
\DoxyCodeLine{00250\ \textcolor{comment}{///\ The\ bounded\_bitset\ is\ represented\ internally\ via\ an\ array\ of\ uint64\_t,\ with\ each\ integer\ storing\ a\ bitmap.}}
\DoxyCodeLine{00251\ \textcolor{comment}{///\ This\ class\ also\ offers\ many\ standard\ logic\ manipulation\ methods,\ like\ ::any(),\ operators\ \&=,\ \&,\ |=,\ |,\ etc.\ and}}
\DoxyCodeLine{00252\ \textcolor{comment}{///\ utility\ methods\ to\ convert\ the\ bitset\ into\ strings\ or\ integers.}}
\DoxyCodeLine{00253\ \textcolor{comment}{///}}
\DoxyCodeLine{00254\ \textcolor{comment}{///\ Depending\ on\ the\ passed\ \(\backslash\)c\ LowestInfoBitIsMSB\ template\ argument,\ this\ class\ can\ represent\ the\ bits\ of\ the\ bitset\ in}}
\DoxyCodeLine{00255\ \textcolor{comment}{///\ different\ orders.\ E.g.}}
\DoxyCodeLine{00256\ \textcolor{comment}{///}}
\DoxyCodeLine{00257\ \textcolor{comment}{///\ bounded\_bitset<6,\ false>\ a(5);\ //\ Bitset\ of\ 5\ bits.\ LSB\ is\ Lowest\ Information\ Bit\ (bit\ 0).}}
\DoxyCodeLine{00258\ \textcolor{comment}{///\ a.set(0);}}
\DoxyCodeLine{00259\ \textcolor{comment}{///\ assert(a.to\_uint64()\ ==\ 0b1);}}
\DoxyCodeLine{00260\ \textcolor{comment}{///\ bounded\_bitset<6,\ true>\ b(5);\ //\ Bitset\ of\ 5\ bits.\ MSB\ is\ Lowest\ Information\ Bit\ (bit\ 0).}}
\DoxyCodeLine{00261\ \textcolor{comment}{///\ b.set(1);}}
\DoxyCodeLine{00262\ \textcolor{comment}{///\ assert(a.to\_uint64()\ ==\ 0b1000);}}
\DoxyCodeLine{00263\ \textcolor{comment}{///}}
\DoxyCodeLine{00264\ \textcolor{comment}{///\ The\ \(\backslash\)c\ LowestInfoBitIsMSB\ template\ argument\ also\ affects\ the\ default\ string\ representation\ of\ the\ bitset.\ E.g.}}
\DoxyCodeLine{00265\ \textcolor{comment}{///\ fmt::print("{}\{:b\}"{},\ a);\ //\ prints\ "{}00001"{}.}}
\DoxyCodeLine{00266\ \textcolor{comment}{///\ fmt::print("{}\{:x\}"{},\ a);\ //\ prints\ "{}1"{}.}}
\DoxyCodeLine{00267\ \textcolor{comment}{///\ fmt::print("{}\{:b\}"{},\ b);\ //\ prints\ "{}01000"{}.}}
\DoxyCodeLine{00268\ \textcolor{comment}{///\ fmt::print("{}\{:x\}"{},\ b);\ //\ prints\ "{}8"{}.}}
\DoxyCodeLine{00269\ \textcolor{comment}{///}}
\DoxyCodeLine{00270\ \textcolor{comment}{///\ However,\ it\ does\ not\ affect\ the\ information\ bit\ position\ string\ representation,\ e.g.}}
\DoxyCodeLine{00271\ \textcolor{comment}{///\ fmt::print("{}\{:n\}"{},\ a);\ //\ prints\ "{}0"{}.}}
\DoxyCodeLine{00272\ \textcolor{comment}{///\ fmt::print("{}\{:n\}"{},\ b);\ //\ prints\ "{}1"{}.}}
\DoxyCodeLine{00273\ \textcolor{comment}{///}}
\DoxyCodeLine{00274\ \textcolor{comment}{///\ \(\backslash\)tparam\ N\ Upper\ bound\ for\ bitset\ size\ in\ number\ of\ bits.}}
\DoxyCodeLine{00275\ \textcolor{comment}{///\ \(\backslash\)tparam\ LowestInfoBitIsMSB\ Bit\ index\ order\ in\ memory.\ If\ set\ to\ (false\ /\ true),\ the\ bit\ index\ 0\ (Lowest\ Information}}
\DoxyCodeLine{00276\ \textcolor{comment}{///\ Bit)\ corresponds\ to\ either\ the\ LSB\ or\ MSB\ of\ the\ bitset.\ Note\ that\ this\ argument\ has\ an\ effect\ on\ the\ underlying}}
\DoxyCodeLine{00277\ \textcolor{comment}{///\ bitset\ memory\ layout.}}
\DoxyCodeLine{00278\ \textcolor{keyword}{template}\ <size\_t\ N,\ \textcolor{keywordtype}{bool}\ LowestInfoBitIsMSB\ =\ \textcolor{keyword}{false}>}
\DoxyCodeLine{00279\ \textcolor{keyword}{class}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}}
\DoxyCodeLine{00280\ \{}
\DoxyCodeLine{00281\ \ \ \textcolor{keyword}{using}\ word\_t\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ uint64\_t;}
\DoxyCodeLine{00282\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ size\_t\ bits\_per\_word\ =\ 8U\ *\ \textcolor{keyword}{sizeof}(\mbox{\hyperlink{classsrsran_1_1bounded__bitset}{word\_t}});}
\DoxyCodeLine{00283\ }
\DoxyCodeLine{00284\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00285\ \ \ \textcolor{keyword}{constexpr}\ bounded\_bitset()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{00286\ }
\DoxyCodeLine{00287\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{explicit}\ bounded\_bitset(size\_t\ cur\_size\_)\ :\ cur\_size(cur\_size\_)}
\DoxyCodeLine{00288\ \ \ \{}
\DoxyCodeLine{00289\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(cur\_size\_\ <=\ N,\ \textcolor{stringliteral}{"{}The\ bounded\_bitset\ current\ size\ cannot\ exceed\ its\ maximum\ size"{}});}
\DoxyCodeLine{00290\ \ \ \}}
\DoxyCodeLine{00291\ }
\DoxyCodeLine{00292\ \ \ \textcolor{keyword}{constexpr}\ bounded\_bitset(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}\&\ other)\ \textcolor{keyword}{noexcept}\ :\ cur\_size(other.cur\_size)}
\DoxyCodeLine{00293\ \ \ \{}
\DoxyCodeLine{00294\ \ \ \ \ std::copy(other.buffer.begin(),\ other.buffer.begin()\ +\ nof\_words\_(),\ buffer.begin());}
\DoxyCodeLine{00295\ \ \ \}}
\DoxyCodeLine{00296\ }
\DoxyCodeLine{00297\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Constructs\ a\ bitset\ using\ iterators.}}
\DoxyCodeLine{00298\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00299\ \ \ \textcolor{comment}{///\ The\ constructed\ bitset\ size\ is\ equal\ to\ <tt>\ end\ -\/\ begin\ </tt>\ size.\ The\ values\ in\ the\ list\ are\ mapped\ one\ to\ one}}
\DoxyCodeLine{00300\ \ \ \textcolor{comment}{///\ starting\ from\ begin.}}
\DoxyCodeLine{00301\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00302\ \ \ \textcolor{comment}{///\ \(\backslash\)tparam\ Iterator\ Boolean\ iterator\ type.}}
\DoxyCodeLine{00303\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ begin\ Begin\ iterator.}}
\DoxyCodeLine{00304\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ end\ End\ iterator.}}
\DoxyCodeLine{00305\ \ \ \textcolor{keyword}{template}\ <}
\DoxyCodeLine{00306\ \ \ \ \ \ \ \textcolor{keyword}{typename}\ Iterator,}
\DoxyCodeLine{00307\ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::enable\_if\_t<std::is\_convertible<\textcolor{keyword}{typename}\ std::iterator\_traits<Iterator>::value\_type,\ \textcolor{keywordtype}{bool}>::value,}
\DoxyCodeLine{00308\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}>\ =\ 0>}
\DoxyCodeLine{00309\ \ \ \textcolor{keyword}{constexpr}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a10740b922478ca7cbc464953929a3652}{bounded\_bitset}}(Iterator\ begin,\ Iterator\ end)}
\DoxyCodeLine{00310\ \ \ \{}
\DoxyCodeLine{00311\ \ \ \ \ resize(end\ -\/\ begin);}
\DoxyCodeLine{00312\ \ \ \ \ std::for\_each(begin,\ end,\ [\textcolor{keyword}{this},\ n\ =\ 0](\textcolor{keywordtype}{bool}\ value)\ \textcolor{keyword}{mutable}\ \{}
\DoxyCodeLine{00313\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (value)\ \{}
\DoxyCodeLine{00314\ \ \ \ \ \ \ \ \ set\_(n);}
\DoxyCodeLine{00315\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00316\ \ \ \ \ \ \ \ \ reset\_(n);}
\DoxyCodeLine{00317\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00318\ \ \ \ \ \ \ ++n;}
\DoxyCodeLine{00319\ \ \ \ \ \});}
\DoxyCodeLine{00320\ \ \ \}}
\DoxyCodeLine{00321\ }
\DoxyCodeLine{00322\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Constructs\ a\ bitset\ from\ an\ initializer\ list.}}
\DoxyCodeLine{00323\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00324\ \ \ \textcolor{comment}{///\ The\ constructed\ bitset\ size\ is\ equal\ to\ \(\backslash\)c\ values\ size.\ The\ values\ in\ the\ list\ are\ mapped\ one\ to\ one.}}
\DoxyCodeLine{00325\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00326\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ values\ Boolean\ initializer\ list.}}
\DoxyCodeLine{00327\ \ \ \textcolor{keyword}{constexpr}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_aa708fd53ceb8ec0e4d5ea92d88835377}{bounded\_bitset}}(\textcolor{keyword}{const}\ std::initializer\_list<\textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}>\&\ values)}
\DoxyCodeLine{00328\ \ \ \{}
\DoxyCodeLine{00329\ \ \ \ \ resize(values.size());}
\DoxyCodeLine{00330\ \ \ \ \ std::for\_each(values.begin(),\ values.end(),\ [\textcolor{keyword}{this},\ n\ =\ 0](\textcolor{keywordtype}{bool}\ value)\ \textcolor{keyword}{mutable}\ \{}
\DoxyCodeLine{00331\ \ \ \ \ \ \ assert\_within\_bounds\_(n,\ \textcolor{keyword}{true});}
\DoxyCodeLine{00332\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (value)\ \{}
\DoxyCodeLine{00333\ \ \ \ \ \ \ \ \ set\_(n);}
\DoxyCodeLine{00334\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00335\ \ \ \ \ \ \ \ \ reset\_(n);}
\DoxyCodeLine{00336\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00337\ \ \ \ \ \ \ ++n;}
\DoxyCodeLine{00338\ \ \ \ \ \});}
\DoxyCodeLine{00339\ \ \ \}}
\DoxyCodeLine{00340\ }
\DoxyCodeLine{00341\ \ \ \textcolor{keyword}{constexpr}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ operator=(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}\&\ other)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00342\ \ \ \{}
\DoxyCodeLine{00343\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{this}\ !=\ \&other)\ \{}
\DoxyCodeLine{00344\ \ \ \ \ \ \ \textcolor{comment}{//\ In\ case\ of\ shrink,\ reset\ erased\ bits.}}
\DoxyCodeLine{00345\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ other.nof\_words\_();\ i\ <\ nof\_words\_();\ ++i)\ \{}
\DoxyCodeLine{00346\ \ \ \ \ \ \ \ \ buffer[i]\ =\ \textcolor{keyword}{static\_cast}<word\_t>(0);}
\DoxyCodeLine{00347\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00348\ \ \ \ \ \ \ cur\_size\ =\ other.cur\_size;}
\DoxyCodeLine{00349\ \ \ \ \ \ \ std::copy(other.buffer.begin(),\ other.buffer.begin()\ +\ nof\_words\_(),\ buffer.begin());}
\DoxyCodeLine{00350\ \ \ \ \ \}}
\DoxyCodeLine{00351\ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{00352\ \ \ \}}
\DoxyCodeLine{00353\ }
\DoxyCodeLine{00354\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ bit\_order()\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ LowestInfoBitIsMSB;\ \}}
\DoxyCodeLine{00355\ }
\DoxyCodeLine{00356\ \ \ \textcolor{comment}{///\ Capacity\ of\ the\ bounded\_bitset\ in\ bits.}}
\DoxyCodeLine{00357\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a0562e07ebfc14914b8f350c2491ce402}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a0562e07ebfc14914b8f350c2491ce402}{max\_size}}()\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ N;\ \}}
\DoxyCodeLine{00358\ }
\DoxyCodeLine{00359\ \ \ \textcolor{comment}{///\ Current\ size\ of\ the\ bounded\_bitset\ in\ bits.}}
\DoxyCodeLine{00360\ \ \ \mbox{\hyperlink{compiler_8h_a88276d6141c7aec6bf2376d2f5eb650a}{SRSRAN\_FORCE\_INLINE}}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a0409da263eb1ccdc8cb491aac2a43bda}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a0409da263eb1ccdc8cb491aac2a43bda}{size}}()\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ cur\_size;\ \}}
\DoxyCodeLine{00361\ }
\DoxyCodeLine{00362\ \ \ \textcolor{comment}{///\ Returns\ true\ if\ the\ bounded\_bitset\ size\ is\ 0.}}
\DoxyCodeLine{00363\ \ \ \mbox{\hyperlink{compiler_8h_a88276d6141c7aec6bf2376d2f5eb650a}{SRSRAN\_FORCE\_INLINE}}\ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6b8af8c1aa9562158deeb79275d6c170}{empty}}()\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ size()\ ==\ 0;\ \}}
\DoxyCodeLine{00364\ }
\DoxyCodeLine{00365\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Resize\ of\ the\ bounded\_bitset.\ If\ <tt>\ new\_size\ >\ max\_size()\ </tt>,\ an\ assertion\ is\ triggered.\ The\ newly}}
\DoxyCodeLine{00366\ \ \ \textcolor{comment}{///\ created\ are\ set\ to\ zero.}}
\DoxyCodeLine{00367\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_affcaf4b2d9be2c09261eb04de6fa67b3}{resize}}(size\_t\ new\_size)}
\DoxyCodeLine{00368\ \ \ \{}
\DoxyCodeLine{00369\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(new\_size\ <=\ max\_size(),\ \textcolor{stringliteral}{"{}ERROR:\ new\ size='\{\}'\ exceeds\ bitset\ capacity='\{\}'"{}},\ new\_size,\ max\_size());}
\DoxyCodeLine{00370\ \ \ \ \ \textcolor{keywordflow}{if}\ (new\_size\ ==\ cur\_size)\ \{}
\DoxyCodeLine{00371\ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{00372\ \ \ \ \ \}}
\DoxyCodeLine{00373\ \ \ \ \ \textcolor{keyword}{const}\ size\_t\ prev\_nof\_words\ =\ nof\_words\_();}
\DoxyCodeLine{00374\ \ \ \ \ cur\_size\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ new\_size;}
\DoxyCodeLine{00375\ \ \ \ \ sanitize\_();}
\DoxyCodeLine{00376\ \ \ \ \ \textcolor{keyword}{const}\ size\_t\ new\_nof\_words\ =\ nof\_words\_();}
\DoxyCodeLine{00377\ \ \ \ \ \textcolor{keyword}{const}\ size\_t\ start\ =\ std::min(prev\_nof\_words,\ new\_nof\_words),\ end\ =\ std::max(prev\_nof\_words,\ new\_nof\_words);}
\DoxyCodeLine{00378\ \ \ \ \ \textcolor{comment}{//\ The\ words\ created/deleted\ are\ set\ to\ zero.}}
\DoxyCodeLine{00379\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ start;\ i\ !=\ end;\ ++i)\ \{}
\DoxyCodeLine{00380\ \ \ \ \ \ \ buffer[i]\ =\ \textcolor{keyword}{static\_cast}<word\_t>(0);}
\DoxyCodeLine{00381\ \ \ \ \ \}}
\DoxyCodeLine{00382\ \ \ \}}
\DoxyCodeLine{00383\ }
\DoxyCodeLine{00384\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Set\ bit\ with\ provided\ index\ to\ either\ true\ or\ false.\ Assertion\ is\ triggered\ if\ pos\ >=\ max\_size().}}
\DoxyCodeLine{00385\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ pos\ Position\ in\ bitset.}}
\DoxyCodeLine{00386\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ val\ Value\ to\ set\ the\ bit.}}
\DoxyCodeLine{00387\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a52f08763e41a945fea0124ad5fc8457c}{set}}(size\_t\ pos,\ \textcolor{keywordtype}{bool}\ val)}
\DoxyCodeLine{00388\ \ \ \{}
\DoxyCodeLine{00389\ \ \ \ \ assert\_within\_bounds\_(pos,\ \textcolor{keyword}{true});}
\DoxyCodeLine{00390\ \ \ \ \ \textcolor{keywordflow}{if}\ (val)\ \{}
\DoxyCodeLine{00391\ \ \ \ \ \ \ set\_(pos);}
\DoxyCodeLine{00392\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00393\ \ \ \ \ \ \ reset\_(pos);}
\DoxyCodeLine{00394\ \ \ \ \ \}}
\DoxyCodeLine{00395\ \ \ \}}
\DoxyCodeLine{00396\ }
\DoxyCodeLine{00397\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Set\ bit\ with\ provided\ index\ to\ true.\ Assertion\ is\ triggered\ if\ pos\ >=\ N.}}
\DoxyCodeLine{00398\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ pos\ Position\ in\ bitset.}}
\DoxyCodeLine{00399\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a5e69884f4f6c363a769e0315ef9aa6f6}{set}}(size\_t\ pos)}
\DoxyCodeLine{00400\ \ \ \{}
\DoxyCodeLine{00401\ \ \ \ \ assert\_within\_bounds\_(pos,\ \textcolor{keyword}{true});}
\DoxyCodeLine{00402\ \ \ \ \ set\_(pos);}
\DoxyCodeLine{00403\ \ \ \}}
\DoxyCodeLine{00404\ }
\DoxyCodeLine{00405\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Set\ bit\ with\ provided\ index\ to\ false.\ Assertion\ is\ triggered\ if\ pos\ >=\ N.}}
\DoxyCodeLine{00406\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ pos\ Position\ in\ bitset.}}
\DoxyCodeLine{00407\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a179a14a79e4686cf1d1259031d0976cb}{reset}}(size\_t\ pos)}
\DoxyCodeLine{00408\ \ \ \{}
\DoxyCodeLine{00409\ \ \ \ \ assert\_within\_bounds\_(pos,\ \textcolor{keyword}{true});}
\DoxyCodeLine{00410\ \ \ \ \ reset\_(pos);}
\DoxyCodeLine{00411\ \ \ \}}
\DoxyCodeLine{00412\ }
\DoxyCodeLine{00413\ \ \ \textcolor{comment}{///\ Reset\ all\ bits\ in\ the\ bounded\_bitset\ to\ false.\ The\ size\ of\ the\ bitset\ is\ maintained.}}
\DoxyCodeLine{00414\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ac0afa38abe8e0e8d502f3ca68e27c793}{reset}}()\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00415\ \ \ \{}
\DoxyCodeLine{00416\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ 0;\ i\ <\ nof\_words\_();\ ++i)\ \{}
\DoxyCodeLine{00417\ \ \ \ \ \ \ buffer[i]\ =\ \textcolor{keyword}{static\_cast}<word\_t>(0);}
\DoxyCodeLine{00418\ \ \ \ \ \}}
\DoxyCodeLine{00419\ \ \ \}}
\DoxyCodeLine{00420\ }
\DoxyCodeLine{00421\ \ \ \textcolor{comment}{///\ Set\ all\ bits\ in\ the\ bounded\_bitset\ to\ true/false.\ The\ size\ of\ the\ bitset\ is\ maintained.}}
\DoxyCodeLine{00422\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a3807138159ac9d71f10a2514eecbdaab}{fill}}(\textcolor{keywordtype}{bool}\ val\ =\ \textcolor{keyword}{true})\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00423\ \ \ \{}
\DoxyCodeLine{00424\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ val)\ \{}
\DoxyCodeLine{00425\ \ \ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ac0afa38abe8e0e8d502f3ca68e27c793}{reset}}\mbox{\hyperlink{classsrsran_1_1bounded__bitset_ac0afa38abe8e0e8d502f3ca68e27c793}{(}}\mbox{\hyperlink{classsrsran_1_1bounded__bitset_ac0afa38abe8e0e8d502f3ca68e27c793}{)}};}
\DoxyCodeLine{00426\ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{00427\ \ \ \ \ \}}
\DoxyCodeLine{00428\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ 0;\ i\ <\ nof\_words\_();\ ++i)\ \{}
\DoxyCodeLine{00429\ \ \ \ \ \ \ buffer[i]\ =\ \textcolor{keyword}{static\_cast}<word\_t>(-\/1);}
\DoxyCodeLine{00430\ \ \ \ \ \}}
\DoxyCodeLine{00431\ \ \ \ \ sanitize\_();}
\DoxyCodeLine{00432\ \ \ \}}
\DoxyCodeLine{00433\ }
\DoxyCodeLine{00434\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Appends\ a\ bit\ with\ value\ \(\backslash\)c\ val\ to\ the\ set.}}
\DoxyCodeLine{00435\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00436\ \ \ \textcolor{comment}{///\ Assertion\ is\ triggered\ if\ the\ resultant\ size\ exceeds\ the\ maximum\ size\ of\ the\ bitset.}}
\DoxyCodeLine{00437\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_af7b9a9bb2ac12590917abb91d48bae99}{push\_back}}(\textcolor{keywordtype}{bool}\ val)}
\DoxyCodeLine{00438\ \ \ \{}
\DoxyCodeLine{00439\ \ \ \ \ \textcolor{keywordtype}{unsigned}\ bitpos\ =\ size();}
\DoxyCodeLine{00440\ \ \ \ \ resize(size()\ +\ 1);}
\DoxyCodeLine{00441\ \ \ \ \ set(bitpos,\ val);}
\DoxyCodeLine{00442\ \ \ \}}
\DoxyCodeLine{00443\ }
\DoxyCodeLine{00444\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Appends\ \(\backslash\)c\ nof\_bits\ bits\ to\ the\ set.}}
\DoxyCodeLine{00445\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00446\ \ \ \textcolor{comment}{///\ The\ least\ \(\backslash\)c\ nof\_bits\ significant\ bits\ of\ \(\backslash\)c\ val\ are\ appended\ to\ the\ set,\ starting\ from\ the\ most\ significant\ bit}}
\DoxyCodeLine{00447\ \ \ \textcolor{comment}{///\ and\ finishing\ with\ the\ least\ significant\ bit.}}
\DoxyCodeLine{00448\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00449\ \ \ \textcolor{comment}{///\ Assertion\ is\ triggered\ if\ the\ resultant\ size\ exceeds\ the\ maximum\ size\ of\ the\ bitset.}}
\DoxyCodeLine{00450\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer>}
\DoxyCodeLine{00451\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a61425a0cf0a1594fa11f3b289c40295d}{push\_back}}(Integer\ val,\ \textcolor{keywordtype}{unsigned}\ nof\_bits)}
\DoxyCodeLine{00452\ \ \ \{}
\DoxyCodeLine{00453\ \ \ \ \ \textcolor{keyword}{static\_assert}(std::is\_unsigned<Integer>::value,\ \textcolor{stringliteral}{"{}push\_back\ only\ works\ for\ unsigned\ integers"{}});}
\DoxyCodeLine{00454\ \ \ \ \ \textcolor{keywordtype}{unsigned}\ bitpos\ =\ size();}
\DoxyCodeLine{00455\ \ \ \ \ resize(size()\ +\ nof\_bits);}
\DoxyCodeLine{00456\ \ \ \ \ \textcolor{keywordflow}{if}\ (LowestInfoBitIsMSB)\ \{}
\DoxyCodeLine{00457\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ bit\_index\ =\ 0;\ bit\_index\ !=\ bitpos;\ ++bit\_index)\ \{}
\DoxyCodeLine{00458\ \ \ \ \ \ \ \ \ set(bit\_index,\ test(bit\_index\ +\ nof\_bits));}
\DoxyCodeLine{00459\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00460\ \ \ \ \ \}}
\DoxyCodeLine{00461\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ bit\_index\ =\ 0;\ bit\_index\ !=\ nof\_bits;\ ++bit\_index)\ \{}
\DoxyCodeLine{00462\ \ \ \ \ \ \ set(bitpos\ +\ bit\_index,\ (val\ >>\ (nof\_bits\ -\/\ 1\ -\/\ bit\_index))\ \&\ 1U);}
\DoxyCodeLine{00463\ \ \ \ \ \}}
\DoxyCodeLine{00464\ \ \ \}}
\DoxyCodeLine{00465\ }
\DoxyCodeLine{00466\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Extracts\ \(\backslash\)c\ nof\_bits\ starting\ from\ \(\backslash\)c\ startpos.}}
\DoxyCodeLine{00467\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00468\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ An\ unsigned\ integer\ containing\ \(\backslash\)c\ nof\_bits\ of\ the\ set\ where\ starting\ with\ the\ most\ significant\ bit\ and}}
\DoxyCodeLine{00469\ \ \ \textcolor{comment}{///\ finishing\ with\ the\ most\ significant\ bit.}}
\DoxyCodeLine{00470\ \ \ \textcolor{comment}{///\ \(\backslash\)remark\ An\ assertion\ is\ triggered\ if\ the\ bit\ range\ exceed\ the\ set\ size.}}
\DoxyCodeLine{00471\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Integer\ =\ \textcolor{keywordtype}{unsigned}>}
\DoxyCodeLine{00472\ \ \ Integer\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a4b0f3b798e2209a43e7afd2d942e2ab4}{extract}}(\textcolor{keywordtype}{unsigned}\ startpos,\ \textcolor{keywordtype}{unsigned}\ nof\_bits)\ \textcolor{keyword}{const}}
\DoxyCodeLine{00473\ \ \ \{}
\DoxyCodeLine{00474\ \ \ \ \ \textcolor{keyword}{static\_assert}(std::is\_unsigned<Integer>::value,\ \textcolor{stringliteral}{"{}Extract\ only\ works\ for\ unsigned\ integers"{}});}
\DoxyCodeLine{00475\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(nof\_bits\ <=\ \textcolor{keyword}{sizeof}(Integer)\ *\ 8,}
\DoxyCodeLine{00476\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}The\ number\ of\ bits\ (i.e.,\ \{\})\ exceeds\ the\ destination\ bit-\/width\ (i.e.,\ \{\})."{}},}
\DoxyCodeLine{00477\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ nof\_bits,}
\DoxyCodeLine{00478\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{sizeof}(Integer)\ *\ 8);}
\DoxyCodeLine{00479\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(startpos\ +\ nof\_bits\ <=\ size(),}
\DoxyCodeLine{00480\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}The\ start\ position\ (i.e.,\ \{\})\ plus\ the\ number\ of\ bits\ (i.e.,\ \{\})\ exceed\ the\ current\ size\ (i.e.,\ \{\})"{}},}
\DoxyCodeLine{00481\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ startpos,}
\DoxyCodeLine{00482\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ nof\_bits,}
\DoxyCodeLine{00483\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size());}
\DoxyCodeLine{00484\ }
\DoxyCodeLine{00485\ \ \ \ \ Integer\ val\ =\ 0;}
\DoxyCodeLine{00486\ }
\DoxyCodeLine{00487\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ bit\_index\ =\ 0;\ bit\_index\ !=\ nof\_bits;\ ++bit\_index)\ \{}
\DoxyCodeLine{00488\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (test(startpos\ +\ bit\_index))\ \{}
\DoxyCodeLine{00489\ \ \ \ \ \ \ \ \ val\ |=\ 1U\ <<\ (nof\_bits\ -\/\ 1\ -\/\ bit\_index);}
\DoxyCodeLine{00490\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00491\ \ \ \ \ \}}
\DoxyCodeLine{00492\ }
\DoxyCodeLine{00493\ \ \ \ \ \textcolor{keywordflow}{return}\ val;}
\DoxyCodeLine{00494\ \ \ \}}
\DoxyCodeLine{00495\ }
\DoxyCodeLine{00496\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Kronecker\ product\ of\ the\ bitset\ with\ another\ bitset.}}
\DoxyCodeLine{00497\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00498\ \ \ \textcolor{comment}{///\ Expands\ the\ bitset\ by\ a\ factor\ of\ \(\backslash\)c\ other.size()\ replacing\ every\ \(\backslash\)c\ true\ bit\ with\ the\ contents\ of\ \(\backslash\)c\ other\ and}}
\DoxyCodeLine{00499\ \ \ \textcolor{comment}{///\ every\ \(\backslash\)c\ false\ bit\ with\ \(\backslash\)c\ other.size()\ \(\backslash\)c\ false\ bits.}}
\DoxyCodeLine{00500\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00501\ \ \ \textcolor{comment}{///\ \(\backslash\)tparam\ Factor\ \ \ \ Maximum\ expansion\ factor.}}
\DoxyCodeLine{00502\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ other\ \ Bitset\ used\ for\ expansion.}}
\DoxyCodeLine{00503\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ The\ result\ of\ the\ bitset\ product.}}
\DoxyCodeLine{00504\ \ \ \textcolor{comment}{///\ \(\backslash\)remark\ The\ current\ implementation\ supports\ only\ a\ bitset\ containing\ one\ word.\ An\ assertion\ is\ triggered\ if\ \(\backslash\)c}}
\DoxyCodeLine{00505\ \ \ \textcolor{comment}{///\ other\ contains\ more\ than\ one\ word.}}
\DoxyCodeLine{00506\ \ \ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{unsigned}\ Factor>}
\DoxyCodeLine{00507\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ab10e03a7b7f1004316a8b01af57d75ef}{bounded\_bitset}}<\mbox{\hyperlink{classsrsran_1_1bounded__bitset_ab10e03a7b7f1004316a8b01af57d75ef}{Factor}}\ *\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ab10e03a7b7f1004316a8b01af57d75ef}{N}}>\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ab10e03a7b7f1004316a8b01af57d75ef}{kronecker\_product}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ab10e03a7b7f1004316a8b01af57d75ef}{bounded\_bitset}}<\mbox{\hyperlink{classsrsran_1_1bounded__bitset_ab10e03a7b7f1004316a8b01af57d75ef}{Factor}}>\&\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ab10e03a7b7f1004316a8b01af57d75ef}{other}})\ \textcolor{keyword}{const}}
\DoxyCodeLine{00508\ \ \ \{}
\DoxyCodeLine{00509\ \ \ \ \ \textcolor{keyword}{static\_assert}(Factor\ <=\ bits\_per\_word,}
\DoxyCodeLine{00510\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}The\ current\ algorithm\ does\ not\ support\ a\ filter\ containing\ more\ than\ one\ word."{}});}
\DoxyCodeLine{00511\ }
\DoxyCodeLine{00512\ \ \ \ \ \textcolor{comment}{//\ Prepare\ an\ empty\ result.}}
\DoxyCodeLine{00513\ \ \ \ \ bounded\_bitset<Factor\ *\ N>\ result(size()\ *\ other.size());}
\DoxyCodeLine{00514\ }
\DoxyCodeLine{00515\ \ \ \ \ \textcolor{comment}{//\ Places\ the\ contents\ of\ other\ centered\ at\ the\ positions\ indicated\ by\ the\ true\ bits.}}
\DoxyCodeLine{00516\ \ \ \ \ std::function<\textcolor{keywordtype}{void}(\textcolor{keywordtype}{unsigned})>\ kronecker\_expansion\ =\ [\&other,\ \&result](\textcolor{keywordtype}{unsigned}\ bit\_index)\ \{}
\DoxyCodeLine{00517\ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ bitpos\ =\ bit\_index\ *\ Factor;}
\DoxyCodeLine{00518\ \ \ \ \ \ \ word\_t\ \ \ word\ \ \ =\ other.buffer[0];}
\DoxyCodeLine{00519\ }
\DoxyCodeLine{00520\ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ bit\_offset\ =\ bitpos\ \%\ bits\_per\_word;}
\DoxyCodeLine{00521\ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ word\_index\ =\ bitpos\ /\ bits\_per\_word;}
\DoxyCodeLine{00522\ }
\DoxyCodeLine{00523\ \ \ \ \ \ \ result.buffer[word\_index]\ |=\ (word\ <<\ bit\_offset);}
\DoxyCodeLine{00524\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (bit\_offset\ \&\&\ (bit\_offset\ +\ other.size()\ >\ bits\_per\_word))\ \{}
\DoxyCodeLine{00525\ \ \ \ \ \ \ \ \ result.buffer[word\_index\ +\ 1]\ |=\ (word\ >>\ (bits\_per\_word\ -\/\ bit\_offset));}
\DoxyCodeLine{00526\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00527\ \ \ \ \ \};}
\DoxyCodeLine{00528\ }
\DoxyCodeLine{00529\ \ \ \ \ \textcolor{keywordflow}{if}\ (\mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6063ce8435cbbc14fb1344e49ac3becf}{is\_contiguous}}\mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6063ce8435cbbc14fb1344e49ac3becf}{(}}\textcolor{keyword}{true}\mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6063ce8435cbbc14fb1344e49ac3becf}{)}})\ \{}
\DoxyCodeLine{00530\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ i\_begin\ =\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_aa2de3a0528dbe3ab78a6c764bef1eb0f}{find\_lowest}}\mbox{\hyperlink{classsrsran_1_1bounded__bitset_aa2de3a0528dbe3ab78a6c764bef1eb0f}{(}}\textcolor{keyword}{true}\mbox{\hyperlink{classsrsran_1_1bounded__bitset_aa2de3a0528dbe3ab78a6c764bef1eb0f}{)}};}
\DoxyCodeLine{00531\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ i\_end\ \ \ =\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a4113d614afd53f3e204dce4ec89963b9}{find\_highest}}\mbox{\hyperlink{classsrsran_1_1bounded__bitset_a4113d614afd53f3e204dce4ec89963b9}{(}}\textcolor{keyword}{true}\mbox{\hyperlink{classsrsran_1_1bounded__bitset_a4113d614afd53f3e204dce4ec89963b9}{)}}\ +\ 1;}
\DoxyCodeLine{00532\ }
\DoxyCodeLine{00533\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((i\_begin\ <\ 0)\ ||\ (i\_end\ <=\ 0))\ \{}
\DoxyCodeLine{00534\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Empty\ bitset.}}
\DoxyCodeLine{00535\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00536\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00537\ }
\DoxyCodeLine{00538\ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ bitset\ in\ contiguous\ and\ the\ other\ bitset\ is\ all\ set,\ then\ use\ fill.}}
\DoxyCodeLine{00539\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (other.all())\ \{}
\DoxyCodeLine{00540\ \ \ \ \ \ \ \ \ result.fill(i\_begin\ *\ other.size(),\ i\_end\ *\ other.size());}
\DoxyCodeLine{00541\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00542\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Otherwise,\ place\ the\ contents\ of\ other\ into\ contiguous\ bit\ positions.}}
\DoxyCodeLine{00543\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\_bit\ =\ i\_begin;\ i\_bit\ !=\ i\_end;\ ++i\_bit)\ \{}
\DoxyCodeLine{00544\ \ \ \ \ \ \ \ \ \ \ kronecker\_expansion(i\_bit);}
\DoxyCodeLine{00545\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00546\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00547\ }
\DoxyCodeLine{00548\ \ \ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(count()\ *\ other.count()\ ==\ result.count(),}
\DoxyCodeLine{00549\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}The\ resultant\ number\ of\ ones\ is\ not\ consistent\ with\ inputs.\ It\ expected\ \{\}\ but\ got\ \{\}."{}},}
\DoxyCodeLine{00550\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ count()\ *\ other.count(),}
\DoxyCodeLine{00551\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ result.count());}
\DoxyCodeLine{00552\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00553\ \ \ \ \ \}}
\DoxyCodeLine{00554\ }
\DoxyCodeLine{00555\ \ \ \ \ \textcolor{comment}{//\ Place\ the\ contents\ of\ other\ into\ arbitrary\ bit\ positions.}}
\DoxyCodeLine{00556\ \ \ \ \ for\_each(0,\ size(),\ kronecker\_expansion);}
\DoxyCodeLine{00557\ }
\DoxyCodeLine{00558\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(count()\ *\ other.count()\ ==\ result.count(),}
\DoxyCodeLine{00559\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}The\ resultant\ number\ of\ ones\ is\ not\ consistent\ with\ inputs.\ It\ expected\ \{\}\ but\ got\ \{\}."{}},}
\DoxyCodeLine{00560\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ count()\ *\ other.count(),}
\DoxyCodeLine{00561\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ result.count());}
\DoxyCodeLine{00562\ }
\DoxyCodeLine{00563\ \ \ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00564\ \ \ \}}
\DoxyCodeLine{00565\ }
\DoxyCodeLine{00566\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Check\ if\ bit\ with\ provided\ index\ is\ set\ to\ true.}}
\DoxyCodeLine{00567\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ pos\ Position\ in\ bitset.}}
\DoxyCodeLine{00568\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ true\ if\ bit\ at\ position\ pos\ is\ set.}}
\DoxyCodeLine{00569\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a53b1498a7820972edb5b9c8db2fc94db}{test}}(size\_t\ pos)\ \textcolor{keyword}{const}}
\DoxyCodeLine{00570\ \ \ \{}
\DoxyCodeLine{00571\ \ \ \ \ assert\_within\_bounds\_(pos,\ \textcolor{keyword}{true});}
\DoxyCodeLine{00572\ \ \ \ \ \textcolor{keywordflow}{return}\ test\_(pos);}
\DoxyCodeLine{00573\ \ \ \}}
\DoxyCodeLine{00574\ }
\DoxyCodeLine{00575\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Toggle\ values\ of\ bits\ in\ bitset.}}
\DoxyCodeLine{00576\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ this\ object.}}
\DoxyCodeLine{00577\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a44a2eaa6409460184a1ebd31279d461e}{flip}}()\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00578\ \ \ \{}
\DoxyCodeLine{00579\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ 0;\ i\ <\ nof\_words\_();\ ++i)\ \{}
\DoxyCodeLine{00580\ \ \ \ \ \ \ buffer[i]\ =\ \string~buffer[i];}
\DoxyCodeLine{00581\ \ \ \ \ \}}
\DoxyCodeLine{00582\ \ \ \ \ sanitize\_();}
\DoxyCodeLine{00583\ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{00584\ \ \ \}}
\DoxyCodeLine{00585\ }
\DoxyCodeLine{00586\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Fills\ range\ of\ bits\ to\ either\ true\ or\ false.}}
\DoxyCodeLine{00587\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ startpos\ Starting\ bit\ index\ that\ will\ be\ set.}}
\DoxyCodeLine{00588\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ endpos\ End\ bit\ index\ (excluding)\ where\ the\ bits\ stop\ being\ set.}}
\DoxyCodeLine{00589\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ Set\ bit\ range\ values\ to\ either\ true\ or\ false.}}
\DoxyCodeLine{00590\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ a\ reference\ to\ this\ object.}}
\DoxyCodeLine{00591\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a96eaccdb330b0195f5ba2c1553a41e3e}{fill}}(size\_t\ startpos,\ size\_t\ endpos,\ \textcolor{keywordtype}{bool}\ value\ =\ \textcolor{keyword}{true})}
\DoxyCodeLine{00592\ \ \ \{}
\DoxyCodeLine{00593\ \ \ \ \ find\_first\_word\_(startpos,\ endpos,\ [\textcolor{keyword}{this},\ value](size\_t\ word\_idx,\ \textcolor{keyword}{const}\ word\_t\&\ mask)\ \{}
\DoxyCodeLine{00594\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (value)\ \{}
\DoxyCodeLine{00595\ \ \ \ \ \ \ \ \ buffer[word\_idx]\ |=\ mask;}
\DoxyCodeLine{00596\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00597\ \ \ \ \ \ \ \ \ buffer[word\_idx]\ \&=\ \string~mask;}
\DoxyCodeLine{00598\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00599\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00600\ \ \ \ \ \});}
\DoxyCodeLine{00601\ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{00602\ \ \ \}}
\DoxyCodeLine{00603\ }
\DoxyCodeLine{00604\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Returns\ bounded\_bitset<>\ that\ represents\ a\ slice\ or\ subview\ of\ the\ original\ bounded\_bitset.\ Unless}}
\DoxyCodeLine{00605\ \ \ \textcolor{comment}{///\ it\ is\ specified,\ the\ returned\ slice\ has\ the\ same\ template\ parameters\ "{}N"{}\ and\ "{}LowestInfoBitIsMSB"{}\ of\ "{}this"{}.}}
\DoxyCodeLine{00606\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00607\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ startpos\ The\ bit\ index\ where\ the\ subview\ starts.}}
\DoxyCodeLine{00608\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ endpos\ The\ bit\ index\ where\ the\ subview\ stops.}}
\DoxyCodeLine{00609\ \ \ \textcolor{keyword}{template}\ <size\_t\ N2\ =\ N>}
\DoxyCodeLine{00610\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N2,\ LowestInfoBitIsMSB>\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_afe1a0207f2e64504dfe8df1d6d7c163b}{slice}}(size\_t\ startpos,\ size\_t\ endpos)\ \textcolor{keyword}{const}}
\DoxyCodeLine{00611\ \ \ \{}
\DoxyCodeLine{00612\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N2,\ LowestInfoBitIsMSB>\ sliced(endpos\ -\/\ startpos);}
\DoxyCodeLine{00613\ \ \ \ \ \textcolor{keywordflow}{if}\ (LowestInfoBitIsMSB)\ \{}
\DoxyCodeLine{00614\ \ \ \ \ \ \ std::swap(startpos,\ endpos);}
\DoxyCodeLine{00615\ \ \ \ \ \ \ startpos\ =\ get\_bitidx\_(startpos)\ +\ 1;}
\DoxyCodeLine{00616\ \ \ \ \ \ \ endpos\ \ \ =\ get\_bitidx\_(endpos)\ +\ 1;}
\DoxyCodeLine{00617\ \ \ \ \ \}}
\DoxyCodeLine{00618\ \ \ \ \ \textcolor{keywordtype}{unsigned}\ start\_word\ =\ startpos\ /\ bits\_per\_word;}
\DoxyCodeLine{00619\ \ \ \ \ \textcolor{keywordtype}{unsigned}\ start\_mod\ \ =\ startpos\ \%\ bits\_per\_word;}
\DoxyCodeLine{00620\ }
\DoxyCodeLine{00621\ \ \ \ \ \textcolor{keywordflow}{if}\ (start\_mod\ !=\ 0)\ \{}
\DoxyCodeLine{00622\ \ \ \ \ \ \ word\_t\ left\_mask\ \ =\ mask\_lsb\_ones<word\_t>(bits\_per\_word\ -\/\ start\_mod);}
\DoxyCodeLine{00623\ \ \ \ \ \ \ word\_t\ right\_mask\ =\ mask\_lsb\_ones<word\_t>(start\_mod);}
\DoxyCodeLine{00624\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i\ =\ 0;\ i\ !=\ sliced.nof\_words\_();\ ++i)\ \{}
\DoxyCodeLine{00625\ \ \ \ \ \ \ \ \ sliced.buffer[i]\ =\ (buffer[i\ +\ start\_word]\ >>\ start\_mod)\ \&\ left\_mask;}
\DoxyCodeLine{00626\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ +\ start\_word\ +\ 1\ <\ nof\_words\_())\ \{}
\DoxyCodeLine{00627\ \ \ \ \ \ \ \ \ \ \ sliced.buffer[i]\ |=\ (buffer[i\ +\ start\_word\ +\ 1]\ \&\ right\_mask)\ <<\ (bits\_per\_word\ -\/\ start\_mod);}
\DoxyCodeLine{00628\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00629\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00630\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00631\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i\ =\ 0;\ i\ !=\ sliced.nof\_words\_();\ ++i)\ \{}
\DoxyCodeLine{00632\ \ \ \ \ \ \ \ \ sliced.buffer[i]\ =\ buffer[i\ +\ start\_word];}
\DoxyCodeLine{00633\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00634\ \ \ \ \ \}}
\DoxyCodeLine{00635\ \ \ \ \ sliced.sanitize\_();}
\DoxyCodeLine{00636\ \ \ \ \ \textcolor{keywordflow}{return}\ sliced;}
\DoxyCodeLine{00637\ \ \ \}}
\DoxyCodeLine{00638\ }
\DoxyCodeLine{00639\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Finds\ the\ lowest\ bit\ with\ value\ set\ to\ the\ value\ passed\ as\ argument.}}
\DoxyCodeLine{00640\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ The\ bit\ value\ to\ find,\ either\ true\ (1)\ or\ false\ (0).}}
\DoxyCodeLine{00641\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ the\ lowest\ found\ bit\ index\ or\ -\/1\ in\ case\ no\ bit\ was\ found\ with\ the\ provided\ value\ argument.}}
\DoxyCodeLine{00642\ \ \ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_aa2de3a0528dbe3ab78a6c764bef1eb0f}{find\_lowest}}(\textcolor{keywordtype}{bool}\ value\ =\ \textcolor{keyword}{true})\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ find\_lowest(0,\ size(),\ value);\ \}}
\DoxyCodeLine{00643\ }
\DoxyCodeLine{00644\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Finds,\ within\ a\ range\ of\ bit\ indexes,\ the\ lowest\ bit\ with\ value\ set\ to\ the\ value\ passed\ as\ argument.}}
\DoxyCodeLine{00645\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ startpos\ Starting\ bit\ index\ for\ the\ search.}}
\DoxyCodeLine{00646\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ endpos\ End\ bit\ index\ for\ the\ search.}}
\DoxyCodeLine{00647\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ The\ bit\ value\ to\ find,\ either\ true\ (1)\ or\ false\ (0).}}
\DoxyCodeLine{00648\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ the\ lowest\ found\ bit\ index\ or\ -\/1\ in\ case\ no\ bit\ was\ found\ with\ the\ provided\ value\ argument.}}
\DoxyCodeLine{00649\ \ \ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a30b59986a6d79fb62ea362c8efe3c75f}{find\_lowest}}(size\_t\ startpos,\ size\_t\ endpos,\ \textcolor{keywordtype}{bool}\ value\ =\ \textcolor{keyword}{true})\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00650\ \ \ \{}
\DoxyCodeLine{00651\ \ \ \ \ assert\_range\_bounds\_(startpos,\ endpos);}
\DoxyCodeLine{00652\ \ \ \ \ \textcolor{keywordflow}{if}\ (startpos\ ==\ endpos)\ \{}
\DoxyCodeLine{00653\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ -\/1;}
\DoxyCodeLine{00654\ \ \ \ \ \}}
\DoxyCodeLine{00655\ }
\DoxyCodeLine{00656\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ LowestInfoBitIsMSB)\ \{}
\DoxyCodeLine{00657\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ find\_first\_(startpos,\ endpos,\ value);}
\DoxyCodeLine{00658\ \ \ \ \ \}}
\DoxyCodeLine{00659\ \ \ \ \ \textcolor{keywordflow}{return}\ find\_first\_reversed\_(startpos,\ endpos,\ value);}
\DoxyCodeLine{00660\ \ \ \}}
\DoxyCodeLine{00661\ }
\DoxyCodeLine{00662\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Executes\ a\ function\ for\ all\ \(\backslash\)c\ true\ (or\ all\ \(\backslash\)c\ false)\ bits\ in\ the\ given\ bitset\ interval.}}
\DoxyCodeLine{00663\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00664\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ startpos\ Smallest\ bit\ index\ considered\ for\ the\ function\ execution\ (included).}}
\DoxyCodeLine{00665\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ endpos\ \ \ Largest\ bit\ index\ considered\ for\ the\ function\ execution\ (excluded).}}
\DoxyCodeLine{00666\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ function\ Function\ to\ execute\ -\/\ the\ signature\ should\ be\ compatible\ with\ <tt>void\ ()(unsigned)</tt>.}}
\DoxyCodeLine{00667\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ \ \ \ Bit\ value\ that\ triggers\ the\ function\ execution.}}
\DoxyCodeLine{00668\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{class}\ T>}
\DoxyCodeLine{00669\ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a976ce0172801963cd61e7baade0c225c}{for\_each}}(size\_t\ startpos,\ size\_t\ endpos,\ T\&\&\ function,\ \textcolor{keywordtype}{bool}\ value\ =\ \textcolor{keyword}{true})\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00670\ \ \ \{}
\DoxyCodeLine{00671\ \ \ \ \ \textcolor{keyword}{static\_assert}(std::is\_convertible<T,\ std::function<\textcolor{keywordtype}{void}(size\_t)>>::value,}
\DoxyCodeLine{00672\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}The\ function\ must\ have\ void(size\_t)\ signature."{}});}
\DoxyCodeLine{00673\ \ \ \ \ \textcolor{keyword}{static\_assert}(!LowestInfoBitIsMSB,\ \textcolor{stringliteral}{"{}The\ for\_each\ method\ is\ not\ yet\ available\ for\ reversed\ bitsets."{}});}
\DoxyCodeLine{00674\ }
\DoxyCodeLine{00675\ \ \ \ \ assert\_range\_bounds\_(startpos,\ endpos);}
\DoxyCodeLine{00676\ }
\DoxyCodeLine{00677\ \ \ \ \ \textcolor{keywordflow}{if}\ (startpos\ ==\ endpos)\ \{}
\DoxyCodeLine{00678\ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{00679\ \ \ \ \ \}}
\DoxyCodeLine{00680\ }
\DoxyCodeLine{00681\ \ \ \ \ \textcolor{keywordflow}{if}\ ((value\ \&\&\ all(startpos,\ endpos))\ ||\ (!value\ \&\&\ none(startpos,\ endpos)))\ \{}
\DoxyCodeLine{00682\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ bitpos\ =\ startpos;\ bitpos\ !=\ endpos;\ ++bitpos)\ \{}
\DoxyCodeLine{00683\ \ \ \ \ \ \ \ \ function(bitpos);}
\DoxyCodeLine{00684\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00685\ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{00686\ \ \ \ \ \}}
\DoxyCodeLine{00687\ }
\DoxyCodeLine{00688\ \ \ \ \ size\_t\ startword\ =\ startpos\ /\ bits\_per\_word;}
\DoxyCodeLine{00689\ \ \ \ \ size\_t\ lastword\ \ =\ (endpos\ +\ bits\_per\_word\ -\/\ 1)\ /\ bits\_per\_word;}
\DoxyCodeLine{00690\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ startword;\ i\ !=\ lastword;\ ++i)\ \{}
\DoxyCodeLine{00691\ \ \ \ \ \ \ word\_t\ w\ =\ buffer[i];}
\DoxyCodeLine{00692\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ value)\ \{}
\DoxyCodeLine{00693\ \ \ \ \ \ \ \ \ w\ =\ \string~w;}
\DoxyCodeLine{00694\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00695\ }
\DoxyCodeLine{00696\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (w\ ==\ 0)\ \{}
\DoxyCodeLine{00697\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{00698\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00699\ }
\DoxyCodeLine{00700\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ ==\ startword)\ \{}
\DoxyCodeLine{00701\ \ \ \ \ \ \ \ \ w\ \&=\ mask\_lsb\_zeros<word\_t>(startpos\ \%\ bits\_per\_word);}
\DoxyCodeLine{00702\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00703\ }
\DoxyCodeLine{00704\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((i\ ==\ lastword\ -\/\ 1)\ \&\&\ (endpos\ \%\ bits\_per\_word\ !=\ 0))\ \{}
\DoxyCodeLine{00705\ \ \ \ \ \ \ \ \ w\ \&=\ mask\_lsb\_ones<word\_t>(endpos\ \%\ bits\_per\_word);}
\DoxyCodeLine{00706\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00707\ }
\DoxyCodeLine{00708\ \ \ \ \ \ \ \textcolor{comment}{//\ Process\ presets\ of\ 4\ bits.}}
\DoxyCodeLine{00709\ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ bitpos\ =\ i\ *\ bits\_per\_word;}
\DoxyCodeLine{00710\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ w\ !=\ 0;\ w\ =\ w\ >>\ 4,\ bitpos\ +=\ 4)\ \{}
\DoxyCodeLine{00711\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (w\ \&\ 0xf)\ \{}
\DoxyCodeLine{00712\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B0000:}
\DoxyCodeLine{00713\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ All\ bits\ are\ false,\ skip.}}
\DoxyCodeLine{00714\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00715\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B0001:}
\DoxyCodeLine{00716\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 0);}
\DoxyCodeLine{00717\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00718\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B0010:}
\DoxyCodeLine{00719\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 1);}
\DoxyCodeLine{00720\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00721\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B0011:}
\DoxyCodeLine{00722\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 0);}
\DoxyCodeLine{00723\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 1);}
\DoxyCodeLine{00724\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00725\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B0100:}
\DoxyCodeLine{00726\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 2);}
\DoxyCodeLine{00727\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00728\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B0101:}
\DoxyCodeLine{00729\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 0);}
\DoxyCodeLine{00730\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 2);}
\DoxyCodeLine{00731\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00732\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B0110:}
\DoxyCodeLine{00733\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 1);}
\DoxyCodeLine{00734\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 2);}
\DoxyCodeLine{00735\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00736\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B0111:}
\DoxyCodeLine{00737\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 0);}
\DoxyCodeLine{00738\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 1);}
\DoxyCodeLine{00739\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 2);}
\DoxyCodeLine{00740\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00741\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B1000:}
\DoxyCodeLine{00742\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 3);}
\DoxyCodeLine{00743\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00744\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B1001:}
\DoxyCodeLine{00745\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 0);}
\DoxyCodeLine{00746\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 3);}
\DoxyCodeLine{00747\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00748\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B1010:}
\DoxyCodeLine{00749\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 1);}
\DoxyCodeLine{00750\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 3);}
\DoxyCodeLine{00751\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00752\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B1011:}
\DoxyCodeLine{00753\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 0);}
\DoxyCodeLine{00754\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 1);}
\DoxyCodeLine{00755\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 3);}
\DoxyCodeLine{00756\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00757\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B1100:}
\DoxyCodeLine{00758\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 2);}
\DoxyCodeLine{00759\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 3);}
\DoxyCodeLine{00760\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00761\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B1101:}
\DoxyCodeLine{00762\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 0);}
\DoxyCodeLine{00763\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 2);}
\DoxyCodeLine{00764\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 3);}
\DoxyCodeLine{00765\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00766\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B1110:}
\DoxyCodeLine{00767\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 1);}
\DoxyCodeLine{00768\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 2);}
\DoxyCodeLine{00769\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 3);}
\DoxyCodeLine{00770\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00771\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0B1111:}
\DoxyCodeLine{00772\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00773\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 0);}
\DoxyCodeLine{00774\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 1);}
\DoxyCodeLine{00775\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 2);}
\DoxyCodeLine{00776\ \ \ \ \ \ \ \ \ \ \ \ \ function(bitpos\ +\ 3);}
\DoxyCodeLine{00777\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00778\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00779\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00780\ \ \ \ \ \}}
\DoxyCodeLine{00781\ \ \ \}}
\DoxyCodeLine{00782\ }
\DoxyCodeLine{00783\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Checks\ if\ all\ bits\ in\ the\ bitset\ are\ set\ to\ 1.}}
\DoxyCodeLine{00784\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ true\ if\ all\ bits\ are\ 1.}}
\DoxyCodeLine{00785\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_add527d4585ee7b24ed669c9661a03056}{all}}()\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00786\ \ \ \{}
\DoxyCodeLine{00787\ \ \ \ \ \textcolor{keyword}{const}\ size\_t\ nw\ =\ nof\_words\_();}
\DoxyCodeLine{00788\ \ \ \ \ \textcolor{keywordflow}{if}\ (nw\ ==\ 0)\ \{}
\DoxyCodeLine{00789\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00790\ \ \ \ \ \}}
\DoxyCodeLine{00791\ \ \ \ \ word\_t\ allset\ =\ \string~\textcolor{keyword}{static\_cast}<word\_t>(0);}
\DoxyCodeLine{00792\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ 0;\ i\ <\ nw\ -\/\ 1;\ i++)\ \{}
\DoxyCodeLine{00793\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (buffer[i]\ !=\ allset)\ \{}
\DoxyCodeLine{00794\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00795\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00796\ \ \ \ \ \}}
\DoxyCodeLine{00797\ \ \ \ \ \textcolor{keywordflow}{return}\ buffer[nw\ -\/\ 1]\ ==\ (allset\ >>\ (nw\ *\ bits\_per\_word\ -\/\ size()));}
\DoxyCodeLine{00798\ \ \ \}}
\DoxyCodeLine{00799\ }
\DoxyCodeLine{00800\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Checks\ if\ all\ bits\ within\ a\ bit\ index\ range\ are\ set\ to\ 1.}}
\DoxyCodeLine{00801\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ true\ if\ all\ the\ bits\ within\ the\ range\ are\ 1.}}
\DoxyCodeLine{00802\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_aa21b2a10d494c72632a846a6e0513269}{all}}(size\_t\ start,\ size\_t\ stop)\ \textcolor{keyword}{const}}
\DoxyCodeLine{00803\ \ \ \{}
\DoxyCodeLine{00804\ \ \ \ \ \textcolor{keywordtype}{bool}\ not\_all\_found\ =\ find\_first\_word\_(start,\ stop,\ [\textcolor{keyword}{this}](size\_t\ word\_idx,\ \textcolor{keyword}{const}\ word\_t\&\ mask)\ \{}
\DoxyCodeLine{00805\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ (buffer[word\_idx]\ |\ \string~mask)\ !=\ \string~\textcolor{keyword}{static\_cast}<word\_t>(0);}
\DoxyCodeLine{00806\ \ \ \ \ \});}
\DoxyCodeLine{00807\ \ \ \ \ \textcolor{keywordflow}{return}\ !not\_all\_found;}
\DoxyCodeLine{00808\ \ \ \}}
\DoxyCodeLine{00809\ }
\DoxyCodeLine{00810\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Finds\ the\ highest\ bit\ with\ value\ set\ to\ the\ value\ passed\ as\ argument.}}
\DoxyCodeLine{00811\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ The\ bit\ value\ to\ find,\ either\ true\ (1)\ or\ false\ (0).}}
\DoxyCodeLine{00812\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ the\ lowest\ found\ bit\ index\ or\ -\/1\ in\ case\ no\ bit\ was\ found\ with\ the\ provided\ value\ argument.}}
\DoxyCodeLine{00813\ \ \ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a4113d614afd53f3e204dce4ec89963b9}{find\_highest}}(\textcolor{keywordtype}{bool}\ value\ =\ \textcolor{keyword}{true})\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ find\_highest(0,\ size(),\ value);\ \}}
\DoxyCodeLine{00814\ }
\DoxyCodeLine{00815\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Finds,\ within\ a\ range\ of\ bit\ indexes,\ the\ highest\ bit\ with\ value\ set\ to\ the\ value\ passed\ as\ argument.}}
\DoxyCodeLine{00816\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ startpos\ Starting\ bit\ index\ for\ the\ search.}}
\DoxyCodeLine{00817\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ endpos\ End\ bit\ index\ for\ the\ search.}}
\DoxyCodeLine{00818\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ The\ bit\ value\ to\ find,\ either\ true\ (1)\ or\ false\ (0).}}
\DoxyCodeLine{00819\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ the\ lowest\ found\ bit\ index\ or\ -\/1\ in\ case\ no\ bit\ was\ found\ with\ the\ provided\ value\ argument.}}
\DoxyCodeLine{00820\ \ \ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a650f906b62306eebcbc8b96b50ff8192}{find\_highest}}(size\_t\ startpos,\ size\_t\ endpos,\ \textcolor{keywordtype}{bool}\ value\ =\ \textcolor{keyword}{true})\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00821\ \ \ \{}
\DoxyCodeLine{00822\ \ \ \ \ assert\_range\_bounds\_(startpos,\ endpos);}
\DoxyCodeLine{00823\ }
\DoxyCodeLine{00824\ \ \ \ \ \textcolor{keywordflow}{if}\ (LowestInfoBitIsMSB)\ \{}
\DoxyCodeLine{00825\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ ret\ =\ find\_first\_(size()\ -\/\ endpos,\ size()\ -\/\ startpos,\ value);}
\DoxyCodeLine{00826\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ret\ ==\ -\/1)\ \{}
\DoxyCodeLine{00827\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{00828\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00829\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ size()\ -\/\ 1\ -\/\ ret;}
\DoxyCodeLine{00830\ \ \ \ \ \}}
\DoxyCodeLine{00831\ \ \ \ \ \textcolor{keywordflow}{return}\ find\_last\_(startpos,\ endpos,\ value);}
\DoxyCodeLine{00832\ \ \ \}}
\DoxyCodeLine{00833\ }
\DoxyCodeLine{00834\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Checks\ if\ at\ least\ one\ bit\ in\ the\ bitset\ is\ set\ to\ 1.}}
\DoxyCodeLine{00835\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ true\ if\ at\ least\ one\ bit\ is\ 1.}}
\DoxyCodeLine{00836\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ae4011c726db20e6038f6e7918f31c0bd}{any}}()\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00837\ \ \ \{}
\DoxyCodeLine{00838\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ 0;\ i\ <\ nof\_words\_();\ ++i)\ \{}
\DoxyCodeLine{00839\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (buffer[i]\ !=\ \textcolor{keyword}{static\_cast}<word\_t>(0))\ \{}
\DoxyCodeLine{00840\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00841\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00842\ \ \ \ \ \}}
\DoxyCodeLine{00843\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00844\ \ \ \}}
\DoxyCodeLine{00845\ }
\DoxyCodeLine{00846\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Checks\ if\ at\ least\ one\ bit\ in\ the\ bitset\ is\ set\ to\ 1\ within\ a\ bit\ index\ range.}}
\DoxyCodeLine{00847\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ true\ if\ at\ least\ one\ bit\ equal\ to\ 1\ was\ found\ within\ the\ range.}}
\DoxyCodeLine{00848\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6bdaffd985bdfbcfe3520c6a1aeb6602}{any}}(size\_t\ start,\ size\_t\ stop)\ \textcolor{keyword}{const}}
\DoxyCodeLine{00849\ \ \ \{}
\DoxyCodeLine{00850\ \ \ \ \ \textcolor{keywordtype}{bool}\ any\_found\ =\ find\_first\_word\_(start,\ stop,\ [\textcolor{keyword}{this}](size\_t\ word\_idx,\ \textcolor{keyword}{const}\ word\_t\&\ mask)\ \{}
\DoxyCodeLine{00851\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ (buffer[word\_idx]\ \&\ mask)\ !=\ \textcolor{keyword}{static\_cast}<word\_t>(0);}
\DoxyCodeLine{00852\ \ \ \ \ \});}
\DoxyCodeLine{00853\ \ \ \ \ \textcolor{keywordflow}{return}\ any\_found;}
\DoxyCodeLine{00854\ \ \ \}}
\DoxyCodeLine{00855\ }
\DoxyCodeLine{00856\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Checks\ if\ at\ no\ bit\ in\ the\ bitset\ is\ set\ to\ 1.}}
\DoxyCodeLine{00857\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ true\ if\ no\ bit\ equal\ to\ 1\ was\ found.}}
\DoxyCodeLine{00858\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a246b404a01b6aff51efb8304262c938b}{none}}()\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ !\mbox{\hyperlink{classsrsran_1_1bounded__bitset_ae4011c726db20e6038f6e7918f31c0bd}{any}}\mbox{\hyperlink{classsrsran_1_1bounded__bitset_ae4011c726db20e6038f6e7918f31c0bd}{(}}\mbox{\hyperlink{classsrsran_1_1bounded__bitset_ae4011c726db20e6038f6e7918f31c0bd}{)}};\ \}}
\DoxyCodeLine{00859\ }
\DoxyCodeLine{00860\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Checks\ whether\ no\ bit\ is\ set\ within\ the\ given\ index\ range.}}
\DoxyCodeLine{00861\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ True\ if\ no\ bit\ is\ equal\ to\ 1,\ false\ otherwise.}}
\DoxyCodeLine{00862\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a2d0c58282040cf63e203aba01c73ccc8}{none}}(size\_t\ start,\ size\_t\ stop)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ !any(start,\ stop);\ \}}
\DoxyCodeLine{00863\ }
\DoxyCodeLine{00864\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Determines\ whether\ all\ bits\ with\ value\ set\ to\ \(\backslash\)c\ value\ are\ contiguous.}}
\DoxyCodeLine{00865\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00866\ \ \ \textcolor{comment}{///\ Bits\ with\ the\ same\ value\ are\ contiguous\ if:}}
\DoxyCodeLine{00867\ \ \ \textcolor{comment}{///\ 1.\ one\ bit\ with\ \(\backslash\)c\ value\ is\ found,}}
\DoxyCodeLine{00868\ \ \ \textcolor{comment}{///\ 2.\ no\ bit\ with\ \(\backslash\)c\ value\ is\ found,\ and}}
\DoxyCodeLine{00869\ \ \ \textcolor{comment}{///\ 3.\ all\ bits\ with\ \(\backslash\)c\ value\ are\ consecutive.}}
\DoxyCodeLine{00870\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00871\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ startpos\ Starting\ bit\ index\ for\ the\ search.}}
\DoxyCodeLine{00872\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ endpos\ End\ bit\ index\ for\ the\ search.}}
\DoxyCodeLine{00873\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ The\ bit\ value\ to\ find,\ either\ true\ (1)\ or\ false\ (0).}}
\DoxyCodeLine{00874\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ the\ lowest\ found\ bit\ index\ or\ -\/1\ in\ case\ no\ bit\ was\ found\ with\ the\ provided\ value\ argument.}}
\DoxyCodeLine{00875\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6063ce8435cbbc14fb1344e49ac3becf}{is\_contiguous}}(\textcolor{keywordtype}{bool}\ value\ =\ \textcolor{keyword}{true})\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00876\ \ \ \{}
\DoxyCodeLine{00877\ \ \ \ \ \textcolor{comment}{//\ Find\ the\ lowest\ value.}}
\DoxyCodeLine{00878\ \ \ \ \ \textcolor{keywordtype}{int}\ startpos\ =\ find\_lowest(0,\ size(),\ value);}
\DoxyCodeLine{00879\ }
\DoxyCodeLine{00880\ \ \ \ \ \textcolor{comment}{//\ Condition\ 1.\ No\ value\ is\ found.}}
\DoxyCodeLine{00881\ \ \ \ \ \textcolor{keywordflow}{if}\ (startpos\ ==\ -\/1)\ \{}
\DoxyCodeLine{00882\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00883\ \ \ \ \ \}}
\DoxyCodeLine{00884\ }
\DoxyCodeLine{00885\ \ \ \ \ \textcolor{comment}{//\ Find\ the\ highest\ value.}}
\DoxyCodeLine{00886\ \ \ \ \ \textcolor{keywordtype}{int}\ endpos\ =\ find\_highest(startpos\ +\ 1,\ size(),\ value);}
\DoxyCodeLine{00887\ }
\DoxyCodeLine{00888\ \ \ \ \ \textcolor{comment}{//\ Condition\ 2.\ There\ is\ only\ one\ bit\ with\ the\ value\ (in\ startpos).}}
\DoxyCodeLine{00889\ \ \ \ \ \textcolor{keywordflow}{if}\ (endpos\ ==\ -\/1)\ \{}
\DoxyCodeLine{00890\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00891\ \ \ \ \ \}}
\DoxyCodeLine{00892\ }
\DoxyCodeLine{00893\ \ \ \ \ \textcolor{comment}{//\ Count\ the\ number\ of\ elements\ set\ to\ value.}}
\DoxyCodeLine{00894\ \ \ \ \ size\_t\ value\_count\ =\ count();}
\DoxyCodeLine{00895\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ value)\ \{}
\DoxyCodeLine{00896\ \ \ \ \ \ \ value\_count\ =\ size()\ -\/\ value\_count;}
\DoxyCodeLine{00897\ \ \ \ \ \}}
\DoxyCodeLine{00898\ }
\DoxyCodeLine{00899\ \ \ \ \ \textcolor{comment}{//\ Condition\ 3.\ The\ number\ of\ elements\ must\ match\ with\ the\ start\ to\ end\ number\ of\ elements.}}
\DoxyCodeLine{00900\ \ \ \ \ \textcolor{keywordflow}{return}\ (value\_count\ ==\ \textcolor{keyword}{static\_cast}<size\_t>((endpos\ +\ 1)\ -\/\ startpos));}
\DoxyCodeLine{00901\ \ \ \}}
\DoxyCodeLine{00902\ }
\DoxyCodeLine{00903\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Counts\ the\ number\ of\ bits\ set\ to\ 1.}}
\DoxyCodeLine{00904\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ the\ number\ of\ bits\ set\ to\ 1.}}
\DoxyCodeLine{00905\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a69381df20e59db2de0af0ed8085ac955}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a69381df20e59db2de0af0ed8085ac955}{count}}()\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00906\ \ \ \{}
\DoxyCodeLine{00907\ \ \ \ \ \textcolor{keywordtype}{int}\ result\ =\ 0;}
\DoxyCodeLine{00908\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ 0;\ i\ <\ nof\_words\_();\ i++)\ \{}
\DoxyCodeLine{00909\ \ \ \ \ \ \ result\ +=\ count\_ones(buffer[i]);}
\DoxyCodeLine{00910\ \ \ \ \ \}}
\DoxyCodeLine{00911\ \ \ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00912\ \ \ \}}
\DoxyCodeLine{00913\ }
\DoxyCodeLine{00914\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Compares\ two\ bitsets.}}
\DoxyCodeLine{00915\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ true\ if\ both\ bitsets\ are\ equal\ in\ size\ and\ values\ of\ bits.}}
\DoxyCodeLine{00916\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a9d1a9985a68fb77b911d3bc573e139e3}{operator}}==(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ other)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00917\ \ \ \{}
\DoxyCodeLine{00918\ \ \ \ \ \textcolor{keywordflow}{if}\ (size()\ !=\ other.size())\ \{}
\DoxyCodeLine{00919\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00920\ \ \ \ \ \}}
\DoxyCodeLine{00921\ \ \ \ \ \textcolor{keywordflow}{for}\ (uint32\_t\ i\ =\ 0;\ i\ <\ nof\_words\_();\ ++i)\ \{}
\DoxyCodeLine{00922\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (buffer[i]\ !=\ other.buffer[i])\ \{}
\DoxyCodeLine{00923\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00924\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00925\ \ \ \ \ \}}
\DoxyCodeLine{00926\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00927\ \ \ \}}
\DoxyCodeLine{00928\ }
\DoxyCodeLine{00929\ \ \ \textcolor{keywordtype}{bool}\ operator!=(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ other)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{not}(*\textcolor{keyword}{this}\ ==\ other);\ \}}
\DoxyCodeLine{00930\ }
\DoxyCodeLine{00931\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Applies\ bitwise\ OR\ operation\ lhs\ |=\ rhs.}}
\DoxyCodeLine{00932\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ other\ Bitset\ which\ corresponds\ to\ the\ rhs\ of\ the\ operation.}}
\DoxyCodeLine{00933\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ This\ object\ updated\ after\ the\ bitwise\ OR\ operation.}}
\DoxyCodeLine{00934\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ae83fa5372dbd565312a73fbd62a28f83}{operator}}|=(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ other)}
\DoxyCodeLine{00935\ \ \ \{}
\DoxyCodeLine{00936\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(other.size()\ ==\ size(),}
\DoxyCodeLine{00937\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}ERROR:\ operator|=\ called\ for\ bitsets\ of\ different\ sizes\ ('\{\}'!='\{\}')"{}},}
\DoxyCodeLine{00938\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size(),}
\DoxyCodeLine{00939\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ other.size());}
\DoxyCodeLine{00940\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ 0;\ i\ <\ nof\_words\_();\ ++i)\ \{}
\DoxyCodeLine{00941\ \ \ \ \ \ \ buffer[i]\ |=\ other.buffer[i];}
\DoxyCodeLine{00942\ \ \ \ \ \}}
\DoxyCodeLine{00943\ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{00944\ \ \ \}}
\DoxyCodeLine{00945\ }
\DoxyCodeLine{00946\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Applies\ bitwise\ AND\ operation\ lhs\ \&=\ rhs.}}
\DoxyCodeLine{00947\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ other\ Bitset\ which\ corresponds\ to\ the\ rhs\ of\ the\ operation.}}
\DoxyCodeLine{00948\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ This\ object\ updated\ after\ the\ bitwise\ AND\ operation.}}
\DoxyCodeLine{00949\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a35c7740a5e5b4be4b794c0c70a9a618e}{operator}}\&=(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ other)}
\DoxyCodeLine{00950\ \ \ \{}
\DoxyCodeLine{00951\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(other.size()\ ==\ size(),}
\DoxyCodeLine{00952\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}ERROR:\ operator\&=\ called\ for\ bitsets\ of\ different\ sizes\ ('\{\}'!='\{\}')"{}},}
\DoxyCodeLine{00953\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size(),}
\DoxyCodeLine{00954\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ other.size());}
\DoxyCodeLine{00955\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ 0;\ i\ <\ nof\_words\_();\ ++i)\ \{}
\DoxyCodeLine{00956\ \ \ \ \ \ \ buffer[i]\ \&=\ other.buffer[i];}
\DoxyCodeLine{00957\ \ \ \ \ \}}
\DoxyCodeLine{00958\ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{00959\ \ \ \}}
\DoxyCodeLine{00960\ }
\DoxyCodeLine{00961\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Flips\ values\ of\ bits\ in\ the\ bitset.}}
\DoxyCodeLine{00962\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ reference\ to\ this\ object,\ updated\ after\ the\ flip\ operation.}}
\DoxyCodeLine{00963\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a3f66b32982872573ecb34aec51009058}{operator}}\string~()\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00964\ \ \ \{}
\DoxyCodeLine{00965\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\ ret(*\textcolor{keyword}{this});}
\DoxyCodeLine{00966\ \ \ \ \ ret.flip();}
\DoxyCodeLine{00967\ \ \ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{00968\ \ \ \}}
\DoxyCodeLine{00969\ }
\DoxyCodeLine{00970\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Conversion\ of\ bounded\_bitset\ to\ unsigned\ integer\ of\ 64\ bits.\ If\ bitset\ size\ is\ larger\ than\ 64\ bits,\ an}}
\DoxyCodeLine{00971\ \ \ \textcolor{comment}{///\ assertion\ is\ triggered.}}
\DoxyCodeLine{00972\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Unsigned\ integer\ representation\ of\ the\ bounded\_bitset.}}
\DoxyCodeLine{00973\ \ \ uint64\_t\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a11683e235b8b198fa74191f1b57c38fc}{to\_uint64}}()\ \textcolor{keyword}{const}}
\DoxyCodeLine{00974\ \ \ \{}
\DoxyCodeLine{00975\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(nof\_words\_()\ ==\ 1,\ \textcolor{stringliteral}{"{}ERROR:\ cannot\ convert\ bitset\ of\ size='\{\}'\ to\ uint64\_t"{}},\ size());}
\DoxyCodeLine{00976\ \ \ \ \ \textcolor{keywordflow}{return}\ get\_word\_(0);}
\DoxyCodeLine{00977\ \ \ \}}
\DoxyCodeLine{00978\ }
\DoxyCodeLine{00979\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Conversion\ of\ unsigned\ integer\ of\ 64\ bits\ to\ bounded\_bitset.\ If\ passed\ bitmap\ doesn't\ fit\ in\ the\ bitset,}}
\DoxyCodeLine{00980\ \ \ \textcolor{comment}{///\ an\ assertion\ is\ triggered.}}
\DoxyCodeLine{00981\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ v\ Integer\ bitmap\ that\ is\ going\ to\ be\ stored\ in\ the\ bitset.}}
\DoxyCodeLine{00982\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a2be34591a1107d071ef809ba37cd14ec}{from\_uint64}}(uint64\_t\ v)}
\DoxyCodeLine{00983\ \ \ \{}
\DoxyCodeLine{00984\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(nof\_words\_()\ ==\ 1,\ \textcolor{stringliteral}{"{}ERROR:\ cannot\ convert\ bitset\ of\ size='\{\}'\ to\ uint64\_t"{}},\ size());}
\DoxyCodeLine{00985\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(v\ <\ (1U\ <<\ size()),\ \textcolor{stringliteral}{"{}ERROR:\ Provided\ mask='\{\}'\ does\ not\ fit\ in\ bitset\ of\ size='\{\}'"{}},\ v,\ size());}
\DoxyCodeLine{00986\ \ \ \ \ buffer[0]\ =\ v;}
\DoxyCodeLine{00987\ \ \ \}}
\DoxyCodeLine{00988\ }
\DoxyCodeLine{00989\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Converts\ the\ bitset\ to\ an\ array\ of\ packed\ bits.\ Each\ element\ of\ the\ resulting\ array\ will\ contain\ a\ bitmap.}}
\DoxyCodeLine{00990\ \ \ \textcolor{comment}{///\ The\ LowInfoBitIsMSB\ template\ parameter\ defines\ the\ order\ of\ bits\ in\ the\ resulting\ array.}}
\DoxyCodeLine{00991\ \ \ \textcolor{comment}{///\ \(\backslash\)tparam\ UnsignedInteger\ Value\ type\ of\ the\ array\ where\ packed\ bits\ will\ be\ stored.\ It\ must\ be\ an\ unsigned\ integer.}}
\DoxyCodeLine{00992\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ packed\_bits\ Array\ where\ packed\ bits\ will\ be\ stored.\ The\ array\ size\ must\ be\ equal\ or\ larger\ than\ the}}
\DoxyCodeLine{00993\ \ \ \textcolor{comment}{///\ bitset\ size\ (in\ bits)\ divided\ by\ \(\backslash\)c\ sizeof(UnsignedInteger)\ *\ 8U\ (the\ number\ of\ bits\ per\ integer).}}
\DoxyCodeLine{00994\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ Returns\ the\ number\ of\ positions\ of\ \(\backslash\)c\ packed\_bits\ that\ were\ written\ during\ the\ function\ call.}}
\DoxyCodeLine{00995\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ UnsignedInteger>}
\DoxyCodeLine{00996\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6af041f873b70a6c812c3a0247f9b618}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6af041f873b70a6c812c3a0247f9b618}{to\_packed\_bits}}(\mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6af041f873b70a6c812c3a0247f9b618}{span}}<\mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6af041f873b70a6c812c3a0247f9b618}{UnsignedInteger}}>\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a6af041f873b70a6c812c3a0247f9b618}{packed\_bits}})\ \textcolor{keyword}{const}}
\DoxyCodeLine{00997\ \ \ \{}
\DoxyCodeLine{00998\ \ \ \ \ \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(UnsignedInteger)\ <=\ \textcolor{keyword}{sizeof}(word\_t),\ \textcolor{stringliteral}{"{}ERROR:\ provided\ array\ type\ is\ too\ large"{}});}
\DoxyCodeLine{00999\ \ \ \ \ \textcolor{keyword}{static\_assert}(std::is\_unsigned<UnsignedInteger>::value,\ \textcolor{stringliteral}{"{}Only\ unsigned\ integers\ are\ supported"{}});}
\DoxyCodeLine{01000\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ size\_t\ steps\_per\_word\ \ \ \ \ \ =\ \textcolor{keyword}{sizeof}(word\_t)\ /\ \textcolor{keyword}{sizeof}(UnsignedInteger);}
\DoxyCodeLine{01001\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ size\_t\ bits\_per\_integer\ \ \ \ =\ \textcolor{keyword}{sizeof}(UnsignedInteger)\ *\ 8U;}
\DoxyCodeLine{01002\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ word\_t\ integer\_mask\ \ \ \ \ \ \ \ =\ mask\_lsb\_ones<word\_t>(bits\_per\_integer);}
\DoxyCodeLine{01003\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \ \ \ \ \ \ \ \ \ last\_word\_steps\ \ \ \ \ =\ divide\_ceil(size()\ \%\ bits\_per\_word,\ bits\_per\_integer);}
\DoxyCodeLine{01004\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \ \ \ \ \ \ \ \ \ nof\_words\ \ \ \ \ \ \ \ \ \ \ =\ nof\_words\_();}
\DoxyCodeLine{01005\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \ \ \ \ \ \ \ \ \ nof\_integers\_packed\ =\ (nof\_words\ -\/\ 1)\ *\ steps\_per\_word\ +\ last\_word\_steps;}
\DoxyCodeLine{01006\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(}
\DoxyCodeLine{01007\ \ \ \ \ \ \ \ \ packed\_bits.size()\ >=\ nof\_integers\_packed,\ \textcolor{stringliteral}{"{}ERROR:\ provided\ array\ size='\{\}'\ is\ too\ small"{}},\ packed\_bits.size());}
\DoxyCodeLine{01008\ }
\DoxyCodeLine{01009\ \ \ \ \ size\_t\ count\ =\ 0;}
\DoxyCodeLine{01010\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ LowestInfoBitIsMSB)\ \{}
\DoxyCodeLine{01011\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i\ =\ 0;\ i\ !=\ nof\_words;\ ++i)\ \{}
\DoxyCodeLine{01012\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ nof\_steps\ =\ i\ ==\ nof\_words\ -\/\ 1\ ?\ last\_word\_steps\ :\ steps\_per\_word;}
\DoxyCodeLine{01013\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ j\ =\ 0;\ j\ !=\ nof\_steps;\ ++j)\ \{}
\DoxyCodeLine{01014\ \ \ \ \ \ \ \ \ \ \ packed\_bits[count++]\ =\ (buffer[i]\ >>\ (j\ *\ steps\_per\_word))\ \&\ integer\_mask;}
\DoxyCodeLine{01015\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01016\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01017\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01018\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i\ =\ 0;\ i\ !=\ nof\_words;\ ++i)\ \{}
\DoxyCodeLine{01019\ \ \ \ \ \ \ \ \ word\_t\ \ \ w\ \ \ \ \ \ \ \ \ =\ buffer[nof\_words\ -\/\ i\ -\/\ 1];}
\DoxyCodeLine{01020\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ nof\_steps\ =\ steps\_per\_word;}
\DoxyCodeLine{01021\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ ==\ nof\_words\ -\/\ 1)\ \{}
\DoxyCodeLine{01022\ \ \ \ \ \ \ \ \ \ \ w\ <<=\ (bits\_per\_word\ -\/\ (size()\ \%\ bits\_per\_word));}
\DoxyCodeLine{01023\ \ \ \ \ \ \ \ \ \ \ nof\_steps\ =\ last\_word\_steps;}
\DoxyCodeLine{01024\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01025\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ j\ =\ 0;\ j\ !=\ nof\_steps;\ ++j)\ \{}
\DoxyCodeLine{01026\ \ \ \ \ \ \ \ \ \ \ packed\_bits[count++]\ =\ (w\ >>\ (bits\_per\_word\ -\/\ (j\ +\ 1)\ *\ bits\_per\_integer))\ \&\ integer\_mask;}
\DoxyCodeLine{01027\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01028\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01029\ \ \ \ \ \}}
\DoxyCodeLine{01030\ }
\DoxyCodeLine{01031\ \ \ \ \ \textcolor{keywordflow}{return}\ nof\_integers\_packed;}
\DoxyCodeLine{01032\ \ \ \}}
\DoxyCodeLine{01033\ }
\DoxyCodeLine{01034\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Converts\ the\ bitset\ to\ an\ array\ of\ unpacked\ bits,\ i.e.\ an\ array\ where\ each\ element\ represents\ a\ single}}
\DoxyCodeLine{01035\ \ \ \textcolor{comment}{///\ boolean.\ The\ order\ of\ bits\ in\ the\ resulting\ array\ matches\ the\ bit\ information\ order\ in\ the\ bitset\ and\ the\ template}}
\DoxyCodeLine{01036\ \ \ \textcolor{comment}{///\ parameter\ \(\backslash\)c\ LowInfoBitIsMSB\ has\ no\ effect.\ That\ means\ that\ \(\backslash\)c\ unpacked\_bits[i]\ will\ be\ equal\ to\ \(\backslash\)c}}
\DoxyCodeLine{01037\ \ \ \textcolor{comment}{///\ bitset.test(i).}}
\DoxyCodeLine{01038\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{01039\ \ \ \textcolor{comment}{///\ \(\backslash\)tparam\ UnsignedInteger\ Value\ type\ of\ the\ array\ where\ packed\ bits\ will\ be\ stored.\ It\ must\ be\ an}}
\DoxyCodeLine{01040\ \ \ \textcolor{comment}{///\ unsigned\ integer.\ \(\backslash\)param[in]\ unpacked\_bits\ Array\ where\ the\ unpacked\ bits\ will\ be\ stored.\ The\ array\ size\ must\ be}}
\DoxyCodeLine{01041\ \ \ \textcolor{comment}{///\ equal\ or\ larger\ than\ the\ bitset\ size\ (in\ bits).\ \(\backslash\)return\ Returns\ the\ number\ of\ bits\ packed.}}
\DoxyCodeLine{01042\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ UnsignedInteger>}
\DoxyCodeLine{01043\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_a27ceb564b67565b694a90d4d951ac70d}{to\_unpacked\_bits}}(span<UnsignedInteger>\ unpacked\_bits)\ \textcolor{keyword}{const}}
\DoxyCodeLine{01044\ \ \ \{}
\DoxyCodeLine{01045\ \ \ \ \ \textcolor{keyword}{static\_assert}(std::is\_unsigned<UnsignedInteger>::value,\ \textcolor{stringliteral}{"{}Only\ unsigned\ integers\ are\ supported"{}});}
\DoxyCodeLine{01046\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(size()\ ==\ unpacked\_bits.size(),}
\DoxyCodeLine{01047\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}ERROR:\ provided\ array\ size='\{\}'\ does\ not\ match\ bitset\ size='\{\}'"{}},}
\DoxyCodeLine{01048\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ unpacked\_bits.size(),}
\DoxyCodeLine{01049\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size());}
\DoxyCodeLine{01050\ }
\DoxyCodeLine{01051\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ i\ =\ 0,\ ie\ =\ size();\ i\ !=\ ie;\ ++i)\ \{}
\DoxyCodeLine{01052\ \ \ \ \ \ \ unpacked\_bits[i]\ =\ test(i);}
\DoxyCodeLine{01053\ \ \ \ \ \}}
\DoxyCodeLine{01054\ \ \ \}}
\DoxyCodeLine{01055\ }
\DoxyCodeLine{01056\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Generates\ a\ list\ of\ bit\ positions\ corresponding\ to\ the\ information\ bits\ set\ to\ one\ or\ zero.}}
\DoxyCodeLine{01057\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{01058\ \ \ \textcolor{comment}{///\ The\ bit\ positions\ correspond\ to\ the\ location\ of\ each\ bit\ within\ the\ information\ bit\ word\ stored\ in\ the\ bitset,}}
\DoxyCodeLine{01059\ \ \ \textcolor{comment}{///\ regardless\ of\ the\ bit\ index\ order\ in\ memory\ given\ by\ \(\backslash\)ref\ LowestInfoBitIsMSB.}}
\DoxyCodeLine{01060\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{01061\ \ \ \textcolor{comment}{///\ \(\backslash\)param[in]\ value\ Selects\ the\ bits\ whose\ positions\ are\ returned.\ Set\ to\ \(\backslash\)c\ true\ to\ find\ ones,\ \(\backslash\)c\ false\ for\ zeros.}}
\DoxyCodeLine{01062\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ A\ list\ containing\ the\ bit\ positions.}}
\DoxyCodeLine{01063\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ace4017d4401eec16716d61a6143d1c07}{static\_vector}}<\mbox{\hyperlink{classsrsran_1_1bounded__bitset_ace4017d4401eec16716d61a6143d1c07}{size\_t}},\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ace4017d4401eec16716d61a6143d1c07}{N}}>\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ace4017d4401eec16716d61a6143d1c07}{get\_bit\_positions}}(\textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset_ace4017d4401eec16716d61a6143d1c07}{value}}\ =\ \textcolor{keyword}{true})\ \textcolor{keyword}{const}}
\DoxyCodeLine{01064\ \ \ \{}
\DoxyCodeLine{01065\ \ \ \ \ static\_vector<size\_t,\ N>\ positions;}
\DoxyCodeLine{01066\ }
\DoxyCodeLine{01067\ \ \ \ \ size\_t\ i\_bit\ =\ 0;}
\DoxyCodeLine{01068\ \ \ \ \ \textcolor{keywordflow}{while}\ (i\_bit\ <\ size())\ \{}
\DoxyCodeLine{01069\ \ \ \ \ \ \ \textcolor{comment}{//\ Find\ the\ next\ bit\ position\ of\ the\ bit\ set\ to\ value.}}
\DoxyCodeLine{01070\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ next\_position\ =\ find\_lowest(i\_bit,\ size(),\ value);}
\DoxyCodeLine{01071\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (next\_position\ <\ 0)\ \{}
\DoxyCodeLine{01072\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{01073\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01074\ }
\DoxyCodeLine{01075\ \ \ \ \ \ \ \textcolor{comment}{//\ If\ a\ bit\ was\ found,\ add\ to\ the\ list.}}
\DoxyCodeLine{01076\ \ \ \ \ \ \ positions.emplace\_back(\textcolor{keyword}{static\_cast}<size\_t>(next\_position));}
\DoxyCodeLine{01077\ }
\DoxyCodeLine{01078\ \ \ \ \ \ \ \textcolor{comment}{//\ Exclude\ the\ evaluated\ bit\ range\ from\ the\ next\ search.}}
\DoxyCodeLine{01079\ \ \ \ \ \ \ i\_bit\ =\ next\_position\ +\ 1;}
\DoxyCodeLine{01080\ \ \ \ \ \}}
\DoxyCodeLine{01081\ }
\DoxyCodeLine{01082\ \ \ \ \ \textcolor{keywordflow}{return}\ positions;}
\DoxyCodeLine{01083\ \ \ \}}
\DoxyCodeLine{01084\ }
\DoxyCodeLine{01085\ \textcolor{keyword}{private}:}
\DoxyCodeLine{01086\ \ \ \textcolor{keyword}{template}\ <size\_t\ N2,\ \textcolor{keywordtype}{bool}\ reversed2>}
\DoxyCodeLine{01087\ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{class}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}};}
\DoxyCodeLine{01088\ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{struct}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{fmt}}::\mbox{\hyperlink{classsrsran_1_1bounded__bitset}{formatter}}<\mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<\mbox{\hyperlink{classsrsran_1_1bounded__bitset}{N}},\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{LowestInfoBitIsMSB}}>>;}
\DoxyCodeLine{01089\ }
\DoxyCodeLine{01090\ \ \ \textcolor{comment}{//\ Capacity\ of\ the\ underlying\ array\ in\ number\ of\ words.}}
\DoxyCodeLine{01091\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{static}\ size\_t\ max\_nof\_words\_()\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ (N\ +\ bits\_per\_word\ -\/\ 1)\ /\ bits\_per\_word;\ \}}
\DoxyCodeLine{01092\ }
\DoxyCodeLine{01093\ \ \ std::array<word\_t,\ max\_nof\_words\_()>\ buffer\ \ \ =\ \{0\};}
\DoxyCodeLine{01094\ \ \ size\_t\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ cur\_size\ =\ 0;}
\DoxyCodeLine{01095\ }
\DoxyCodeLine{01096\ \ \ \textcolor{keywordtype}{void}\ sanitize\_()}
\DoxyCodeLine{01097\ \ \ \{}
\DoxyCodeLine{01098\ \ \ \ \ size\_t\ n\ \ \ \ \ \ =\ size()\ \%\ bits\_per\_word;}
\DoxyCodeLine{01099\ \ \ \ \ size\_t\ nwords\ =\ nof\_words\_();}
\DoxyCodeLine{01100\ \ \ \ \ \textcolor{keywordflow}{if}\ (n\ !=\ 0\ \textcolor{keyword}{and}\ nwords\ >\ 0)\ \{}
\DoxyCodeLine{01101\ \ \ \ \ \ \ buffer[nwords\ -\/\ 1]\ \&=\ \string~((\string~\textcolor{keyword}{static\_cast}<word\_t>(0))\ <<\ n);}
\DoxyCodeLine{01102\ \ \ \ \ \}}
\DoxyCodeLine{01103\ \ \ \}}
\DoxyCodeLine{01104\ }
\DoxyCodeLine{01105\ \ \ \mbox{\hyperlink{compiler_8h_a88276d6141c7aec6bf2376d2f5eb650a}{SRSRAN\_FORCE\_INLINE}}\ size\_t\ get\_bitidx\_(size\_t\ bitpos)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01106\ \ \ \{}
\DoxyCodeLine{01107\ \ \ \ \ \textcolor{keywordflow}{return}\ get\_bitidx\_(bitpos,\ std::integral\_constant<\textcolor{keywordtype}{bool},\ LowestInfoBitIsMSB>\{\});}
\DoxyCodeLine{01108\ \ \ \}}
\DoxyCodeLine{01109\ \ \ \textcolor{comment}{//\ Tag\ dispatching\ for\ LowestInfoBitIsMSB==true.}}
\DoxyCodeLine{01110\ \ \ \mbox{\hyperlink{compiler_8h_a88276d6141c7aec6bf2376d2f5eb650a}{SRSRAN\_FORCE\_INLINE}}\ size\_t\ get\_bitidx\_(size\_t\ bitpos,\ std::true\_type\ \textcolor{comment}{/*unused*/})\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01111\ \ \ \{}
\DoxyCodeLine{01112\ \ \ \ \ \textcolor{keywordflow}{return}\ size()\ -\/\ 1\ -\/\ bitpos;}
\DoxyCodeLine{01113\ \ \ \}}
\DoxyCodeLine{01114\ \ \ \textcolor{comment}{//\ Tag\ dispatching\ for\ LowestInfoBitIsMSB==false.}}
\DoxyCodeLine{01115\ \ \ \mbox{\hyperlink{compiler_8h_a88276d6141c7aec6bf2376d2f5eb650a}{SRSRAN\_FORCE\_INLINE}}\ size\_t\ get\_bitidx\_(size\_t\ bitpos,\ std::false\_type\ \textcolor{comment}{/*unused*/})\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ bitpos;\ \}}
\DoxyCodeLine{01116\ }
\DoxyCodeLine{01117\ \ \ \mbox{\hyperlink{compiler_8h_a88276d6141c7aec6bf2376d2f5eb650a}{SRSRAN\_FORCE\_INLINE}}\ \textcolor{keywordtype}{bool}\ test\_(size\_t\ bitpos)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01118\ \ \ \{}
\DoxyCodeLine{01119\ \ \ \ \ bitpos\ =\ get\_bitidx\_(bitpos);}
\DoxyCodeLine{01120\ \ \ \ \ \textcolor{keywordflow}{return}\ ((get\_word\_(bitpos)\ \&\ maskbit(bitpos))\ !=\ \textcolor{keyword}{static\_cast}<word\_t>(0));}
\DoxyCodeLine{01121\ \ \ \}}
\DoxyCodeLine{01122\ }
\DoxyCodeLine{01123\ \ \ \textcolor{keywordtype}{void}\ set\_(size\_t\ bitpos)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01124\ \ \ \{}
\DoxyCodeLine{01125\ \ \ \ \ bitpos\ =\ get\_bitidx\_(bitpos);}
\DoxyCodeLine{01126\ \ \ \ \ get\_word\_(bitpos)\ |=\ maskbit(bitpos);}
\DoxyCodeLine{01127\ \ \ \}}
\DoxyCodeLine{01128\ }
\DoxyCodeLine{01129\ \ \ \textcolor{keywordtype}{void}\ reset\_(size\_t\ bitpos)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01130\ \ \ \{}
\DoxyCodeLine{01131\ \ \ \ \ bitpos\ =\ get\_bitidx\_(bitpos);}
\DoxyCodeLine{01132\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ae9b6660fbe4f46e85ea4890c56a9eb74}{srsran\_assume}}(bitpos\ <\ cur\_size);}
\DoxyCodeLine{01133\ \ \ \ \ get\_word\_(bitpos)\ \&=\ \string~(maskbit(bitpos));}
\DoxyCodeLine{01134\ \ \ \}}
\DoxyCodeLine{01135\ }
\DoxyCodeLine{01136\ \ \ \mbox{\hyperlink{compiler_8h_a88276d6141c7aec6bf2376d2f5eb650a}{SRSRAN\_FORCE\_INLINE}}\ size\_t\ nof\_words\_()\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ divide\_ceil(size(),\ bits\_per\_word);\ \}}
\DoxyCodeLine{01137\ }
\DoxyCodeLine{01138\ \ \ \mbox{\hyperlink{compiler_8h_a88276d6141c7aec6bf2376d2f5eb650a}{SRSRAN\_FORCE\_INLINE}}\ word\_t\&\ get\_word\_(size\_t\ bitidx)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01139\ \ \ \{}
\DoxyCodeLine{01140\ \ \ \ \ \textcolor{keyword}{const}\ size\_t\ word\_idx\ =\ bitidx\ /\ bits\_per\_word;}
\DoxyCodeLine{01141\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ae9b6660fbe4f46e85ea4890c56a9eb74}{srsran\_assume}}(word\_idx\ <\ buffer.size());}
\DoxyCodeLine{01142\ \ \ \ \ \textcolor{keywordflow}{return}\ buffer[word\_idx];}
\DoxyCodeLine{01143\ \ \ \}}
\DoxyCodeLine{01144\ }
\DoxyCodeLine{01145\ \ \ \mbox{\hyperlink{compiler_8h_a88276d6141c7aec6bf2376d2f5eb650a}{SRSRAN\_FORCE\_INLINE}}\ \textcolor{keyword}{const}\ word\_t\&\ get\_word\_(size\_t\ bitidx)\ \textcolor{keyword}{const}}
\DoxyCodeLine{01146\ \ \ \{}
\DoxyCodeLine{01147\ \ \ \ \ \textcolor{keyword}{const}\ size\_t\ word\_idx\ =\ bitidx\ /\ bits\_per\_word;}
\DoxyCodeLine{01148\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ae9b6660fbe4f46e85ea4890c56a9eb74}{srsran\_assume}}(word\_idx\ <\ buffer.size());}
\DoxyCodeLine{01149\ \ \ \ \ \textcolor{keywordflow}{return}\ buffer[word\_idx];}
\DoxyCodeLine{01150\ \ \ \}}
\DoxyCodeLine{01151\ }
\DoxyCodeLine{01152\ \ \ size\_t\ word\_idx\_(size\_t\ bitidx)\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ bitidx\ /\ bits\_per\_word;\ \}}
\DoxyCodeLine{01153\ }
\DoxyCodeLine{01154\ \ \ \textcolor{keywordtype}{void}\ assert\_within\_bounds\_(size\_t\ pos,\ \textcolor{keywordtype}{bool}\ strict)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01155\ \ \ \{}
\DoxyCodeLine{01156\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(pos\ <\ size()\ \textcolor{keyword}{or}\ (\textcolor{keyword}{not}\ strict\ \textcolor{keyword}{and}\ pos\ ==\ size()),}
\DoxyCodeLine{01157\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}ERROR:\ index='\{\}'\ is\ out-\/of-\/bounds\ for\ bitset\ of\ size='\{\}'"{}},}
\DoxyCodeLine{01158\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pos,}
\DoxyCodeLine{01159\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size());}
\DoxyCodeLine{01160\ \ \ \}}
\DoxyCodeLine{01161\ }
\DoxyCodeLine{01162\ \ \ \textcolor{keywordtype}{void}\ assert\_range\_bounds\_(size\_t\ startpos,\ size\_t\ endpos)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01163\ \ \ \{}
\DoxyCodeLine{01164\ \ \ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(startpos\ <=\ endpos\ \textcolor{keyword}{and}\ endpos\ <=\ size(),}
\DoxyCodeLine{01165\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}ERROR:\ range\ ['\{\}',\ '\{\}')\ out-\/of-\/bounds\ for\ bitsize\ of\ size='\{\}'"{}},}
\DoxyCodeLine{01166\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ startpos,}
\DoxyCodeLine{01167\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ endpos,}
\DoxyCodeLine{01168\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size());}
\DoxyCodeLine{01169\ \ \ \}}
\DoxyCodeLine{01170\ }
\DoxyCodeLine{01171\ \ \ \mbox{\hyperlink{compiler_8h_a88276d6141c7aec6bf2376d2f5eb650a}{SRSRAN\_FORCE\_INLINE}}\ \textcolor{keyword}{static}\ word\_t\ maskbit(size\_t\ pos)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01172\ \ \ \{}
\DoxyCodeLine{01173\ \ \ \ \ \textcolor{keywordflow}{return}\ (\textcolor{keyword}{static\_cast}<word\_t>(1))\ <<\ (pos\ \%\ bits\_per\_word);}
\DoxyCodeLine{01174\ \ \ \}}
\DoxyCodeLine{01175\ }
\DoxyCodeLine{01176\ \ \ \textcolor{keywordtype}{int}\ find\_last\_(size\_t\ startpos,\ size\_t\ endpos,\ \textcolor{keywordtype}{bool}\ value)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01177\ \ \ \{}
\DoxyCodeLine{01178\ \ \ \ \ size\_t\ startword\ =\ startpos\ /\ bits\_per\_word;}
\DoxyCodeLine{01179\ \ \ \ \ size\_t\ lastword\ \ =\ (endpos\ -\/\ 1)\ /\ bits\_per\_word;}
\DoxyCodeLine{01180\ }
\DoxyCodeLine{01181\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ lastword;\ i\ !=\ startword\ -\/\ 1;\ -\/-\/i)\ \{}
\DoxyCodeLine{01182\ \ \ \ \ \ \ word\_t\ w\ =\ buffer[i];}
\DoxyCodeLine{01183\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ value)\ \{}
\DoxyCodeLine{01184\ \ \ \ \ \ \ \ \ w\ =\ \string~w;}
\DoxyCodeLine{01185\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01186\ }
\DoxyCodeLine{01187\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ ==\ startword)\ \{}
\DoxyCodeLine{01188\ \ \ \ \ \ \ \ \ size\_t\ offset\ =\ startpos\ \%\ bits\_per\_word;}
\DoxyCodeLine{01189\ \ \ \ \ \ \ \ \ w\ \&=\ (LowestInfoBitIsMSB)\ ?\ mask\_msb\_zeros<word\_t>(offset)\ :\ mask\_lsb\_zeros<word\_t>(offset);}
\DoxyCodeLine{01190\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01191\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ ==\ lastword)\ \{}
\DoxyCodeLine{01192\ \ \ \ \ \ \ \ \ size\_t\ offset\ =\ (endpos\ -\/\ 1)\ \%\ bits\_per\_word;}
\DoxyCodeLine{01193\ \ \ \ \ \ \ \ \ w\ \&=\ (LowestInfoBitIsMSB)\ ?\ mask\_msb\_ones<word\_t>(offset\ +\ 1)\ :\ mask\_lsb\_ones<word\_t>(offset\ +\ 1);}
\DoxyCodeLine{01194\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01195\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (w\ !=\ 0)\ \{}
\DoxyCodeLine{01196\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast}<\textcolor{keywordtype}{int}>(i\ *\ bits\_per\_word\ +\ find\_first\_msb\_one(w));}
\DoxyCodeLine{01197\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01198\ \ \ \ \ \}}
\DoxyCodeLine{01199\ \ \ \ \ \textcolor{keywordflow}{return}\ -\/1;}
\DoxyCodeLine{01200\ \ \ \}}
\DoxyCodeLine{01201\ }
\DoxyCodeLine{01202\ \ \ \textcolor{keywordtype}{int}\ find\_first\_(size\_t\ startpos,\ size\_t\ endpos,\ \textcolor{keywordtype}{bool}\ value)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01203\ \ \ \{}
\DoxyCodeLine{01204\ \ \ \ \ size\_t\ startword\ =\ startpos\ /\ bits\_per\_word;}
\DoxyCodeLine{01205\ \ \ \ \ size\_t\ lastword\ \ =\ (endpos\ -\/\ 1)\ /\ bits\_per\_word;}
\DoxyCodeLine{01206\ }
\DoxyCodeLine{01207\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ startword;\ i\ <=\ lastword;\ ++i)\ \{}
\DoxyCodeLine{01208\ \ \ \ \ \ \ word\_t\ w\ =\ buffer[i];}
\DoxyCodeLine{01209\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ value)\ \{}
\DoxyCodeLine{01210\ \ \ \ \ \ \ \ \ w\ =\ \string~w;}
\DoxyCodeLine{01211\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01212\ }
\DoxyCodeLine{01213\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ ==\ startword)\ \{}
\DoxyCodeLine{01214\ \ \ \ \ \ \ \ \ size\_t\ offset\ =\ startpos\ \%\ bits\_per\_word;}
\DoxyCodeLine{01215\ \ \ \ \ \ \ \ \ w\ \&=\ mask\_lsb\_zeros<word\_t>(offset);}
\DoxyCodeLine{01216\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01217\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ ==\ lastword)\ \{}
\DoxyCodeLine{01218\ \ \ \ \ \ \ \ \ size\_t\ offset\ =\ (endpos\ -\/\ 1)\ \%\ bits\_per\_word;}
\DoxyCodeLine{01219\ \ \ \ \ \ \ \ \ w\ \&=\ mask\_lsb\_ones<word\_t>(offset\ +\ 1);}
\DoxyCodeLine{01220\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01221\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (w\ !=\ 0)\ \{}
\DoxyCodeLine{01222\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast}<\textcolor{keywordtype}{int}>(i\ *\ bits\_per\_word\ +\ find\_first\_lsb\_one(w));}
\DoxyCodeLine{01223\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01224\ \ \ \ \ \}}
\DoxyCodeLine{01225\ \ \ \ \ \textcolor{keywordflow}{return}\ -\/1;}
\DoxyCodeLine{01226\ \ \ \}}
\DoxyCodeLine{01227\ }
\DoxyCodeLine{01228\ \ \ \textcolor{keywordtype}{int}\ find\_first\_reversed\_(size\_t\ startpos,\ size\_t\ endpos,\ \textcolor{keywordtype}{bool}\ value)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01229\ \ \ \{}
\DoxyCodeLine{01230\ \ \ \ \ size\_t\ startbitpos\ =\ get\_bitidx\_(startpos),\ lastbitpos\ =\ get\_bitidx\_(endpos\ -\/\ 1);}
\DoxyCodeLine{01231\ \ \ \ \ size\_t\ startword\ =\ startbitpos\ /\ bits\_per\_word;}
\DoxyCodeLine{01232\ \ \ \ \ size\_t\ lastword\ \ =\ lastbitpos\ /\ bits\_per\_word;}
\DoxyCodeLine{01233\ }
\DoxyCodeLine{01234\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ startword;\ i\ !=\ lastword\ -\/\ 1;\ -\/-\/i)\ \{}
\DoxyCodeLine{01235\ \ \ \ \ \ \ word\_t\ w\ =\ buffer[i];}
\DoxyCodeLine{01236\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ value)\ \{}
\DoxyCodeLine{01237\ \ \ \ \ \ \ \ \ w\ =\ \string~w;}
\DoxyCodeLine{01238\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01239\ }
\DoxyCodeLine{01240\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ ==\ startword)\ \{}
\DoxyCodeLine{01241\ \ \ \ \ \ \ \ \ size\_t\ offset\ =\ startbitpos\ \%\ bits\_per\_word;}
\DoxyCodeLine{01242\ \ \ \ \ \ \ \ \ w\ \&=\ mask\_lsb\_ones<word\_t>(offset\ +\ 1);}
\DoxyCodeLine{01243\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01244\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ ==\ lastword)\ \{}
\DoxyCodeLine{01245\ \ \ \ \ \ \ \ \ size\_t\ offset\ =\ lastbitpos\ \%\ bits\_per\_word;}
\DoxyCodeLine{01246\ \ \ \ \ \ \ \ \ w\ \&=\ mask\_lsb\_zeros<word\_t>(offset);}
\DoxyCodeLine{01247\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01248\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (w\ !=\ 0)\ \{}
\DoxyCodeLine{01249\ \ \ \ \ \ \ \ \ word\_t\ pos\ =\ find\_first\_msb\_one(w);}
\DoxyCodeLine{01250\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast}<\textcolor{keywordtype}{int}>(size()\ -\/\ 1\ -\/\ (pos\ +\ i\ *\ bits\_per\_word));}
\DoxyCodeLine{01251\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01252\ \ \ \ \ \}}
\DoxyCodeLine{01253\ \ \ \ \ \textcolor{keywordflow}{return}\ -\/1;}
\DoxyCodeLine{01254\ \ \ \}}
\DoxyCodeLine{01255\ }
\DoxyCodeLine{01256\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Finds\ first\ word,\ aka\ integer\ bitmap,\ within\ the\ provided\ bit\ index\ bounds\ for\ which\ the\ provided}}
\DoxyCodeLine{01257\ \ \ \textcolor{comment}{///\ callback\ returns\ true.\ This\ helper\ function\ iterates\ through\ the\ bounded\_bitset\ on\ a\ word-\/by-\/word\ basis.\ Note}}
\DoxyCodeLine{01258\ \ \ \textcolor{comment}{///\ that\ operations\ over\ words\ are\ generally\ faster\ than\ operations\ over\ individual\ bits.\ For\ each\ iterated\ word,\ a}}
\DoxyCodeLine{01259\ \ \ \textcolor{comment}{///\ mask\ of\ the\ selected\ bits\ is\ computed\ (which\ depends\ on\ the\ provided\ "{}start"{}\ and\ "{}stop"{}\ bit\ indexes),\ and\ the}}
\DoxyCodeLine{01260\ \ \ \textcolor{comment}{///\ provided\ callback\ is\ invoked.\ The\ callback\ receives\ as\ arguments\ the\ word\ index\ and\ the\ selected-\/bit\ mask.\ If}}
\DoxyCodeLine{01261\ \ \ \textcolor{comment}{///\ the\ callback\ returns\ true,\ the\ iteration\ stops\ and\ the\ function\ returns\ true.}}
\DoxyCodeLine{01262\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{01263\ \ \ \textcolor{comment}{///\ \(\backslash\)param\ start\ first\ bit\ index\ of\ the\ bounded\_bitset.}}
\DoxyCodeLine{01264\ \ \ \textcolor{comment}{///\ \(\backslash\)param\ stop\ end\ bit\ index\ of\ the\ bounded\_bitset.}}
\DoxyCodeLine{01265\ \ \ \textcolor{comment}{///\ \(\backslash\)param\ c\ Callback\ with\ signature\ "{}bool(size\_t\ word\_index,\ word\_t\ active\_mask)"{}\ called\ for\ each\ word\ of\ the}}
\DoxyCodeLine{01266\ \ \ \textcolor{comment}{///\ bitset.}}
\DoxyCodeLine{01267\ \ \ \textcolor{comment}{///\ \ \ \ \ \ \ \ \ \ When\ this\ callback\ returns\ true,\ the\ iteration\ is\ notify\_stop.}}
\DoxyCodeLine{01268\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ true\ if\ the\ provided\ callback\ returns\ true\ for\ a\ given\ word.\ False\ otherwise.}}
\DoxyCodeLine{01269\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ C>}
\DoxyCodeLine{01270\ \ \ \textcolor{keywordtype}{bool}\ find\_first\_word\_(size\_t\ start,\ size\_t\ stop,\ \textcolor{keyword}{const}\ C\&\ c)\ \textcolor{keyword}{const}}
\DoxyCodeLine{01271\ \ \ \{}
\DoxyCodeLine{01272\ \ \ \ \ assert\_range\_bounds\_(start,\ stop);}
\DoxyCodeLine{01273\ \ \ \ \ \textcolor{keywordflow}{return}\ find\_first\_word\_(start,\ stop,\ c,\ std::integral\_constant<\textcolor{keywordtype}{bool},\ LowestInfoBitIsMSB>\{\});}
\DoxyCodeLine{01274\ \ \ \}}
\DoxyCodeLine{01275\ }
\DoxyCodeLine{01276\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ C>}
\DoxyCodeLine{01277\ \ \ \textcolor{keywordtype}{bool}\ find\_first\_word\_(size\_t\ start,\ size\_t\ stop,\ \textcolor{keyword}{const}\ C\&\ c,\ std::true\_type\ \textcolor{comment}{/*unused*/})\ \textcolor{keyword}{const}}
\DoxyCodeLine{01278\ \ \ \{}
\DoxyCodeLine{01279\ \ \ \ \ std::swap(start,\ stop);}
\DoxyCodeLine{01280\ \ \ \ \ start\ =\ get\_bitidx\_(start)\ +\ 1;}
\DoxyCodeLine{01281\ \ \ \ \ stop\ \ =\ get\_bitidx\_(stop)\ +\ 1;}
\DoxyCodeLine{01282\ \ \ \ \ \textcolor{keywordflow}{return}\ find\_first\_word\_(start,\ stop,\ c,\ std::false\_type\{\});}
\DoxyCodeLine{01283\ \ \ \}}
\DoxyCodeLine{01284\ }
\DoxyCodeLine{01285\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ C>}
\DoxyCodeLine{01286\ \ \ \textcolor{keywordtype}{bool}\ find\_first\_word\_(size\_t\ start,\ size\_t\ stop,\ \textcolor{keyword}{const}\ C\&\ c,\ std::false\_type\ \textcolor{comment}{/*unused*/})\ \textcolor{keyword}{const}}
\DoxyCodeLine{01287\ \ \ \{}
\DoxyCodeLine{01288\ \ \ \ \ size\_t\ start\_word\ =\ word\_idx\_(start);}
\DoxyCodeLine{01289\ \ \ \ \ size\_t\ end\_word\ \ \ =\ word\_idx\_(stop)\ +\ (stop\ \%\ bits\_per\_word\ >\ 0\ ?\ 1U\ :\ 0U);}
\DoxyCodeLine{01290\ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ start\_word;\ i\ !=\ end\_word;\ ++i)\ \{}
\DoxyCodeLine{01291\ \ \ \ \ \ \ word\_t\ mask\ =\ \string~\textcolor{keyword}{static\_cast}<word\_t>(0);}
\DoxyCodeLine{01292\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ ==\ start\_word)\ \{}
\DoxyCodeLine{01293\ \ \ \ \ \ \ \ \ mask\ \&=\ mask\_lsb\_zeros<word\_t>(start\ \%\ bits\_per\_word);}
\DoxyCodeLine{01294\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01295\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ ==\ end\_word\ -\/\ 1)\ \{}
\DoxyCodeLine{01296\ \ \ \ \ \ \ \ \ mask\ \&=\ mask\_msb\_zeros<word\_t>(end\_word\ *\ bits\_per\_word\ -\/\ stop);}
\DoxyCodeLine{01297\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01298\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (c(i,\ mask))\ \{}
\DoxyCodeLine{01299\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01300\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01301\ \ \ \ \ \}}
\DoxyCodeLine{01302\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01303\ \ \ \}}
\DoxyCodeLine{01304\ }
\DoxyCodeLine{01305\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Formatting\ helper\ to\ convert\ bitset\ to\ string\ of\ bits.}}
\DoxyCodeLine{01306\ \ \ \textcolor{comment}{///\ \(\backslash\)tparam\ OutputIt\ Output\ fmt\ memory\ buffer\ type.}}
\DoxyCodeLine{01307\ \ \ \textcolor{comment}{///\ \(\backslash\)param[out]\ mem\_buffer\ Fmt\ memory\ buffer.}}
\DoxyCodeLine{01308\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ The\ memory\ buffer\ passed\ as\ argument.}}
\DoxyCodeLine{01309\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OutputIt>}
\DoxyCodeLine{01310\ \ \ OutputIt\ to\_string\_of\_bits(OutputIt\&\&\ mem\_buffer,\ \textcolor{keywordtype}{bool}\ reverse)\ \textcolor{keyword}{const}}
\DoxyCodeLine{01311\ \ \ \{}
\DoxyCodeLine{01312\ \ \ \ \ \textcolor{keywordflow}{if}\ (size()\ ==\ 0)\ \{}
\DoxyCodeLine{01313\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ mem\_buffer;}
\DoxyCodeLine{01314\ \ \ \ \ \}}
\DoxyCodeLine{01315\ }
\DoxyCodeLine{01316\ \ \ \ \ reverse\ =\ reverse\ \string^\ LowestInfoBitIsMSB;}
\DoxyCodeLine{01317\ }
\DoxyCodeLine{01318\ \ \ \ \ std::string\ s;}
\DoxyCodeLine{01319\ \ \ \ \ s.assign(size(),\ \textcolor{stringliteral}{'0'});}
\DoxyCodeLine{01320\ \ \ \ \ \textcolor{keywordflow}{if}\ (!reverse)\ \{}
\DoxyCodeLine{01321\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ size();\ i\ !=\ 0;\ -\/-\/i)\ \{}
\DoxyCodeLine{01322\ \ \ \ \ \ \ \ \ fmt::format\_to(mem\_buffer,\ \textcolor{stringliteral}{"{}\{\}"{}},\ test(i\ -\/\ 1)\ ?\ \textcolor{stringliteral}{'1'}\ :\ \textcolor{stringliteral}{'0'});}
\DoxyCodeLine{01323\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01324\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01325\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ 0;\ i\ !=\ size();\ ++i)\ \{}
\DoxyCodeLine{01326\ \ \ \ \ \ \ \ \ fmt::format\_to(mem\_buffer,\ \textcolor{stringliteral}{"{}\{\}"{}},\ test(i)\ ?\ \textcolor{stringliteral}{'1'}\ :\ \textcolor{stringliteral}{'0'});}
\DoxyCodeLine{01327\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01328\ \ \ \ \ \}}
\DoxyCodeLine{01329\ \ \ \ \ \textcolor{keywordflow}{return}\ mem\_buffer;}
\DoxyCodeLine{01330\ \ \ \}}
\DoxyCodeLine{01331\ }
\DoxyCodeLine{01332\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Formatting\ helper\ to\ convert\ bitset\ to\ hexadecimal\ digits.}}
\DoxyCodeLine{01333\ \ \ \textcolor{comment}{///\ \(\backslash\)tparam\ OutputIt\ Output\ fmt\ memory\ buffer\ type.}}
\DoxyCodeLine{01334\ \ \ \textcolor{comment}{///\ \(\backslash\)param[out]\ mem\_buffer\ Fmt\ memory\ buffer.}}
\DoxyCodeLine{01335\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ The\ memory\ buffer\ passed\ as\ argument.}}
\DoxyCodeLine{01336\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OutputIt>}
\DoxyCodeLine{01337\ \ \ OutputIt\ to\_string\_of\_hex(OutputIt\&\&\ mem\_buffer,\ \textcolor{keywordtype}{bool}\ reverse)\ \textcolor{keyword}{const}}
\DoxyCodeLine{01338\ \ \ \{}
\DoxyCodeLine{01339\ \ \ \ \ \textcolor{keywordflow}{if}\ (size()\ ==\ 0)\ \{}
\DoxyCodeLine{01340\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ mem\_buffer;}
\DoxyCodeLine{01341\ \ \ \ \ \}}
\DoxyCodeLine{01342\ }
\DoxyCodeLine{01343\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ reverse)\ \{}
\DoxyCodeLine{01344\ \ \ \ \ \ \ \textcolor{comment}{//\ first\ word\ may\ not\ print\ 16\ hex\ digits}}
\DoxyCodeLine{01345\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ \ \ \ i\ \ \ \ \ \ \ \ \ \ =\ nof\_words\_()\ -\/\ 1;}
\DoxyCodeLine{01346\ \ \ \ \ \ \ size\_t\ rem\_digits\ =\ divide\_ceil((size()\ -\/\ (size()\ /\ bits\_per\_word)\ *\ bits\_per\_word),\ 4U);}
\DoxyCodeLine{01347\ \ \ \ \ \ \ fmt::format\_to(mem\_buffer,\ \textcolor{stringliteral}{"{}\{:0>\{\}x\}"{}},\ buffer[i],\ rem\_digits);}
\DoxyCodeLine{01348\ \ \ \ \ \ \ \textcolor{comment}{//\ remaining\ words\ will\ occupy\ 16\ hex\ digits\ each\ (4\ bits\ per\ hex\ digit).}}
\DoxyCodeLine{01349\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (-\/-\/i;\ i\ >=\ 0;\ -\/-\/i)\ \{}
\DoxyCodeLine{01350\ \ \ \ \ \ \ \ \ fmt::format\_to(mem\_buffer,\ \textcolor{stringliteral}{"{}\{:0>16x\}"{}},\ buffer[i]);}
\DoxyCodeLine{01351\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01352\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01353\ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ i\ =\ 0;}
\DoxyCodeLine{01354\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ i\ !=\ nof\_words\_()\ -\/\ 1;\ ++i)\ \{}
\DoxyCodeLine{01355\ \ \ \ \ \ \ \ \ uint64\_t\ w\ =\ bit\_reverse(buffer[i]);}
\DoxyCodeLine{01356\ \ \ \ \ \ \ \ \ fmt::format\_to(mem\_buffer,\ \textcolor{stringliteral}{"{}\{:0>16x\}"{}},\ w);}
\DoxyCodeLine{01357\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01358\ \ \ \ \ \ \ \textcolor{comment}{//\ last\ word\ may\ not\ print\ 16\ hex\ digits}}
\DoxyCodeLine{01359\ \ \ \ \ \ \ size\_t\ \ \ rem\_bits\ \ \ =\ size()\ -\/\ (size()\ /\ bits\_per\_word)\ *\ bits\_per\_word;}
\DoxyCodeLine{01360\ \ \ \ \ \ \ size\_t\ \ \ rem\_digits\ =\ divide\_ceil(rem\_bits,\ 4U);}
\DoxyCodeLine{01361\ \ \ \ \ \ \ uint64\_t\ w\ \ \ \ \ \ \ \ \ \ =\ bit\_reverse(buffer[i])\ >>\ (bits\_per\_word\ -\/\ rem\_bits);}
\DoxyCodeLine{01362\ \ \ \ \ \ \ fmt::format\_to(mem\_buffer,\ \textcolor{stringliteral}{"{}\{:0>\{\}x\}"{}},\ w,\ rem\_digits);}
\DoxyCodeLine{01363\ \ \ \ \ \}}
\DoxyCodeLine{01364\ \ \ \ \ \textcolor{keywordflow}{return}\ mem\_buffer;}
\DoxyCodeLine{01365\ \ \ \}}
\DoxyCodeLine{01366\ \};}
\DoxyCodeLine{01367\ }
\DoxyCodeLine{01368\ \textcolor{comment}{///\ \(\backslash\)brief\ Bitwise\ AND\ operation\ result\ =\ lhs\ \&\ rhs.}}
\DoxyCodeLine{01369\ \textcolor{comment}{///\ \(\backslash\)return\ new\ bounded\_bitset\ that\ results\ from\ the\ Bitwise\ AND\ operation.}}
\DoxyCodeLine{01370\ \textcolor{keyword}{template}\ <size\_t\ N,\ \textcolor{keywordtype}{bool}\ LowestInfoBitIsMSB>}
\DoxyCodeLine{01371\ \textcolor{keyword}{inline}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\ \mbox{\hyperlink{namespacesrsran_a48f008a9e02f546f039eac257867f5df}{operator}}\&(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ lhs,}
\DoxyCodeLine{01372\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ rhs)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01373\ \{}
\DoxyCodeLine{01374\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\ res(lhs);}
\DoxyCodeLine{01375\ \ \ res\ \&=\ rhs;}
\DoxyCodeLine{01376\ \ \ \textcolor{keywordflow}{return}\ res;}
\DoxyCodeLine{01377\ \}}
\DoxyCodeLine{01378\ }
\DoxyCodeLine{01379\ \textcolor{comment}{///\ \(\backslash\)brief\ Bitwise\ AND\ operation\ result\ =\ lhs\ |\ rhs.}}
\DoxyCodeLine{01380\ \textcolor{comment}{///\ \(\backslash\)return\ new\ bounded\_bitset\ that\ results\ from\ the\ Bitwise\ OR\ operation.}}
\DoxyCodeLine{01381\ \textcolor{keyword}{template}\ <size\_t\ N,\ \textcolor{keywordtype}{bool}\ LowestInfoBitIsMSB>}
\DoxyCodeLine{01382\ \textcolor{keyword}{inline}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\ \mbox{\hyperlink{namespacesrsran_af96da31d22b002cd95e72072dff9cbe6}{operator}}|(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ lhs,}
\DoxyCodeLine{01383\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ rhs)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01384\ \{}
\DoxyCodeLine{01385\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\ res(lhs);}
\DoxyCodeLine{01386\ \ \ res\ |=\ rhs;}
\DoxyCodeLine{01387\ \ \ \textcolor{keywordflow}{return}\ res;}
\DoxyCodeLine{01388\ \}}
\DoxyCodeLine{01389\ }
\DoxyCodeLine{01390\ \textcolor{comment}{///\ \(\backslash\)brief\ Flip\ bits\ from\ left\ to\ right.}}
\DoxyCodeLine{01391\ \textcolor{comment}{///\ \(\backslash\)return\ new\ bounded\_bitset\ that\ results\ from\ the\ fliplr\ operation.}}
\DoxyCodeLine{01392\ \textcolor{keyword}{template}\ <size\_t\ N,\ \textcolor{keywordtype}{bool}\ LowestInfoBitIsMSB>}
\DoxyCodeLine{01393\ \textcolor{keyword}{inline}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\ \mbox{\hyperlink{namespacesrsran_a7ad99f8abc0bf25b3d16248cbc70bd78}{fliplr}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ other)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01394\ \{}
\DoxyCodeLine{01395\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\ ret(other.size());}
\DoxyCodeLine{01396\ \ \ \textcolor{keywordflow}{for}\ (uint32\_t\ i\ =\ 0;\ i\ <\ ret.size();\ ++i)\ \{}
\DoxyCodeLine{01397\ \ \ \ \ \textcolor{keywordflow}{if}\ (other.test(i))\ \{}
\DoxyCodeLine{01398\ \ \ \ \ \ \ ret.set(ret.size()\ -\/\ 1\ -\/\ i);}
\DoxyCodeLine{01399\ \ \ \ \ \}}
\DoxyCodeLine{01400\ \ \ \}}
\DoxyCodeLine{01401\ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{01402\ \}}
\DoxyCodeLine{01403\ }
\DoxyCodeLine{01404\ \textcolor{comment}{///\ \(\backslash\)brief\ Divides\ a\ bitset\ of\ size\ "{}S"{}\ into\ "{}M"{}\ smaller\ bitsets,\ where\ each\ bitset\ has\ length\ "{}L=S/M"{}.\ A\ bitwise-\/or}}
\DoxyCodeLine{01405\ \textcolor{comment}{///\ operation\ is\ performed\ across\ bitsets.\ At\ the\ end,\ a\ slice\ with\ an\ offset\ "{}O"{}\ and\ length\ "{}K"{}\ is\ taken\ from\ the}}
\DoxyCodeLine{01406\ \textcolor{comment}{///\ bitset\ of\ length\ "{}L"{}\ that\ resulted\ from\ the\ bitwise-\/or\ operation.}}
\DoxyCodeLine{01407\ \textcolor{comment}{///\ This\ operation\ is\ equivalent\ to\ reshaping\ an\ array\ of\ bits\ of\ size\ "{}S"{}\ into\ a\ matrix\ of\ dimensions\ "{}(M,\ L)"{}\ and}}
\DoxyCodeLine{01408\ \textcolor{comment}{///\ applying\ an\ "{}or"{}\ operation\ across\ all\ bits\ of\ each\ column.\ The\ resulting\ array\ of\ "{}L"{}\ bits,\ is\ then\ sliced\ with}}
\DoxyCodeLine{01409\ \textcolor{comment}{///\ an\ offset\ "{}O"{}\ and\ length\ "{}K"{}.}}
\DoxyCodeLine{01410\ \textcolor{comment}{///\ The\ operation\ asserts\ if\ "{}S\ \%\ L\ !=\ 0"{}.}}
\DoxyCodeLine{01411\ \textcolor{comment}{///\ E.g.\ Consider\ the\ bitset\ 1000\ 0100\ 0000\ 1001\ (S=16),\ L=4,\ O=1,\ K=2.\ This\ function\ performs\ the\ following\ steps:}}
\DoxyCodeLine{01412\ \textcolor{comment}{///\ 1.\ Break\ the\ bitset\ into\ M=S/L=4\ parts:\ \{1000,\ 0100,\ 0000,\ 1001\}.}}
\DoxyCodeLine{01413\ \textcolor{comment}{///\ 2.\ Bitwise-\/or\ all\ the\ M\ parts:\ 1101.}}
\DoxyCodeLine{01414\ \textcolor{comment}{///\ 3.\ Slice\ the\ bitset\ obtained\ in\ 2.\ with\ offset\ O=1\ and\ slice\ length\ K=2:\ 10.}}
\DoxyCodeLine{01415\ \textcolor{comment}{///}}
\DoxyCodeLine{01416\ \textcolor{comment}{///\ \(\backslash\)tparam\ N2\ maximum\ bitset\ size\ for\ returned\ bitset.}}
\DoxyCodeLine{01417\ \textcolor{comment}{///\ \(\backslash\)param[in]\ other\ original\ bitset\ of\ length\ "{}S"{}.}}
\DoxyCodeLine{01418\ \textcolor{comment}{///\ \(\backslash\)param[in]\ fold\_length\ length\ of\ each\ folded\ bitset\ "{}L"{}.}}
\DoxyCodeLine{01419\ \textcolor{comment}{///\ \(\backslash\)param[in]\ slice\_offset\ offset\ from\ where\ to\ slice\ each\ fold\ "{}O"{}.}}
\DoxyCodeLine{01420\ \textcolor{comment}{///\ \(\backslash\)param[in]\ slice\_length\ length\ of\ the\ slice\ taken\ from\ each\ fold\ "{}K"{}.}}
\DoxyCodeLine{01421\ \textcolor{comment}{///\ \(\backslash\)return\ bitset\ of\ size\ slice\_length\ with\ the\ or-\/accumulated\ folds.}}
\DoxyCodeLine{01422\ \textcolor{keyword}{template}\ <size\_t\ N2,\ size\_t\ N,\ \textcolor{keywordtype}{bool}\ LowestInfoBitIsMSB>}
\DoxyCodeLine{01423\ \textcolor{keyword}{inline}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N2,\ LowestInfoBitIsMSB>\ \mbox{\hyperlink{namespacesrsran_aa216729f615b99df2fe9a16848d88f44}{fold\_and\_accumulate}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ other,}
\DoxyCodeLine{01424\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ fold\_length,}
\DoxyCodeLine{01425\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ slice\_offset,}
\DoxyCodeLine{01426\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ slice\_length)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01427\ \{}
\DoxyCodeLine{01428\ \ \ \mbox{\hyperlink{srsran__assert_8h_ab080308588b563333b9da75e3746eed6}{srsran\_assert}}(}
\DoxyCodeLine{01429\ \ \ \ \ \ \ other.size()\ \%\ fold\_length\ ==\ 0,\ \textcolor{stringliteral}{"{}Invalid\ fold\ length=\{\}\ for\ bitset\ of\ size=\{\}"{}},\ fold\_length,\ other.size());}
\DoxyCodeLine{01430\ \ \ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N2,\ LowestInfoBitIsMSB>\ ret(slice\_length);}
\DoxyCodeLine{01431\ \ \ \textcolor{keywordflow}{for}\ (size\_t\ i\ =\ 0;\ i\ !=\ other.size();\ i\ +=\ fold\_length)\ \{}
\DoxyCodeLine{01432\ \ \ \ \ ret\ |=\ other.\textcolor{keyword}{template}\ slice<N2>(i\ +\ slice\_offset,\ i\ +\ slice\_offset\ +\ slice\_length);}
\DoxyCodeLine{01433\ \ \ \}}
\DoxyCodeLine{01434\ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{01435\ \}}
\DoxyCodeLine{01436\ }
\DoxyCodeLine{01437\ \textcolor{comment}{///\ \(\backslash\)brief\ Performs\ the\ fold\ and\ accumulate\ operation,\ but\ without\ slicing\ at\ the\ end.}}
\DoxyCodeLine{01438\ \textcolor{comment}{///}}
\DoxyCodeLine{01439\ \textcolor{comment}{///\ \(\backslash\)tparam\ N2\ maximum\ bitset\ size\ for\ returned\ bitset.}}
\DoxyCodeLine{01440\ \textcolor{comment}{///\ \(\backslash\)tparam\ LowestInfoBitIsMSB\ internal\ bit\ order\ representation\ of\ returned\ bitset.}}
\DoxyCodeLine{01441\ \textcolor{comment}{///\ \(\backslash\)param[in]\ other\ original\ bitset\ from\ where\ folds\ are\ generated.}}
\DoxyCodeLine{01442\ \textcolor{comment}{///\ \(\backslash\)param[in]\ fold\_length\ length\ of\ each\ fold\ bitset.}}
\DoxyCodeLine{01443\ \textcolor{comment}{///\ \(\backslash\)return\ bitset\ of\ size\ fold\_length\ with\ the\ accumulated\ folds.}}
\DoxyCodeLine{01444\ \textcolor{keyword}{template}\ <size\_t\ N2,\ size\_t\ N,\ \textcolor{keywordtype}{bool}\ LowestInfoBitIsMSB>}
\DoxyCodeLine{01445\ \textcolor{keyword}{inline}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N2,\ LowestInfoBitIsMSB>\ \mbox{\hyperlink{namespacesrsran_a208925971da742f3d5e7f4a45b7a09fb}{fold\_and\_accumulate}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1bounded__bitset}{bounded\_bitset}}<N,\ LowestInfoBitIsMSB>\&\ other,}
\DoxyCodeLine{01446\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ fold\_length)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{01447\ \{}
\DoxyCodeLine{01448\ \ \ \textcolor{keywordflow}{return}\ fold\_and\_accumulate<N2,\ N,\ LowestInfoBitIsMSB>(other,\ fold\_length,\ 0,\ fold\_length);}
\DoxyCodeLine{01449\ \}}
\DoxyCodeLine{01450\ }
\DoxyCodeLine{01451\ \}\ \textcolor{comment}{//\ namespace\ srsran}}
\DoxyCodeLine{01452\ }
\DoxyCodeLine{01453\ \textcolor{keyword}{namespace}\ fmt\ \{}
\DoxyCodeLine{01454\ \textcolor{comment}{///\ \(\backslash\)brief\ Custom\ formatter\ for\ bounded\_bitset<N,\ LowestInfoBitIsMSB>}}
\DoxyCodeLine{01455\ \textcolor{keyword}{template}\ <size\_t\ N,\ \textcolor{keywordtype}{bool}\ LowestInfoBitIsMSB>}
\DoxyCodeLine{01456\ \textcolor{keyword}{struct}\ formatter<srsran::bounded\_bitset<N,\ LowestInfoBitIsMSB>>\ \{}
\DoxyCodeLine{01457\ \ \ \textcolor{keyword}{enum}\ \{\ hexadecimal,\ binary,\ bit\_positions\ \}\ mode\ =\ binary;}
\DoxyCodeLine{01458\ \ \ \textcolor{keyword}{enum}\ \{\ forward,\ reverse\ \}\ order\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ forward;}
\DoxyCodeLine{01459\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ParseContext>}
\DoxyCodeLine{01460\ \ \ \textcolor{keyword}{auto}\ parse(ParseContext\&\ ctx)\ -\/>\ \textcolor{keyword}{decltype}(ctx.begin())}
\DoxyCodeLine{01461\ \ \ \{}
\DoxyCodeLine{01462\ \ \ \ \ \textcolor{keyword}{auto}\ it\ =\ ctx.begin();}
\DoxyCodeLine{01463\ \ \ \ \ \textcolor{keywordflow}{while}\ (it\ !=\ ctx.end()\ \textcolor{keyword}{and}\ *it\ !=\ \textcolor{stringliteral}{'\}'})\ \{}
\DoxyCodeLine{01464\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (*it\ ==\ \textcolor{stringliteral}{'x'})\ \{}
\DoxyCodeLine{01465\ \ \ \ \ \ \ \ \ mode\ =\ hexadecimal;}
\DoxyCodeLine{01466\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01467\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (*it\ ==\ \textcolor{stringliteral}{'r'})\ \{}
\DoxyCodeLine{01468\ \ \ \ \ \ \ \ \ order\ =\ reverse;}
\DoxyCodeLine{01469\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01470\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (*it\ ==\ \textcolor{stringliteral}{'n'})\ \{}
\DoxyCodeLine{01471\ \ \ \ \ \ \ \ \ mode\ =\ bit\_positions;}
\DoxyCodeLine{01472\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01473\ \ \ \ \ \ \ ++it;}
\DoxyCodeLine{01474\ \ \ \ \ \}}
\DoxyCodeLine{01475\ }
\DoxyCodeLine{01476\ \ \ \ \ \textcolor{keywordflow}{return}\ it;}
\DoxyCodeLine{01477\ \ \ \}}
\DoxyCodeLine{01478\ }
\DoxyCodeLine{01479\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FormatContext>}
\DoxyCodeLine{01480\ \ \ \textcolor{keyword}{auto}\ format(\textcolor{keyword}{const}\ srsran::bounded\_bitset<N,\ LowestInfoBitIsMSB>\&\ s,\ FormatContext\&\ ctx)}
\DoxyCodeLine{01481\ \ \ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(std::declval<FormatContext>().out())}
\DoxyCodeLine{01482\ \ \ \{}
\DoxyCodeLine{01483\ \ \ \ \ \textcolor{keywordflow}{if}\ (mode\ ==\ hexadecimal)\ \{}
\DoxyCodeLine{01484\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ s.\textcolor{keyword}{template}\ to\_string\_of\_hex(ctx.out(),\ order\ ==\ reverse);}
\DoxyCodeLine{01485\ \ \ \ \ \}}
\DoxyCodeLine{01486\ }
\DoxyCodeLine{01487\ \ \ \ \ \textcolor{keywordflow}{if}\ (mode\ ==\ bit\_positions)\ \{}
\DoxyCodeLine{01488\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (s.is\_contiguous())\ \{}
\DoxyCodeLine{01489\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ lowest\ \ =\ s.find\_lowest();}
\DoxyCodeLine{01490\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ highest\ =\ s.find\_highest();}
\DoxyCodeLine{01491\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (lowest\ ==\ highest)\ \{}
\DoxyCodeLine{01492\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Single\ value.}}
\DoxyCodeLine{01493\ \ \ \ \ \ \ \ \ \ \ fmt::format\_to(ctx.out(),\ \textcolor{stringliteral}{"{}\{\}"{}},\ lowest);}
\DoxyCodeLine{01494\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01495\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Format\ as\ a\ range.}}
\DoxyCodeLine{01496\ \ \ \ \ \ \ \ \ \ \ fmt::format\_to(ctx.out(),\ \textcolor{stringliteral}{"{}[\{\},\ \{\})"{}},\ lowest,\ highest\ +\ 1);}
\DoxyCodeLine{01497\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01498\ }
\DoxyCodeLine{01499\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01500\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Format\ as\ a\ list\ of\ bit\ positions.}}
\DoxyCodeLine{01501\ \ \ \ \ \ \ \ \ srsran::static\_vector<size\_t,\ N>\ bit\_pos\ =\ s.get\_bit\_positions();}
\DoxyCodeLine{01502\ }
\DoxyCodeLine{01503\ \ \ \ \ \ \ \ \ fmt::format\_to(ctx.out(),\ \textcolor{stringliteral}{"{}\{\}"{}},\ srsran::span<size\_t>(bit\_pos));}
\DoxyCodeLine{01504\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01505\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ctx.out();}
\DoxyCodeLine{01506\ \ \ \ \ \}}
\DoxyCodeLine{01507\ }
\DoxyCodeLine{01508\ \ \ \ \ \textcolor{keywordflow}{return}\ s.\textcolor{keyword}{template}\ to\_string\_of\_bits(ctx.out(),\ order\ ==\ reverse);}
\DoxyCodeLine{01509\ \ \ \}}
\DoxyCodeLine{01510\ \};}
\DoxyCodeLine{01511\ \}\ \textcolor{comment}{//\ namespace\ fmt}}

\end{DoxyCode}
