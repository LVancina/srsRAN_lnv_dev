\doxysection{concurrentqueue.\+h}
\hypertarget{concurrentqueue_8h_source}{}\label{concurrentqueue_8h_source}\index{external/cameron314/concurrentqueue.h@{external/cameron314/concurrentqueue.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{//\ Provides\ a\ C++11\ implementation\ of\ a\ multi-\/producer,\ multi-\/consumer\ lock-\/free\ queue.}}
\DoxyCodeLine{00002\ \textcolor{comment}{//\ An\ overview,\ including\ benchmark\ results,\ is\ provided\ here:}}
\DoxyCodeLine{00003\ \textcolor{comment}{//\ \ \ \ \ http://moodycamel.com/blog/2014/a-\/fast-\/general-\/purpose-\/lock-\/free-\/queue-\/for-\/c++}}
\DoxyCodeLine{00004\ \textcolor{comment}{//\ The\ full\ design\ is\ also\ described\ in\ excruciating\ detail\ at:}}
\DoxyCodeLine{00005\ \textcolor{comment}{//\ \ \ \ http://moodycamel.com/blog/2014/detailed-\/design-\/of-\/a-\/lock-\/free-\/queue}}
\DoxyCodeLine{00006\ }
\DoxyCodeLine{00007\ \textcolor{comment}{//\ Simplified\ BSD\ license:}}
\DoxyCodeLine{00008\ \textcolor{comment}{//\ Copyright\ (c)\ 2013-\/2020,\ Cameron\ Desrochers.}}
\DoxyCodeLine{00009\ \textcolor{comment}{//\ All\ rights\ reserved.}}
\DoxyCodeLine{00010\ \textcolor{comment}{//}}
\DoxyCodeLine{00011\ \textcolor{comment}{//\ Redistribution\ and\ use\ in\ source\ and\ binary\ forms,\ with\ or\ without\ modification,}}
\DoxyCodeLine{00012\ \textcolor{comment}{//\ are\ permitted\ provided\ that\ the\ following\ conditions\ are\ met:}}
\DoxyCodeLine{00013\ \textcolor{comment}{//}}
\DoxyCodeLine{00014\ \textcolor{comment}{//\ -\/\ Redistributions\ of\ source\ code\ must\ retain\ the\ above\ copyright\ notice,\ this\ list\ of}}
\DoxyCodeLine{00015\ \textcolor{comment}{//\ conditions\ and\ the\ following\ disclaimer.}}
\DoxyCodeLine{00016\ \textcolor{comment}{//\ -\/\ Redistributions\ in\ binary\ form\ must\ reproduce\ the\ above\ copyright\ notice,\ this\ list\ of}}
\DoxyCodeLine{00017\ \textcolor{comment}{//\ conditions\ and\ the\ following\ disclaimer\ in\ the\ documentation\ and/or\ other\ materials}}
\DoxyCodeLine{00018\ \textcolor{comment}{//\ provided\ with\ the\ distribution.}}
\DoxyCodeLine{00019\ \textcolor{comment}{//}}
\DoxyCodeLine{00020\ \textcolor{comment}{//\ THIS\ SOFTWARE\ IS\ PROVIDED\ BY\ THE\ COPYRIGHT\ HOLDERS\ AND\ CONTRIBUTORS\ "{}AS\ IS"{}\ AND\ ANY}}
\DoxyCodeLine{00021\ \textcolor{comment}{//\ EXPRESS\ OR\ IMPLIED\ WARRANTIES,\ INCLUDING,\ BUT\ NOT\ LIMITED\ TO,\ THE\ IMPLIED\ WARRANTIES\ OF}}
\DoxyCodeLine{00022\ \textcolor{comment}{//\ MERCHANTABILITY\ AND\ FITNESS\ FOR\ A\ PARTICULAR\ PURPOSE\ ARE\ DISCLAIMED.\ IN\ NO\ EVENT\ SHALL}}
\DoxyCodeLine{00023\ \textcolor{comment}{//\ THE\ COPYRIGHT\ HOLDER\ OR\ CONTRIBUTORS\ BE\ LIABLE\ FOR\ ANY\ DIRECT,\ INDIRECT,\ INCIDENTAL,}}
\DoxyCodeLine{00024\ \textcolor{comment}{//\ SPECIAL,\ EXEMPLARY,\ OR\ CONSEQUENTIAL\ DAMAGES\ (INCLUDING,\ BUT\ NOT\ LIMITED\ TO,\ PROCUREMENT}}
\DoxyCodeLine{00025\ \textcolor{comment}{//\ OF\ SUBSTITUTE\ GOODS\ OR\ SERVICES;\ LOSS\ OF\ USE,\ DATA,\ OR\ PROFITS;\ OR\ BUSINESS\ INTERRUPTION)}}
\DoxyCodeLine{00026\ \textcolor{comment}{//\ HOWEVER\ CAUSED\ AND\ ON\ ANY\ THEORY\ OF\ LIABILITY,\ WHETHER\ IN\ CONTRACT,\ STRICT\ LIABILITY,\ OR}}
\DoxyCodeLine{00027\ \textcolor{comment}{//\ TORT\ (INCLUDING\ NEGLIGENCE\ OR\ OTHERWISE)\ ARISING\ IN\ ANY\ WAY\ OUT\ OF\ THE\ USE\ OF\ THIS\ SOFTWARE,}}
\DoxyCodeLine{00028\ \textcolor{comment}{//\ EVEN\ IF\ ADVISED\ OF\ THE\ POSSIBILITY\ OF\ SUCH\ DAMAGE.}}
\DoxyCodeLine{00029\ }
\DoxyCodeLine{00030\ \textcolor{comment}{//\ Also\ dual-\/licensed\ under\ the\ Boost\ Software\ License\ (see\ LICENSE.md)}}
\DoxyCodeLine{00031\ }
\DoxyCodeLine{00032\ \textcolor{preprocessor}{\#pragma\ once}}
\DoxyCodeLine{00033\ }
\DoxyCodeLine{00034\ \textcolor{preprocessor}{\#if\ defined(\_\_GNUC\_\_)\ \&\&\ !defined(\_\_INTEL\_COMPILER)}}
\DoxyCodeLine{00035\ \textcolor{comment}{//\ Disable\ -\/Wconversion\ warnings\ (spuriously\ triggered\ when\ Traits::size\_t\ and}}
\DoxyCodeLine{00036\ \textcolor{comment}{//\ Traits::index\_t\ are\ set\ to\ <\ 32\ bits,\ causing\ integer\ promotion,\ causing\ warnings}}
\DoxyCodeLine{00037\ \textcolor{comment}{//\ upon\ assigning\ any\ computed\ values)}}
\DoxyCodeLine{00038\ \textcolor{preprocessor}{\#pragma\ GCC\ diagnostic\ push}}
\DoxyCodeLine{00039\ \textcolor{preprocessor}{\#pragma\ GCC\ diagnostic\ ignored\ "{}-\/Wconversion"{}}}
\DoxyCodeLine{00040\ }
\DoxyCodeLine{00041\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_USE\_RELACY}}
\DoxyCodeLine{00042\ \textcolor{preprocessor}{\#pragma\ GCC\ diagnostic\ ignored\ "{}-\/Wint-\/to-\/pointer-\/cast"{}}}
\DoxyCodeLine{00043\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00044\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00045\ }
\DoxyCodeLine{00046\ \textcolor{preprocessor}{\#if\ defined(\_MSC\_VER)\ \&\&\ (!defined(\_HAS\_CXX17)\ ||\ !\_HAS\_CXX17)}}
\DoxyCodeLine{00047\ \textcolor{comment}{//\ VS2019\ with\ /W4\ warns\ about\ constant\ conditional\ expressions\ but\ unless\ /std=c++17\ or\ higher}}
\DoxyCodeLine{00048\ \textcolor{comment}{//\ does\ not\ support\ \`{}if\ constexpr`,\ so\ we\ have\ no\ choice\ but\ to\ simply\ disable\ the\ warning}}
\DoxyCodeLine{00049\ \textcolor{preprocessor}{\#pragma\ warning(push)}}
\DoxyCodeLine{00050\ \textcolor{preprocessor}{\#pragma\ warning(disable:\ 4127)\ \ }\textcolor{comment}{//\ conditional\ expression\ is\ constant}}
\DoxyCodeLine{00051\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00052\ }
\DoxyCodeLine{00053\ \textcolor{preprocessor}{\#if\ defined(\_\_APPLE\_\_)}}
\DoxyCodeLine{00054\ \textcolor{preprocessor}{\#include\ "{}TargetConditionals.h"{}}}
\DoxyCodeLine{00055\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00056\ }
\DoxyCodeLine{00057\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_USE\_RELACY}}
\DoxyCodeLine{00058\ \textcolor{preprocessor}{\#include\ "{}relacy/relacy\_std.hpp"{}}}
\DoxyCodeLine{00059\ \textcolor{preprocessor}{\#include\ "{}relacy\_shims.h"{}}}
\DoxyCodeLine{00060\ \textcolor{comment}{//\ We\ only\ use\ malloc/free\ anyway,\ and\ the\ delete\ macro\ messes\ up\ \`{}=\ delete`\ method\ declarations.}}
\DoxyCodeLine{00061\ \textcolor{comment}{//\ We'll\ override\ the\ default\ trait\ malloc\ ourselves\ without\ a\ macro.}}
\DoxyCodeLine{00062\ \textcolor{preprocessor}{\#undef\ new}}
\DoxyCodeLine{00063\ \textcolor{preprocessor}{\#undef\ delete}}
\DoxyCodeLine{00064\ \textcolor{preprocessor}{\#undef\ malloc}}
\DoxyCodeLine{00065\ \textcolor{preprocessor}{\#undef\ free}}
\DoxyCodeLine{00066\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00067\ \textcolor{preprocessor}{\#include\ <atomic>}\ \ \ \ \ \ \ \textcolor{comment}{//\ Requires\ C++11.\ Sorry\ VS2010.}}
\DoxyCodeLine{00068\ \textcolor{preprocessor}{\#include\ <cassert>}}
\DoxyCodeLine{00069\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00070\ \textcolor{preprocessor}{\#include\ <cstddef>}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ for\ max\_align\_t}}
\DoxyCodeLine{00071\ \textcolor{preprocessor}{\#include\ <cstdint>}}
\DoxyCodeLine{00072\ \textcolor{preprocessor}{\#include\ <cstdlib>}}
\DoxyCodeLine{00073\ \textcolor{preprocessor}{\#include\ <type\_traits>}}
\DoxyCodeLine{00074\ \textcolor{preprocessor}{\#include\ <algorithm>}}
\DoxyCodeLine{00075\ \textcolor{preprocessor}{\#include\ <utility>}}
\DoxyCodeLine{00076\ \textcolor{preprocessor}{\#include\ <limits>}}
\DoxyCodeLine{00077\ \textcolor{preprocessor}{\#include\ <climits>}\ \ \ \ \ \ \textcolor{comment}{//\ for\ CHAR\_BIT}}
\DoxyCodeLine{00078\ \textcolor{preprocessor}{\#include\ <array>}}
\DoxyCodeLine{00079\ \textcolor{preprocessor}{\#include\ <thread>}\ \ \ \ \ \ \ \textcolor{comment}{//\ partly\ for\ \_\_WINPTHREADS\_VERSION\ if\ on\ MinGW-\/w64\ w/\ POSIX\ threading}}
\DoxyCodeLine{00080\ \textcolor{preprocessor}{\#include\ <mutex>}\ \ \ \ \ \ \ \ \textcolor{comment}{//\ used\ for\ thread\ exit\ synchronization}}
\DoxyCodeLine{00081\ }
\DoxyCodeLine{00082\ \textcolor{comment}{//\ Platform-\/specific\ definitions\ of\ a\ numeric\ thread\ ID\ type\ and\ an\ invalid\ value}}
\DoxyCodeLine{00083\ \textcolor{keyword}{namespace\ }moodycamel\ \{\ \textcolor{keyword}{namespace\ }details\ \{}
\DoxyCodeLine{00084\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ thread\_\textcolor{keywordtype}{id}\_t>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1thread__id__converter}{thread\_id\_converter}}\ \{}
\DoxyCodeLine{00085\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typedef}\ thread\_id\_t\ thread\_id\_numeric\_size\_t;}
\DoxyCodeLine{00086\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typedef}\ thread\_id\_t\ thread\_id\_hash\_t;}
\DoxyCodeLine{00087\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ thread\_id\_hash\_t\ prehash(thread\_id\_t\ \textcolor{keyword}{const}\&\ x)\ \{\ \textcolor{keywordflow}{return}\ x;\ \}}
\DoxyCodeLine{00088\ \ \ \ \ \};}
\DoxyCodeLine{00089\ \}\ \}}
\DoxyCodeLine{00090\ \textcolor{preprocessor}{\#if\ defined(MCDBGQ\_USE\_RELACY)}}
\DoxyCodeLine{00091\ \textcolor{keyword}{namespace\ }moodycamel\ \{\ \textcolor{keyword}{namespace\ }details\ \{}
\DoxyCodeLine{00092\ \ \ \ \ \textcolor{keyword}{typedef}\ std::uint32\_t\ thread\_id\_t;}
\DoxyCodeLine{00093\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ thread\_id\_t\ invalid\_thread\_id\ \ =\ 0xFFFFFFFFU;}
\DoxyCodeLine{00094\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ thread\_id\_t\ invalid\_thread\_id2\ =\ 0xFFFFFFFEU;}
\DoxyCodeLine{00095\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ thread\_id\_t\ thread\_id()\ \{\ \textcolor{keywordflow}{return}\ rl::thread\_index();\ \}}
\DoxyCodeLine{00096\ \}\ \}}
\DoxyCodeLine{00097\ \textcolor{preprocessor}{\#elif\ defined(\_WIN32)\ ||\ defined(\_\_WINDOWS\_\_)\ ||\ defined(\_\_WIN32\_\_)}}
\DoxyCodeLine{00098\ \textcolor{comment}{//\ No\ sense\ pulling\ in\ windows.h\ in\ a\ header,\ we'll\ manually\ declare\ the\ function}}
\DoxyCodeLine{00099\ \textcolor{comment}{//\ we\ use\ and\ rely\ on\ backwards-\/compatibility\ for\ this\ not\ to\ break}}
\DoxyCodeLine{00100\ \textcolor{keyword}{extern}\ \textcolor{stringliteral}{"{}C"{}}\ \_\_declspec(dllimport)\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \_\_stdcall\ GetCurrentThreadId(\textcolor{keywordtype}{void});}
\DoxyCodeLine{00101\ \textcolor{keyword}{namespace\ }moodycamel\ \{\ \textcolor{keyword}{namespace\ }details\ \{}
\DoxyCodeLine{00102\ \ \ \ \ \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned}\ long)\ ==\ \textcolor{keyword}{sizeof}(std::uint32\_t),\ \textcolor{stringliteral}{"{}Expected\ size\ of\ unsigned\ long\ to\ be\ 32\ bits\ on\ Windows"{}});}
\DoxyCodeLine{00103\ \ \ \ \ \textcolor{keyword}{typedef}\ std::uint32\_t\ thread\_id\_t;}
\DoxyCodeLine{00104\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ thread\_id\_t\ invalid\_thread\_id\ \ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ See\ http://blogs.msdn.com/b/oldnewthing/archive/2004/02/23/78395.aspx}}
\DoxyCodeLine{00105\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ thread\_id\_t\ invalid\_thread\_id2\ =\ 0xFFFFFFFFU;\ \ \textcolor{comment}{//\ Not\ technically\ guaranteed\ to\ be\ invalid,\ but\ is\ never\ used\ in\ practice.\ Note\ that\ all\ Win32\ thread\ IDs\ are\ presently\ multiples\ of\ 4.}}
\DoxyCodeLine{00106\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ thread\_id\_t\ thread\_id()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}thread\_id\_t\textcolor{keyword}{>}(::GetCurrentThreadId());\ \}}
\DoxyCodeLine{00107\ \}\ \}}
\DoxyCodeLine{00108\ \textcolor{preprocessor}{\#elif\ defined(\_\_arm\_\_)\ ||\ defined(\_M\_ARM)\ ||\ defined(\_\_aarch64\_\_)\ ||\ (defined(\_\_APPLE\_\_)\ \&\&\ TARGET\_OS\_IPHONE)\ ||\ defined(\_\_MVS\_\_)\ ||\ defined(MOODYCAMEL\_NO\_THREAD\_LOCAL)}}
\DoxyCodeLine{00109\ \textcolor{keyword}{namespace\ }moodycamel\ \{\ \textcolor{keyword}{namespace\ }details\ \{}
\DoxyCodeLine{00110\ \ \ \ \ \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(std::thread::id)\ ==\ 4\ ||\ \textcolor{keyword}{sizeof}(std::thread::id)\ ==\ 8,\ \textcolor{stringliteral}{"{}std::thread::id\ is\ expected\ to\ be\ either\ 4\ or\ 8\ bytes"{}});}
\DoxyCodeLine{00111\ }
\DoxyCodeLine{00112\ \ \ \ \ \textcolor{keyword}{typedef}\ std::thread::id\ thread\_id\_t;}
\DoxyCodeLine{00113\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ thread\_id\_t\ invalid\_thread\_id;\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Default\ ctor\ creates\ invalid\ ID}}
\DoxyCodeLine{00114\ }
\DoxyCodeLine{00115\ \ \ \ \ \textcolor{comment}{//\ Note\ we\ don't\ define\ a\ invalid\_thread\_id2\ since\ std::thread::id\ doesn't\ have\ one;\ it's}}
\DoxyCodeLine{00116\ \ \ \ \ \textcolor{comment}{//\ only\ used\ if\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED\ is\ defined\ anyway,\ which\ it\ won't}}
\DoxyCodeLine{00117\ \ \ \ \ \textcolor{comment}{//\ be.}}
\DoxyCodeLine{00118\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ thread\_id\_t\ thread\_id()\ \{\ \textcolor{keywordflow}{return}\ std::this\_thread::get\_id();\ \}}
\DoxyCodeLine{00119\ }
\DoxyCodeLine{00120\ \ \ \ \ \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t}>\ \textcolor{keyword}{struct\ }thread\_id\_size\ \{\ \};}
\DoxyCodeLine{00121\ \ \ \ \ \textcolor{keyword}{template}<>\ \textcolor{keyword}{struct\ }thread\_id\_size<4>\ \{\ \textcolor{keyword}{typedef}\ std::uint32\_t\ numeric\_t;\ \};}
\DoxyCodeLine{00122\ \ \ \ \ \textcolor{keyword}{template}<>\ \textcolor{keyword}{struct\ }thread\_id\_size<8>\ \{\ \textcolor{keyword}{typedef}\ std::uint64\_t\ numeric\_t;\ \};}
\DoxyCodeLine{00123\ }
\DoxyCodeLine{00124\ \ \ \ \ \textcolor{keyword}{template}<>\ \textcolor{keyword}{struct\ }thread\_id\_converter<thread\_id\_t>\ \{}
\DoxyCodeLine{00125\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typedef}\ thread\_id\_size<\textcolor{keyword}{sizeof}(thread\_id\_t)>::numeric\_t\ thread\_id\_numeric\_size\_t;}
\DoxyCodeLine{00126\ \textcolor{preprocessor}{\#ifndef\ \_\_APPLE\_\_}}
\DoxyCodeLine{00127\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typedef}\ std::size\_t\ thread\_id\_hash\_t;}
\DoxyCodeLine{00128\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00129\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typedef}\ thread\_id\_numeric\_size\_t\ thread\_id\_hash\_t;}
\DoxyCodeLine{00130\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00131\ }
\DoxyCodeLine{00132\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ thread\_id\_hash\_t\ prehash(thread\_id\_t\ \textcolor{keyword}{const}\&\ x)}
\DoxyCodeLine{00133\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00134\ \textcolor{preprocessor}{\#ifndef\ \_\_APPLE\_\_}}
\DoxyCodeLine{00135\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::hash<std::thread::id>()(x);}
\DoxyCodeLine{00136\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00137\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{reinterpret\_cast<}thread\_id\_hash\_t\ const*\textcolor{keyword}{>}(\&x);}
\DoxyCodeLine{00138\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00139\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00140\ \ \ \ \ \};}
\DoxyCodeLine{00141\ \}\ \}}
\DoxyCodeLine{00142\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00143\ \textcolor{comment}{//\ Use\ a\ nice\ trick\ from\ this\ answer:\ http://stackoverflow.com/a/8438730/21475}}
\DoxyCodeLine{00144\ \textcolor{comment}{//\ In\ order\ to\ get\ a\ numeric\ thread\ ID\ in\ a\ platform-\/independent\ way,\ we\ use\ a\ thread-\/local}}
\DoxyCodeLine{00145\ \textcolor{comment}{//\ static\ variable's\ address\ as\ a\ thread\ identifier\ :-\/)}}
\DoxyCodeLine{00146\ \textcolor{preprocessor}{\#if\ defined(\_\_GNUC\_\_)\ ||\ defined(\_\_INTEL\_COMPILER)}}
\DoxyCodeLine{00147\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_THREADLOCAL\ \_\_thread}}
\DoxyCodeLine{00148\ \textcolor{preprocessor}{\#elif\ defined(\_MSC\_VER)}}
\DoxyCodeLine{00149\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_THREADLOCAL\ \_\_declspec(thread)}}
\DoxyCodeLine{00150\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00151\ \textcolor{comment}{//\ Assume\ C++11\ compliant\ compiler}}
\DoxyCodeLine{00152\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_THREADLOCAL\ thread\_local}}
\DoxyCodeLine{00153\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00154\ \textcolor{keyword}{namespace\ }moodycamel\ \{\ \textcolor{keyword}{namespace\ }details\ \{}
\DoxyCodeLine{00155\ \ \ \ \ \textcolor{keyword}{typedef}\ std::uintptr\_t\ thread\_id\_t;}
\DoxyCodeLine{00156\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ thread\_id\_t\ invalid\_thread\_id\ \ =\ 0;\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Address\ can't\ be\ nullptr}}
\DoxyCodeLine{00157\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ thread\_id\_t\ invalid\_thread\_id2\ =\ 1;\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Member\ accesses\ off\ a\ null\ pointer\ are\ also\ generally\ invalid.\ Plus\ it's\ not\ aligned.}}
\DoxyCodeLine{00158\ \ \ \ \ \textcolor{keyword}{inline}\ thread\_id\_t\ thread\_id()\ \{\ \textcolor{keyword}{static}\ MOODYCAMEL\_THREADLOCAL\ \textcolor{keywordtype}{int}\ x;\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{reinterpret\_cast<}thread\_id\_t\textcolor{keyword}{>}(\&x);\ \}}
\DoxyCodeLine{00159\ \}\ \}}
\DoxyCodeLine{00160\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00161\ }
\DoxyCodeLine{00162\ \textcolor{comment}{//\ Constexpr\ if}}
\DoxyCodeLine{00163\ \textcolor{preprocessor}{\#ifndef\ MOODYCAMEL\_CONSTEXPR\_IF}}
\DoxyCodeLine{00164\ \textcolor{preprocessor}{\#if\ (defined(\_MSC\_VER)\ \&\&\ defined(\_HAS\_CXX17)\ \&\&\ \_HAS\_CXX17)\ ||\ \_\_cplusplus\ >\ 201402L}}
\DoxyCodeLine{00165\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_CONSTEXPR\_IF\ if\ constexpr}}
\DoxyCodeLine{00166\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_MAYBE\_UNUSED\ [[maybe\_unused]]}}
\DoxyCodeLine{00167\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00168\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_CONSTEXPR\_IF\ if}}
\DoxyCodeLine{00169\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_MAYBE\_UNUSED}}
\DoxyCodeLine{00170\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00171\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00172\ }
\DoxyCodeLine{00173\ \textcolor{comment}{//\ Exceptions}}
\DoxyCodeLine{00174\ \textcolor{preprocessor}{\#ifndef\ MOODYCAMEL\_EXCEPTIONS\_ENABLED}}
\DoxyCodeLine{00175\ \textcolor{preprocessor}{\#if\ (defined(\_MSC\_VER)\ \&\&\ defined(\_CPPUNWIND))\ ||\ (defined(\_\_GNUC\_\_)\ \&\&\ defined(\_\_EXCEPTIONS))\ ||\ (!defined(\_MSC\_VER)\ \&\&\ !defined(\_\_GNUC\_\_))}}
\DoxyCodeLine{00176\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_EXCEPTIONS\_ENABLED}}
\DoxyCodeLine{00177\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00178\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00179\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_EXCEPTIONS\_ENABLED}}
\DoxyCodeLine{00180\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_TRY\ try}}
\DoxyCodeLine{00181\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_CATCH(...)\ catch(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{00182\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_RETHROW\ throw}}
\DoxyCodeLine{00183\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_THROW(expr)\ throw\ (expr)}}
\DoxyCodeLine{00184\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00185\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_TRY\ MOODYCAMEL\_CONSTEXPR\_IF\ (true)}}
\DoxyCodeLine{00186\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_CATCH(...)\ else\ MOODYCAMEL\_CONSTEXPR\_IF\ (false)}}
\DoxyCodeLine{00187\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_RETHROW}}
\DoxyCodeLine{00188\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_THROW(expr)}}
\DoxyCodeLine{00189\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00190\ }
\DoxyCodeLine{00191\ \textcolor{preprocessor}{\#ifndef\ MOODYCAMEL\_NOEXCEPT}}
\DoxyCodeLine{00192\ \textcolor{preprocessor}{\#if\ !defined(MOODYCAMEL\_EXCEPTIONS\_ENABLED)}}
\DoxyCodeLine{00193\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT}}
\DoxyCodeLine{00194\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\_CTOR(type,\ valueType,\ expr)\ true}}
\DoxyCodeLine{00195\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\_ASSIGN(type,\ valueType,\ expr)\ true}}
\DoxyCodeLine{00196\ \textcolor{preprocessor}{\#elif\ defined(\_MSC\_VER)\ \&\&\ defined(\_NOEXCEPT)\ \&\&\ \_MSC\_VER\ <\ 1800}}
\DoxyCodeLine{00197\ \textcolor{comment}{//\ VS2012's\ std::is\_nothrow\_[move\_]constructible\ is\ broken\ and\ returns\ true\ when\ it\ shouldn't\ :-\/(}}
\DoxyCodeLine{00198\ \textcolor{comment}{//\ We\ have\ to\ assume\ *all*\ non-\/trivial\ constructors\ may\ throw\ on\ VS2012!}}
\DoxyCodeLine{00199\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\ \_NOEXCEPT}}
\DoxyCodeLine{00200\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\_CTOR(type,\ valueType,\ expr)\ (std::is\_rvalue\_reference<valueType>::value\ \&\&\ std::is\_move\_constructible<type>::value\ ?\ std::is\_trivially\_move\_constructible<type>::value\ :\ std::is\_trivially\_copy\_constructible<type>::value)}}
\DoxyCodeLine{00201\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\_ASSIGN(type,\ valueType,\ expr)\ ((std::is\_rvalue\_reference<valueType>::value\ \&\&\ std::is\_move\_assignable<type>::value\ ?\ std::is\_trivially\_move\_assignable<type>::value\ ||\ std::is\_nothrow\_move\_assignable<type>::value\ :\ std::is\_trivially\_copy\_assignable<type>::value\ ||\ std::is\_nothrow\_copy\_assignable<type>::value)\ \&\&\ MOODYCAMEL\_NOEXCEPT\_CTOR(type,\ valueType,\ expr))}}
\DoxyCodeLine{00202\ \textcolor{preprocessor}{\#elif\ defined(\_MSC\_VER)\ \&\&\ defined(\_NOEXCEPT)\ \&\&\ \_MSC\_VER\ <\ 1900}}
\DoxyCodeLine{00203\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\ \_NOEXCEPT}}
\DoxyCodeLine{00204\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\_CTOR(type,\ valueType,\ expr)\ (std::is\_rvalue\_reference<valueType>::value\ \&\&\ std::is\_move\_constructible<type>::value\ ?\ std::is\_trivially\_move\_constructible<type>::value\ ||\ std::is\_nothrow\_move\_constructible<type>::value\ :\ std::is\_trivially\_copy\_constructible<type>::value\ ||\ std::is\_nothrow\_copy\_constructible<type>::value)}}
\DoxyCodeLine{00205\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\_ASSIGN(type,\ valueType,\ expr)\ ((std::is\_rvalue\_reference<valueType>::value\ \&\&\ std::is\_move\_assignable<type>::value\ ?\ std::is\_trivially\_move\_assignable<type>::value\ ||\ std::is\_nothrow\_move\_assignable<type>::value\ :\ std::is\_trivially\_copy\_assignable<type>::value\ ||\ std::is\_nothrow\_copy\_assignable<type>::value)\ \&\&\ MOODYCAMEL\_NOEXCEPT\_CTOR(type,\ valueType,\ expr))}}
\DoxyCodeLine{00206\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00207\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\ noexcept}}
\DoxyCodeLine{00208\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\_CTOR(type,\ valueType,\ expr)\ noexcept(expr)}}
\DoxyCodeLine{00209\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NOEXCEPT\_ASSIGN(type,\ valueType,\ expr)\ noexcept(expr)}}
\DoxyCodeLine{00210\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00211\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00212\ }
\DoxyCodeLine{00213\ \textcolor{preprocessor}{\#ifndef\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED}}
\DoxyCodeLine{00214\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_USE\_RELACY}}
\DoxyCodeLine{00215\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED}}
\DoxyCodeLine{00216\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00217\ \textcolor{comment}{//\ VS2013\ doesn't\ support\ \`{}thread\_local`,\ and\ MinGW-\/w64\ w/\ POSIX\ threading\ has\ a\ crippling\ bug:\ http://sourceforge.net/p/mingw-\/w64/bugs/445}}
\DoxyCodeLine{00218\ \textcolor{comment}{//\ g++\ <=4.7\ doesn't\ support\ thread\_local\ either.}}
\DoxyCodeLine{00219\ \textcolor{comment}{//\ Finally,\ iOS/ARM\ doesn't\ have\ support\ for\ it\ either,\ and\ g++/ARM\ allows\ it\ to\ compile\ but\ it's\ unconfirmed\ to\ actually\ work}}
\DoxyCodeLine{00220\ \textcolor{preprocessor}{\#if\ (!defined(\_MSC\_VER)\ ||\ \_MSC\_VER\ >=\ 1900)\ \&\&\ (!defined(\_\_MINGW32\_\_)\ \&\&\ !defined(\_\_MINGW64\_\_)\ ||\ !defined(\_\_WINPTHREADS\_VERSION))\ \&\&\ (!defined(\_\_GNUC\_\_)\ ||\ \_\_GNUC\_\_\ >\ 4\ ||\ (\_\_GNUC\_\_\ ==\ 4\ \&\&\ \_\_GNUC\_MINOR\_\_\ >=\ 8))\ \&\&\ (!defined(\_\_APPLE\_\_)\ ||\ !TARGET\_OS\_IPHONE)\ \&\&\ !defined(\_\_arm\_\_)\ \&\&\ !defined(\_M\_ARM)\ \&\&\ !defined(\_\_aarch64\_\_)\ \&\&\ !defined(\_\_MVS\_\_)}}
\DoxyCodeLine{00221\ \textcolor{comment}{//\ Assume\ \`{}thread\_local`\ is\ fully\ supported\ in\ all\ other\ C++11\ compilers/platforms}}
\DoxyCodeLine{00222\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED\ \ \ \ }\textcolor{comment}{//\ tentatively\ enabled\ for\ now;\ years\ ago\ several\ users\ report\ having\ problems\ with\ it\ on}}
\DoxyCodeLine{00223\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00224\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00225\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00226\ }
\DoxyCodeLine{00227\ \textcolor{comment}{//\ VS2012\ doesn't\ support\ deleted\ functions.}}
\DoxyCodeLine{00228\ \textcolor{comment}{//\ In\ this\ case,\ we\ declare\ the\ function\ normally\ but\ don't\ define\ it.\ A\ link\ error\ will\ be\ generated\ if\ the\ function\ is\ called.}}
\DoxyCodeLine{00229\ \textcolor{preprocessor}{\#ifndef\ MOODYCAMEL\_DELETE\_FUNCTION}}
\DoxyCodeLine{00230\ \textcolor{preprocessor}{\#if\ defined(\_MSC\_VER)\ \&\&\ \_MSC\_VER\ <\ 1800}}
\DoxyCodeLine{00231\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_DELETE\_FUNCTION}}
\DoxyCodeLine{00232\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00233\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_DELETE\_FUNCTION\ =\ delete}}
\DoxyCodeLine{00234\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00235\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00236\ }
\DoxyCodeLine{00237\ \textcolor{keyword}{namespace\ }moodycamel\ \{\ \textcolor{keyword}{namespace\ }details\ \{}
\DoxyCodeLine{00238\ \textcolor{preprocessor}{\#ifndef\ MOODYCAMEL\_ALIGNAS}}
\DoxyCodeLine{00239\ \textcolor{comment}{//\ VS2013\ doesn't\ support\ alignas\ or\ alignof,\ and\ align()\ requires\ a\ constant\ literal}}
\DoxyCodeLine{00240\ \textcolor{preprocessor}{\#if\ defined(\_MSC\_VER)\ \&\&\ \_MSC\_VER\ <=\ 1800}}
\DoxyCodeLine{00241\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_ALIGNAS(alignment)\ \_\_declspec(align(alignment))}}
\DoxyCodeLine{00242\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_ALIGNOF(obj)\ \_\_alignof(obj)}}
\DoxyCodeLine{00243\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_ALIGNED\_TYPE\_LIKE(T,\ obj)\ typename\ details::Vs2013Aligned<std::alignment\_of<obj>::value,\ T>::type}}
\DoxyCodeLine{00244\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keywordtype}{int}\ Align,\ \textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }Vs2013Aligned\ \{\ \};\ \ \textcolor{comment}{//\ default,\ unsupported\ alignment}}
\DoxyCodeLine{00245\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }Vs2013Aligned<1,\ T>\ \{\ \textcolor{keyword}{typedef}\ \_\_declspec(align(1))\ T\ type;\ \};}
\DoxyCodeLine{00246\ \ \ \ \ template<typename\ T>\ struct\ Vs2013Aligned<2,\ T>\ \{\ \textcolor{keyword}{typedef}\ \_\_declspec(align(2))\ T\ type;\ \};}
\DoxyCodeLine{00247\ \ \ \ \ template<typename\ T>\ struct\ Vs2013Aligned<4,\ T>\ \{\ \textcolor{keyword}{typedef}\ \_\_declspec(align(4))\ T\ type;\ \};}
\DoxyCodeLine{00248\ \ \ \ \ template<typename\ T>\ struct\ Vs2013Aligned<8,\ T>\ \{\ \textcolor{keyword}{typedef}\ \_\_declspec(align(8))\ T\ type;\ \};}
\DoxyCodeLine{00249\ \ \ \ \ template<typename\ T>\ struct\ Vs2013Aligned<16,\ T>\ \{\ \textcolor{keyword}{typedef}\ \_\_declspec(align(16))\ T\ type;\ \};}
\DoxyCodeLine{00250\ \ \ \ \ template<typename\ T>\ struct\ Vs2013Aligned<32,\ T>\ \{\ \textcolor{keyword}{typedef}\ \_\_declspec(align(32))\ T\ type;\ \};}
\DoxyCodeLine{00251\ \ \ \ \ template<typename\ T>\ struct\ Vs2013Aligned<64,\ T>\ \{\ \textcolor{keyword}{typedef}\ \_\_declspec(align(64))\ T\ type;\ \};}
\DoxyCodeLine{00252\ \ \ \ \ template<typename\ T>\ struct\ Vs2013Aligned<128,\ T>\ \{\ \textcolor{keyword}{typedef}\ \_\_declspec(align(128))\ T\ type;\ \};}
\DoxyCodeLine{00253\ \ \ \ \ template<typename\ T>\ struct\ Vs2013Aligned<256,\ T>\ \{\ \textcolor{keyword}{typedef}\ \_\_declspec(align(256))\ T\ type;\ \};}
\DoxyCodeLine{00254\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00255\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1identity}{identity}}\ \{\ \textcolor{keyword}{typedef}\ T\ type;\ \};}
\DoxyCodeLine{00256\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_ALIGNAS(alignment)\ alignas(alignment)}}
\DoxyCodeLine{00257\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_ALIGNOF(obj)\ alignof(obj)}}
\DoxyCodeLine{00258\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_ALIGNED\_TYPE\_LIKE(T,\ obj)\ alignas(alignof(obj))\ typename\ details::identity<T>::type}}
\DoxyCodeLine{00259\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00260\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00261\ \}\ \}}
\DoxyCodeLine{00262\ }
\DoxyCodeLine{00263\ }
\DoxyCodeLine{00264\ \textcolor{comment}{//\ TSAN\ can\ false\ report\ races\ in\ lock-\/free\ code.\ \ To\ enable\ TSAN\ to\ be\ used\ from\ projects\ that\ use\ this\ one,}}
\DoxyCodeLine{00265\ \textcolor{comment}{//\ we\ can\ apply\ per-\/function\ compile-\/time\ suppression.}}
\DoxyCodeLine{00266\ \textcolor{comment}{//\ See\ https://clang.llvm.org/docs/ThreadSanitizer.html\#has-\/feature-\/thread-\/sanitizer}}
\DoxyCodeLine{00267\ \textcolor{preprocessor}{\#define\ MOODYCAMEL\_NO\_TSAN}}
\DoxyCodeLine{00268\ \textcolor{preprocessor}{\#if\ defined(\_\_has\_feature)}}
\DoxyCodeLine{00269\ \textcolor{preprocessor}{\ \#if\ \_\_has\_feature(thread\_sanitizer)\ ||\ defined(\_\_SANITIZE\_THREAD\_\_)}}
\DoxyCodeLine{00270\ \textcolor{preprocessor}{\ \ \#undef\ MOODYCAMEL\_NO\_TSAN}}
\DoxyCodeLine{00271\ \textcolor{preprocessor}{\ \ \#define\ MOODYCAMEL\_NO\_TSAN\ \_\_attribute\_\_((no\_sanitize("{}thread"{})))}}
\DoxyCodeLine{00272\ \textcolor{preprocessor}{\ \#endif\ }\textcolor{comment}{//\ TSAN}}
\DoxyCodeLine{00273\ \textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ TSAN}}
\DoxyCodeLine{00274\ }
\DoxyCodeLine{00275\ \textcolor{comment}{//\ Compiler-\/specific\ likely/unlikely\ hints}}
\DoxyCodeLine{00276\ \textcolor{keyword}{namespace\ }moodycamel\ \{\ \textcolor{keyword}{namespace\ }details\ \{}
\DoxyCodeLine{00277\ \textcolor{preprocessor}{\#if\ defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{00278\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ bool\ (likely)(\textcolor{keywordtype}{bool}\ x)\ \{\ \textcolor{keywordflow}{return}\ \_\_builtin\_expect((x),\ \textcolor{keyword}{true});\ \}}
\DoxyCodeLine{00279\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ bool\ (unlikely)(\textcolor{keywordtype}{bool}\ x)\ \{\ \textcolor{keywordflow}{return}\ \_\_builtin\_expect((x),\ \textcolor{keyword}{false});\ \}}
\DoxyCodeLine{00280\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00281\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ bool\ (likely)(\textcolor{keywordtype}{bool}\ x)\ \{\ \textcolor{keywordflow}{return}\ x;\ \}}
\DoxyCodeLine{00282\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ bool\ (unlikely)(\textcolor{keywordtype}{bool}\ x)\ \{\ \textcolor{keywordflow}{return}\ x;\ \}}
\DoxyCodeLine{00283\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00284\ \}\ \}}
\DoxyCodeLine{00285\ }
\DoxyCodeLine{00286\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_QUEUE\_INTERNAL\_DEBUG}}
\DoxyCodeLine{00287\ \textcolor{preprocessor}{\#include\ "{}internal/concurrentqueue\_internal\_debug.h"{}}}
\DoxyCodeLine{00288\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00289\ }
\DoxyCodeLine{00290\ \textcolor{keyword}{namespace\ }moodycamel\ \{}
\DoxyCodeLine{00291\ \textcolor{keyword}{namespace\ }details\ \{}
\DoxyCodeLine{00292\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00293\ \ \ \ \ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1const__numeric__max}{const\_numeric\_max}}\ \{}
\DoxyCodeLine{00294\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(std::is\_integral<T>::value,\ \textcolor{stringliteral}{"{}const\_numeric\_max\ can\ only\ be\ used\ with\ integers"{}});}
\DoxyCodeLine{00295\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ T\ value\ =\ std::numeric\_limits<T>::is\_signed}
\DoxyCodeLine{00296\ \ \ \ \ \ \ \ \ \ \ \ \ ?\ (\textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(1)\ <<\ (\textcolor{keyword}{sizeof}(T)\ *\ CHAR\_BIT\ -\/\ 1))\ -\/\ \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(1)}
\DoxyCodeLine{00297\ \ \ \ \ \ \ \ \ \ \ \ \ :\ \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{00298\ \ \ \ \ \};}
\DoxyCodeLine{00299\ }
\DoxyCodeLine{00300\ \textcolor{preprocessor}{\#if\ defined(\_\_GLIBCXX\_\_)}}
\DoxyCodeLine{00301\ \ \ \ \ \textcolor{keyword}{typedef}\ ::max\_align\_t\ std\_max\_align\_t;\ \ \ \ \ \ \textcolor{comment}{//\ libstdc++\ forgot\ to\ add\ it\ to\ std::\ for\ a\ while}}
\DoxyCodeLine{00302\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00303\ \ \ \ \ \textcolor{keyword}{typedef}\ std::max\_align\_t\ std\_max\_align\_t;\ \ \ \textcolor{comment}{//\ Others\ (e.g.\ MSVC)\ insist\ it\ can\ *only*\ be\ accessed\ via\ std::}}
\DoxyCodeLine{00304\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00305\ }
\DoxyCodeLine{00306\ \ \ \ \ \textcolor{comment}{//\ Some\ platforms\ have\ incorrectly\ set\ max\_align\_t\ to\ a\ type\ with\ <8\ bytes\ alignment\ even\ while\ supporting}}
\DoxyCodeLine{00307\ \ \ \ \ \textcolor{comment}{//\ 8-\/byte\ aligned\ scalar\ values\ (*cough*\ 32-\/bit\ iOS).\ Work\ around\ this\ with\ our\ own\ union.\ See\ issue\ \#64.}}
\DoxyCodeLine{00308\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{union\ }\{}
\DoxyCodeLine{00309\ \ \ \ \ \ \ \ \ std\_max\_align\_t\ x;}
\DoxyCodeLine{00310\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\ y;}
\DoxyCodeLine{00311\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}*\ z;}
\DoxyCodeLine{00312\ \ \ \ \ \}\ \mbox{\hyperlink{unionmoodycamel_1_1details_1_1max__align__t}{max\_align\_t}};}
\DoxyCodeLine{00313\ \}}
\DoxyCodeLine{00314\ }
\DoxyCodeLine{00315\ \textcolor{comment}{//\ Default\ traits\ for\ the\ ConcurrentQueue.\ To\ change\ some\ of\ the}}
\DoxyCodeLine{00316\ \textcolor{comment}{//\ traits\ without\ re-\/implementing\ all\ of\ them,\ inherit\ from\ this}}
\DoxyCodeLine{00317\ \textcolor{comment}{//\ struct\ and\ shadow\ the\ declarations\ you\ wish\ to\ be\ different;}}
\DoxyCodeLine{00318\ \textcolor{comment}{//\ since\ the\ traits\ are\ used\ as\ a\ template\ type\ parameter,\ the}}
\DoxyCodeLine{00319\ \textcolor{comment}{//\ shadowed\ declarations\ will\ be\ used\ where\ defined,\ and\ the\ defaults}}
\DoxyCodeLine{00320\ \textcolor{comment}{//\ otherwise.}}
\DoxyCodeLine{00321\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1ConcurrentQueueDefaultTraits}{ConcurrentQueueDefaultTraits}}}
\DoxyCodeLine{00322\ \{}
\DoxyCodeLine{00323\ \ \ \ \ \textcolor{comment}{//\ General-\/purpose\ size\ type.\ std::size\_t\ is\ strongly\ recommended.}}
\DoxyCodeLine{00324\ \ \ \ \ \textcolor{keyword}{typedef}\ std::size\_t\ size\_t;}
\DoxyCodeLine{00325\ }
\DoxyCodeLine{00326\ \ \ \ \ \textcolor{comment}{//\ The\ type\ used\ for\ the\ enqueue\ and\ dequeue\ indices.\ Must\ be\ at\ least\ as}}
\DoxyCodeLine{00327\ \ \ \ \ \textcolor{comment}{//\ large\ as\ size\_t.\ Should\ be\ significantly\ larger\ than\ the\ number\ of\ elements}}
\DoxyCodeLine{00328\ \ \ \ \ \textcolor{comment}{//\ you\ expect\ to\ hold\ at\ once,\ especially\ if\ you\ have\ a\ high\ turnover\ rate;}}
\DoxyCodeLine{00329\ \ \ \ \ \textcolor{comment}{//\ for\ example,\ on\ 32-\/bit\ x86,\ if\ you\ expect\ to\ have\ over\ a\ hundred\ million}}
\DoxyCodeLine{00330\ \ \ \ \ \textcolor{comment}{//\ elements\ or\ pump\ several\ million\ elements\ through\ your\ queue\ in\ a\ very}}
\DoxyCodeLine{00331\ \ \ \ \ \textcolor{comment}{//\ short\ space\ of\ time,\ using\ a\ 32-\/bit\ type\ *may*\ trigger\ a\ race\ condition.}}
\DoxyCodeLine{00332\ \ \ \ \ \textcolor{comment}{//\ A\ 64-\/bit\ int\ type\ is\ recommended\ in\ that\ case,\ and\ in\ practice\ will}}
\DoxyCodeLine{00333\ \ \ \ \ \textcolor{comment}{//\ prevent\ a\ race\ condition\ no\ matter\ the\ usage\ of\ the\ queue.\ Note\ that}}
\DoxyCodeLine{00334\ \ \ \ \ \textcolor{comment}{//\ whether\ the\ queue\ is\ lock-\/free\ with\ a\ 64-\/int\ type\ depends\ on\ the\ whether}}
\DoxyCodeLine{00335\ \ \ \ \ \textcolor{comment}{//\ std::atomic<std::uint64\_t>\ is\ lock-\/free,\ which\ is\ platform-\/specific.}}
\DoxyCodeLine{00336\ \ \ \ \ \textcolor{keyword}{typedef}\ std::size\_t\ index\_t;}
\DoxyCodeLine{00337\ }
\DoxyCodeLine{00338\ \ \ \ \ \textcolor{comment}{//\ Internally,\ all\ elements\ are\ enqueued\ and\ dequeued\ from\ multi-\/element}}
\DoxyCodeLine{00339\ \ \ \ \ \textcolor{comment}{//\ blocks;\ this\ is\ the\ smallest\ controllable\ unit.\ If\ you\ expect\ few\ elements}}
\DoxyCodeLine{00340\ \ \ \ \ \textcolor{comment}{//\ but\ many\ producers,\ a\ smaller\ block\ size\ should\ be\ favoured.\ For\ few\ producers}}
\DoxyCodeLine{00341\ \ \ \ \ \textcolor{comment}{//\ and/or\ many\ elements,\ a\ larger\ block\ size\ is\ preferred.\ A\ sane\ default}}
\DoxyCodeLine{00342\ \ \ \ \ \textcolor{comment}{//\ is\ provided.\ Must\ be\ a\ power\ of\ 2.}}
\DoxyCodeLine{00343\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ BLOCK\_SIZE\ =\ 32;}
\DoxyCodeLine{00344\ }
\DoxyCodeLine{00345\ \ \ \ \ \textcolor{comment}{//\ For\ explicit\ producers\ (i.e.\ when\ using\ a\ producer\ token),\ the\ block\ is}}
\DoxyCodeLine{00346\ \ \ \ \ \textcolor{comment}{//\ checked\ for\ being\ empty\ by\ iterating\ through\ a\ list\ of\ flags,\ one\ per\ element.}}
\DoxyCodeLine{00347\ \ \ \ \ \textcolor{comment}{//\ For\ large\ block\ sizes,\ this\ is\ too\ inefficient,\ and\ switching\ to\ an\ atomic}}
\DoxyCodeLine{00348\ \ \ \ \ \textcolor{comment}{//\ counter-\/based\ approach\ is\ faster.\ The\ switch\ is\ made\ for\ block\ sizes\ strictly}}
\DoxyCodeLine{00349\ \ \ \ \ \textcolor{comment}{//\ larger\ than\ this\ threshold.}}
\DoxyCodeLine{00350\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD\ =\ 32;}
\DoxyCodeLine{00351\ }
\DoxyCodeLine{00352\ \ \ \ \ \textcolor{comment}{//\ How\ many\ full\ blocks\ can\ be\ expected\ for\ a\ single\ explicit\ producer?\ This\ should}}
\DoxyCodeLine{00353\ \ \ \ \ \textcolor{comment}{//\ reflect\ that\ number's\ maximum\ for\ optimal\ performance.\ Must\ be\ a\ power\ of\ 2.}}
\DoxyCodeLine{00354\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ EXPLICIT\_INITIAL\_INDEX\_SIZE\ =\ 32;}
\DoxyCodeLine{00355\ }
\DoxyCodeLine{00356\ \ \ \ \ \textcolor{comment}{//\ How\ many\ full\ blocks\ can\ be\ expected\ for\ a\ single\ implicit\ producer?\ This\ should}}
\DoxyCodeLine{00357\ \ \ \ \ \textcolor{comment}{//\ reflect\ that\ number's\ maximum\ for\ optimal\ performance.\ Must\ be\ a\ power\ of\ 2.}}
\DoxyCodeLine{00358\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ IMPLICIT\_INITIAL\_INDEX\_SIZE\ =\ 32;}
\DoxyCodeLine{00359\ }
\DoxyCodeLine{00360\ \ \ \ \ \textcolor{comment}{//\ The\ initial\ size\ of\ the\ hash\ table\ mapping\ thread\ IDs\ to\ implicit\ producers.}}
\DoxyCodeLine{00361\ \ \ \ \ \textcolor{comment}{//\ Note\ that\ the\ hash\ is\ resized\ every\ time\ it\ becomes\ half\ full.}}
\DoxyCodeLine{00362\ \ \ \ \ \textcolor{comment}{//\ Must\ be\ a\ power\ of\ two,\ and\ either\ 0\ or\ at\ least\ 1.\ If\ 0,\ implicit\ production}}
\DoxyCodeLine{00363\ \ \ \ \ \textcolor{comment}{//\ (using\ the\ enqueue\ methods\ without\ an\ explicit\ producer\ token)\ is\ disabled.}}
\DoxyCodeLine{00364\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ =\ 32;}
\DoxyCodeLine{00365\ }
\DoxyCodeLine{00366\ \ \ \ \ \textcolor{comment}{//\ Controls\ the\ number\ of\ items\ that\ an\ explicit\ consumer\ (i.e.\ one\ with\ a\ token)}}
\DoxyCodeLine{00367\ \ \ \ \ \textcolor{comment}{//\ must\ consume\ before\ it\ causes\ all\ consumers\ to\ rotate\ and\ move\ on\ to\ the\ next}}
\DoxyCodeLine{00368\ \ \ \ \ \textcolor{comment}{//\ internal\ queue.}}
\DoxyCodeLine{00369\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ std::uint32\_t\ EXPLICIT\_CONSUMER\_CONSUMPTION\_QUOTA\_BEFORE\_ROTATE\ =\ 256;}
\DoxyCodeLine{00370\ }
\DoxyCodeLine{00371\ \ \ \ \ \textcolor{comment}{//\ The\ maximum\ number\ of\ elements\ (inclusive)\ that\ can\ be\ enqueued\ to\ a\ sub-\/queue.}}
\DoxyCodeLine{00372\ \ \ \ \ \textcolor{comment}{//\ Enqueue\ operations\ that\ would\ cause\ this\ limit\ to\ be\ surpassed\ will\ fail.\ Note}}
\DoxyCodeLine{00373\ \ \ \ \ \textcolor{comment}{//\ that\ this\ limit\ is\ enforced\ at\ the\ block\ level\ (for\ performance\ reasons),\ i.e.}}
\DoxyCodeLine{00374\ \ \ \ \ \textcolor{comment}{//\ it's\ rounded\ up\ to\ the\ nearest\ block\ size.}}
\DoxyCodeLine{00375\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ MAX\_SUBQUEUE\_SIZE\ =\ \mbox{\hyperlink{structmoodycamel_1_1details_1_1const__numeric__max}{details::const\_numeric\_max<size\_t>::value}};}
\DoxyCodeLine{00376\ }
\DoxyCodeLine{00377\ \ \ \ \ \textcolor{comment}{//\ The\ number\ of\ times\ to\ spin\ before\ sleeping\ when\ waiting\ on\ a\ semaphore.}}
\DoxyCodeLine{00378\ \ \ \ \ \textcolor{comment}{//\ Recommended\ values\ are\ on\ the\ order\ of\ 1000-\/10000\ unless\ the\ number\ of}}
\DoxyCodeLine{00379\ \ \ \ \ \textcolor{comment}{//\ consumer\ threads\ exceeds\ the\ number\ of\ idle\ cores\ (in\ which\ case\ try\ 0-\/100).}}
\DoxyCodeLine{00380\ \ \ \ \ \textcolor{comment}{//\ Only\ affects\ instances\ of\ the\ BlockingConcurrentQueue.}}
\DoxyCodeLine{00381\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ MAX\_SEMA\_SPINS\ =\ 10000;}
\DoxyCodeLine{00382\ }
\DoxyCodeLine{00383\ \ \ \ \ \textcolor{comment}{//\ Whether\ to\ recycle\ dynamically-\/allocated\ blocks\ into\ an\ internal\ free\ list\ or}}
\DoxyCodeLine{00384\ \ \ \ \ \textcolor{comment}{//\ not.\ If\ false,\ only\ pre-\/allocated\ blocks\ (controlled\ by\ the\ constructor}}
\DoxyCodeLine{00385\ \ \ \ \ \textcolor{comment}{//\ arguments)\ will\ be\ recycled,\ and\ all\ others\ will\ be\ \`{}free`d\ back\ to\ the\ heap.}}
\DoxyCodeLine{00386\ \ \ \ \ \textcolor{comment}{//\ Note\ that\ blocks\ consumed\ by\ explicit\ producers\ are\ only\ freed\ on\ destruction}}
\DoxyCodeLine{00387\ \ \ \ \ \textcolor{comment}{//\ of\ the\ queue\ (not\ following\ destruction\ of\ the\ token)\ regardless\ of\ this\ trait.}}
\DoxyCodeLine{00388\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ RECYCLE\_ALLOCATED\_BLOCKS\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00389\ }
\DoxyCodeLine{00390\ }
\DoxyCodeLine{00391\ \textcolor{preprocessor}{\#ifndef\ MCDBGQ\_USE\_RELACY}}
\DoxyCodeLine{00392\ \ \ \ \ \textcolor{comment}{//\ Memory\ allocation\ can\ be\ customized\ if\ needed.}}
\DoxyCodeLine{00393\ \ \ \ \ \textcolor{comment}{//\ malloc\ should\ return\ nullptr\ on\ failure,\ and\ handle\ alignment\ like\ std::malloc.}}
\DoxyCodeLine{00394\ \textcolor{preprocessor}{\#if\ defined(malloc)\ ||\ defined(free)}}
\DoxyCodeLine{00395\ \ \ \ \ \textcolor{comment}{//\ Gah,\ this\ is\ 2015,\ stop\ defining\ macros\ that\ break\ standard\ code\ already!}}
\DoxyCodeLine{00396\ \ \ \ \ \textcolor{comment}{//\ Work\ around\ malloc/free\ being\ special\ macros:}}
\DoxyCodeLine{00397\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ WORKAROUND\_malloc(\textcolor{keywordtype}{size\_t}\ size)\ \{\ \textcolor{keywordflow}{return}\ malloc(size);\ \}}
\DoxyCodeLine{00398\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ WORKAROUND\_free(\textcolor{keywordtype}{void}*\ ptr)\ \{\ \textcolor{keywordflow}{return}\ free(ptr);\ \}}
\DoxyCodeLine{00399\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ (malloc)(\textcolor{keywordtype}{size\_t}\ size)\ \{\ \textcolor{keywordflow}{return}\ WORKAROUND\_malloc(size);\ \}}
\DoxyCodeLine{00400\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ void\ (free)(\textcolor{keywordtype}{void}*\ ptr)\ \{\ \textcolor{keywordflow}{return}\ WORKAROUND\_free(ptr);\ \}}
\DoxyCodeLine{00401\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00402\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ malloc(\textcolor{keywordtype}{size\_t}\ size)\ \{\ \textcolor{keywordflow}{return}\ std::malloc(size);\ \}}
\DoxyCodeLine{00403\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ free(\textcolor{keywordtype}{void}*\ ptr)\ \{\ \textcolor{keywordflow}{return}\ std::free(ptr);\ \}}
\DoxyCodeLine{00404\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00405\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00406\ \ \ \ \ \textcolor{comment}{//\ Debug\ versions\ when\ running\ under\ the\ Relacy\ race\ detector\ (ignore}}
\DoxyCodeLine{00407\ \ \ \ \ \textcolor{comment}{//\ these\ in\ user\ code)}}
\DoxyCodeLine{00408\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ malloc(\textcolor{keywordtype}{size\_t}\ size)\ \{\ \textcolor{keywordflow}{return}\ rl::rl\_malloc(size,\ \$);\ \}}
\DoxyCodeLine{00409\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ free(\textcolor{keywordtype}{void}*\ ptr)\ \{\ \textcolor{keywordflow}{return}\ rl::rl\_free(ptr,\ \$);\ \}}
\DoxyCodeLine{00410\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00411\ \};}
\DoxyCodeLine{00412\ }
\DoxyCodeLine{00413\ }
\DoxyCodeLine{00414\ \textcolor{comment}{//\ When\ producing\ or\ consuming\ many\ elements,\ the\ most\ efficient\ way\ is\ to:}}
\DoxyCodeLine{00415\ \textcolor{comment}{//\ \ \ \ 1)\ Use\ one\ of\ the\ bulk-\/operation\ methods\ of\ the\ queue\ with\ a\ token}}
\DoxyCodeLine{00416\ \textcolor{comment}{//\ \ \ \ 2)\ Failing\ that,\ use\ the\ bulk-\/operation\ methods\ without\ a\ token}}
\DoxyCodeLine{00417\ \textcolor{comment}{//\ \ \ \ 3)\ Failing\ that,\ create\ a\ token\ and\ use\ that\ with\ the\ single-\/item\ methods}}
\DoxyCodeLine{00418\ \textcolor{comment}{//\ \ \ \ 4)\ Failing\ that,\ use\ the\ single-\/parameter\ methods\ of\ the\ queue}}
\DoxyCodeLine{00419\ \textcolor{comment}{//\ Having\ said\ that,\ don't\ create\ tokens\ willy-\/nilly\ -\/-\/\ ideally\ there\ should\ be}}
\DoxyCodeLine{00420\ \textcolor{comment}{//\ a\ maximum\ of\ one\ token\ per\ thread\ (of\ each\ kind).}}
\DoxyCodeLine{00421\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}};}
\DoxyCodeLine{00422\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}};}
\DoxyCodeLine{00423\ }
\DoxyCodeLine{00424\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}};}
\DoxyCodeLine{00425\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classmoodycamel_1_1BlockingConcurrentQueue}{BlockingConcurrentQueue}};}
\DoxyCodeLine{00426\ \textcolor{keyword}{class\ }ConcurrentQueueTests;}
\DoxyCodeLine{00427\ }
\DoxyCodeLine{00428\ }
\DoxyCodeLine{00429\ \textcolor{keyword}{namespace\ }details}
\DoxyCodeLine{00430\ \{}
\DoxyCodeLine{00431\ \ \ \ \ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1ConcurrentQueueProducerTypelessBase}{ConcurrentQueueProducerTypelessBase}}}
\DoxyCodeLine{00432\ \ \ \ \ \{}
\DoxyCodeLine{00433\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1ConcurrentQueueProducerTypelessBase}{ConcurrentQueueProducerTypelessBase}}*\ next;}
\DoxyCodeLine{00434\ \ \ \ \ \ \ \ \ std::atomic<bool>\ inactive;}
\DoxyCodeLine{00435\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}*\ token;}
\DoxyCodeLine{00436\ }
\DoxyCodeLine{00437\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1ConcurrentQueueProducerTypelessBase}{ConcurrentQueueProducerTypelessBase}}()}
\DoxyCodeLine{00438\ \ \ \ \ \ \ \ \ \ \ \ \ :\ next(\textcolor{keyword}{nullptr}),\ inactive(\textcolor{keyword}{false}),\ token(\textcolor{keyword}{nullptr})}
\DoxyCodeLine{00439\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00440\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00441\ \ \ \ \ \};}
\DoxyCodeLine{00442\ }
\DoxyCodeLine{00443\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keywordtype}{bool}\ use32>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1__hash__32__or__64}{\_hash\_32\_or\_64}}\ \{}
\DoxyCodeLine{00444\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ std::uint32\_t\ hash(std::uint32\_t\ h)}
\DoxyCodeLine{00445\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00446\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ MurmurHash3\ finalizer\ -\/-\/\ see\ https://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp}}
\DoxyCodeLine{00447\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Since\ the\ thread\ ID\ is\ already\ unique,\ all\ we\ really\ want\ to\ do\ is\ propagate\ that}}
\DoxyCodeLine{00448\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ uniqueness\ evenly\ across\ all\ the\ bits,\ so\ that\ we\ can\ use\ a\ subset\ of\ the\ bits\ while}}
\DoxyCodeLine{00449\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ reducing\ collisions\ significantly}}
\DoxyCodeLine{00450\ \ \ \ \ \ \ \ \ \ \ \ \ h\ \string^=\ h\ >>\ 16;}
\DoxyCodeLine{00451\ \ \ \ \ \ \ \ \ \ \ \ \ h\ *=\ 0x85ebca6b;}
\DoxyCodeLine{00452\ \ \ \ \ \ \ \ \ \ \ \ \ h\ \string^=\ h\ >>\ 13;}
\DoxyCodeLine{00453\ \ \ \ \ \ \ \ \ \ \ \ \ h\ *=\ 0xc2b2ae35;}
\DoxyCodeLine{00454\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ h\ \string^\ (h\ >>\ 16);}
\DoxyCodeLine{00455\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00456\ \ \ \ \ \};}
\DoxyCodeLine{00457\ \ \ \ \ \textcolor{keyword}{template}<>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1__hash__32__or__64}{\_hash\_32\_or\_64}}<1>\ \{}
\DoxyCodeLine{00458\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ std::uint64\_t\ hash(std::uint64\_t\ h)}
\DoxyCodeLine{00459\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00460\ \ \ \ \ \ \ \ \ \ \ \ \ h\ \string^=\ h\ >>\ 33;}
\DoxyCodeLine{00461\ \ \ \ \ \ \ \ \ \ \ \ \ h\ *=\ 0xff51afd7ed558ccd;}
\DoxyCodeLine{00462\ \ \ \ \ \ \ \ \ \ \ \ \ h\ \string^=\ h\ >>\ 33;}
\DoxyCodeLine{00463\ \ \ \ \ \ \ \ \ \ \ \ \ h\ *=\ 0xc4ceb9fe1a85ec53;}
\DoxyCodeLine{00464\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ h\ \string^\ (h\ >>\ 33);}
\DoxyCodeLine{00465\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00466\ \ \ \ \ \};}
\DoxyCodeLine{00467\ \ \ \ \ \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t}\ size>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1hash__32__or__64}{hash\_32\_or\_64}}\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{structmoodycamel_1_1details_1_1__hash__32__or__64}{\_hash\_32\_or\_64}}<(size\ >\ 4)>\ \{\ \ \};}
\DoxyCodeLine{00468\ }
\DoxyCodeLine{00469\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{size\_t}\ hash\_thread\_id(thread\_id\_t\ \textcolor{keywordtype}{id})}
\DoxyCodeLine{00470\ \ \ \ \ \{}
\DoxyCodeLine{00471\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(thread\_id\_t)\ <=\ 8,\ \textcolor{stringliteral}{"{}Expected\ a\ platform\ where\ thread\ IDs\ are\ at\ most\ 64-\/bit\ values"{}});}
\DoxyCodeLine{00472\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(\mbox{\hyperlink{structmoodycamel_1_1details_1_1hash__32__or__64}{hash\_32\_or\_64}}<\textcolor{keyword}{sizeof}(thread\_id\_converter<thread\_id\_t>::thread\_id\_hash\_t)>::hash(}
\DoxyCodeLine{00473\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1thread__id__converter}{thread\_id\_converter<thread\_id\_t>::prehash}}(\textcolor{keywordtype}{id})));}
\DoxyCodeLine{00474\ \ \ \ \ \}}
\DoxyCodeLine{00475\ }
\DoxyCodeLine{00476\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00477\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ circular\_less\_than(T\ a,\ T\ b)}
\DoxyCodeLine{00478\ \ \ \ \ \{}
\DoxyCodeLine{00479\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(std::is\_integral<T>::value\ \&\&\ !std::numeric\_limits<T>::is\_signed,\ \textcolor{stringliteral}{"{}circular\_less\_than\ is\ intended\ to\ be\ used\ only\ with\ unsigned\ integer\ types"{}});}
\DoxyCodeLine{00480\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(a\ -\/\ b)\ >\ \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(1)\ <<\ (\textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(\textcolor{keyword}{sizeof}(T)\ *\ CHAR\_BIT\ -\/\ 1)));}
\DoxyCodeLine{00481\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note:\ extra\ parens\ around\ rhs\ of\ operator<<\ is\ MSVC\ bug:\ https://developercommunity2.visualstudio.com/t/C4554-\/triggers-\/when-\/both-\/lhs-\/and-\/rhs-\/is/10034931}}
\DoxyCodeLine{00482\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ silencing\ the\ bug\ requires\ \#pragma\ warning(disable:\ 4554)\ around\ the\ calling\ code\ and\ has\ no\ effect\ when\ done\ here.}}
\DoxyCodeLine{00483\ \ \ \ \ \}}
\DoxyCodeLine{00484\ }
\DoxyCodeLine{00485\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00486\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{char}*\ align\_for(\textcolor{keywordtype}{char}*\ ptr)}
\DoxyCodeLine{00487\ \ \ \ \ \{}
\DoxyCodeLine{00488\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::size\_t\ alignment\ =\ std::alignment\_of<U>::value;}
\DoxyCodeLine{00489\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ptr\ +\ (alignment\ -\/\ (\textcolor{keyword}{reinterpret\_cast<}std::uintptr\_t\textcolor{keyword}{>}(ptr)\ \%\ alignment))\ \%\ alignment;}
\DoxyCodeLine{00490\ \ \ \ \ \}}
\DoxyCodeLine{00491\ }
\DoxyCodeLine{00492\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00493\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ T\ ceil\_to\_pow\_2(T\ x)}
\DoxyCodeLine{00494\ \ \ \ \ \{}
\DoxyCodeLine{00495\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(std::is\_integral<T>::value\ \&\&\ !std::numeric\_limits<T>::is\_signed,\ \textcolor{stringliteral}{"{}ceil\_to\_pow\_2\ is\ intended\ to\ be\ used\ only\ with\ unsigned\ integer\ types"{}});}
\DoxyCodeLine{00496\ }
\DoxyCodeLine{00497\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Adapted\ from\ http://graphics.stanford.edu/\string~seander/bithacks.html\#RoundUpPowerOf2}}
\DoxyCodeLine{00498\ \ \ \ \ \ \ \ \ -\/-\/x;}
\DoxyCodeLine{00499\ \ \ \ \ \ \ \ \ x\ |=\ x\ >>\ 1;}
\DoxyCodeLine{00500\ \ \ \ \ \ \ \ \ x\ |=\ x\ >>\ 2;}
\DoxyCodeLine{00501\ \ \ \ \ \ \ \ \ x\ |=\ x\ >>\ 4;}
\DoxyCodeLine{00502\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (std::size\_t\ i\ =\ 1;\ i\ <\ \textcolor{keyword}{sizeof}(T);\ i\ <<=\ 1)\ \{}
\DoxyCodeLine{00503\ \ \ \ \ \ \ \ \ \ \ \ \ x\ |=\ x\ >>\ (i\ <<\ 3);}
\DoxyCodeLine{00504\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00505\ \ \ \ \ \ \ \ \ ++x;}
\DoxyCodeLine{00506\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ x;}
\DoxyCodeLine{00507\ \ \ \ \ \}}
\DoxyCodeLine{00508\ }
\DoxyCodeLine{00509\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00510\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ swap\_relaxed(std::atomic<T>\&\ left,\ std::atomic<T>\&\ right)}
\DoxyCodeLine{00511\ \ \ \ \ \{}
\DoxyCodeLine{00512\ \ \ \ \ \ \ \ \ T\ temp\ =\ std::move(left.load(std::memory\_order\_relaxed));}
\DoxyCodeLine{00513\ \ \ \ \ \ \ \ \ left.store(std::move(right.load(std::memory\_order\_relaxed)),\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00514\ \ \ \ \ \ \ \ \ right.store(std::move(temp),\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00515\ \ \ \ \ \}}
\DoxyCodeLine{00516\ }
\DoxyCodeLine{00517\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00518\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ T\ \textcolor{keyword}{const}\&\ nomove(T\ \textcolor{keyword}{const}\&\ x)}
\DoxyCodeLine{00519\ \ \ \ \ \{}
\DoxyCodeLine{00520\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ x;}
\DoxyCodeLine{00521\ \ \ \ \ \}}
\DoxyCodeLine{00522\ }
\DoxyCodeLine{00523\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keywordtype}{bool}\ Enable>}
\DoxyCodeLine{00524\ \ \ \ \ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1nomove__if}{nomove\_if}}}
\DoxyCodeLine{00525\ \ \ \ \ \{}
\DoxyCodeLine{00526\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00527\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ T\ \textcolor{keyword}{const}\&\ eval(T\ \textcolor{keyword}{const}\&\ x)}
\DoxyCodeLine{00528\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00529\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ x;}
\DoxyCodeLine{00530\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00531\ \ \ \ \ \};}
\DoxyCodeLine{00532\ }
\DoxyCodeLine{00533\ \ \ \ \ \textcolor{keyword}{template}<>}
\DoxyCodeLine{00534\ \ \ \ \ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1nomove__if}{nomove\_if}}<false>}
\DoxyCodeLine{00535\ \ \ \ \ \{}
\DoxyCodeLine{00536\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00537\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ eval(U\&\&\ x)}
\DoxyCodeLine{00538\ \ \ \ \ \ \ \ \ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(std::forward<U>(x))}
\DoxyCodeLine{00539\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00540\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::forward<U>(x);}
\DoxyCodeLine{00541\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00542\ \ \ \ \ \};}
\DoxyCodeLine{00543\ }
\DoxyCodeLine{00544\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{00545\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ deref\_noexcept(It\&\ it)\ MOODYCAMEL\_NOEXCEPT\ -\/>\ \textcolor{keyword}{decltype}(*it)}
\DoxyCodeLine{00546\ \ \ \ \ \{}
\DoxyCodeLine{00547\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ *it;}
\DoxyCodeLine{00548\ \ \ \ \ \}}
\DoxyCodeLine{00549\ }
\DoxyCodeLine{00550\ \textcolor{preprocessor}{\#if\ defined(\_\_clang\_\_)\ ||\ !defined(\_\_GNUC\_\_)\ ||\ \_\_GNUC\_\_\ >\ 4\ ||\ (\_\_GNUC\_\_\ ==\ 4\ \&\&\ \_\_GNUC\_MINOR\_\_\ >=\ 8)}}
\DoxyCodeLine{00551\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1is__trivially__destructible}{is\_trivially\_destructible}}\ :\ std::is\_trivially\_destructible<T>\ \{\ \};}
\DoxyCodeLine{00552\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00553\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1is__trivially__destructible}{is\_trivially\_destructible}}\ :\ std::has\_trivial\_destructor<T>\ \{\ \};}
\DoxyCodeLine{00554\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00555\ }
\DoxyCodeLine{00556\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED}}
\DoxyCodeLine{00557\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_USE\_RELACY}}
\DoxyCodeLine{00558\ \ \ \ \ \textcolor{keyword}{typedef}\ RelacyThreadExitListener\ ThreadExitListener;}
\DoxyCodeLine{00559\ \ \ \ \ \textcolor{keyword}{typedef}\ RelacyThreadExitNotifier\ ThreadExitNotifier;}
\DoxyCodeLine{00560\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00561\ \ \ \ \ \textcolor{keyword}{class\ }ThreadExitNotifier;}
\DoxyCodeLine{00562\ }
\DoxyCodeLine{00563\ \ \ \ \ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1ThreadExitListener}{ThreadExitListener}}}
\DoxyCodeLine{00564\ \ \ \ \ \{}
\DoxyCodeLine{00565\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typedef}\ void\ (*callback\_t)(\textcolor{keywordtype}{void}*);}
\DoxyCodeLine{00566\ \ \ \ \ \ \ \ \ callback\_t\ callback;}
\DoxyCodeLine{00567\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}*\ userData;}
\DoxyCodeLine{00568\ }
\DoxyCodeLine{00569\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1ThreadExitListener}{ThreadExitListener}}*\ next;\ \ \ \ \ \textcolor{comment}{//\ reserved\ for\ use\ by\ the\ ThreadExitNotifier}}
\DoxyCodeLine{00570\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1details_1_1ThreadExitNotifier}{ThreadExitNotifier}}*\ chain;\ \ \ \ \ \ \ \ \textcolor{comment}{//\ reserved\ for\ use\ by\ the\ ThreadExitNotifier}}
\DoxyCodeLine{00571\ \ \ \ \ \};}
\DoxyCodeLine{00572\ }
\DoxyCodeLine{00573\ \ \ \ \ \textcolor{keyword}{class\ }\mbox{\hyperlink{classmoodycamel_1_1details_1_1ThreadExitNotifier}{ThreadExitNotifier}}}
\DoxyCodeLine{00574\ \ \ \ \ \{}
\DoxyCodeLine{00575\ \ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00576\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ subscribe(\mbox{\hyperlink{structmoodycamel_1_1details_1_1ThreadExitListener}{ThreadExitListener}}*\ listener)}
\DoxyCodeLine{00577\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00578\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ tlsInst\ =\ instance();}
\DoxyCodeLine{00579\ \ \ \ \ \ \ \ \ \ \ \ \ std::lock\_guard<std::mutex>\ guard(mutex());}
\DoxyCodeLine{00580\ \ \ \ \ \ \ \ \ \ \ \ \ listener-\/>next\ =\ tlsInst.tail;}
\DoxyCodeLine{00581\ \ \ \ \ \ \ \ \ \ \ \ \ listener-\/>chain\ =\ \&tlsInst;}
\DoxyCodeLine{00582\ \ \ \ \ \ \ \ \ \ \ \ \ tlsInst.tail\ =\ listener;}
\DoxyCodeLine{00583\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00584\ }
\DoxyCodeLine{00585\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ unsubscribe(\mbox{\hyperlink{structmoodycamel_1_1details_1_1ThreadExitListener}{ThreadExitListener}}*\ listener)}
\DoxyCodeLine{00586\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00587\ \ \ \ \ \ \ \ \ \ \ \ \ std::lock\_guard<std::mutex>\ guard(mutex());}
\DoxyCodeLine{00588\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>chain)\ \{}
\DoxyCodeLine{00589\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};\ \ \textcolor{comment}{//\ race\ with\ \string~ThreadExitNotifier}}
\DoxyCodeLine{00590\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00591\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ tlsInst\ =\ *listener-\/>chain;}
\DoxyCodeLine{00592\ \ \ \ \ \ \ \ \ \ \ \ \ listener-\/>chain\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00593\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1ThreadExitListener}{ThreadExitListener}}**\ prev\ =\ \&tlsInst.tail;}
\DoxyCodeLine{00594\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ ptr\ =\ tlsInst.tail;\ ptr\ !=\ \textcolor{keyword}{nullptr};\ ptr\ =\ ptr-\/>next)\ \{}
\DoxyCodeLine{00595\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr\ ==\ listener)\ \{}
\DoxyCodeLine{00596\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *prev\ =\ ptr-\/>next;}
\DoxyCodeLine{00597\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00598\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00599\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ prev\ =\ \&ptr-\/>next;}
\DoxyCodeLine{00600\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00601\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00602\ }
\DoxyCodeLine{00603\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00604\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1details_1_1ThreadExitNotifier}{ThreadExitNotifier}}()\ :\ tail(\textcolor{keyword}{nullptr})\ \{\ \}}
\DoxyCodeLine{00605\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1details_1_1ThreadExitNotifier}{ThreadExitNotifier}}(\mbox{\hyperlink{classmoodycamel_1_1details_1_1ThreadExitNotifier}{ThreadExitNotifier}}\ \textcolor{keyword}{const}\&)\ MOODYCAMEL\_DELETE\_FUNCTION;}
\DoxyCodeLine{00606\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1details_1_1ThreadExitNotifier}{ThreadExitNotifier}}\&\ operator=(\mbox{\hyperlink{classmoodycamel_1_1details_1_1ThreadExitNotifier}{ThreadExitNotifier}}\ \textcolor{keyword}{const}\&)\ MOODYCAMEL\_DELETE\_FUNCTION;}
\DoxyCodeLine{00607\ }
\DoxyCodeLine{00608\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1details_1_1ThreadExitNotifier}{\string~ThreadExitNotifier}}()}
\DoxyCodeLine{00609\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00610\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ This\ thread\ is\ about\ to\ exit,\ let\ everyone\ know!}}
\DoxyCodeLine{00611\ \ \ \ \ \ \ \ \ \ \ \ \ assert(\textcolor{keyword}{this}\ ==\ \&instance()\ \&\&\ \textcolor{stringliteral}{"{}If\ this\ assert\ fails,\ you\ likely\ have\ a\ buggy\ compiler!\ Change\ the\ preprocessor\ conditions\ such\ that\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED\ is\ no\ longer\ defined."{}});}
\DoxyCodeLine{00612\ \ \ \ \ \ \ \ \ \ \ \ \ std::lock\_guard<std::mutex>\ guard(mutex());}
\DoxyCodeLine{00613\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ ptr\ =\ tail;\ ptr\ !=\ \textcolor{keyword}{nullptr};\ ptr\ =\ ptr-\/>next)\ \{}
\DoxyCodeLine{00614\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ptr-\/>chain\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00615\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ptr-\/>callback(ptr-\/>userData);}
\DoxyCodeLine{00616\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00617\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00618\ }
\DoxyCodeLine{00619\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Thread-\/local}}
\DoxyCodeLine{00620\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \mbox{\hyperlink{classmoodycamel_1_1details_1_1ThreadExitNotifier}{ThreadExitNotifier}}\&\ instance()}
\DoxyCodeLine{00621\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00622\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{thread\_local}\ \mbox{\hyperlink{classmoodycamel_1_1details_1_1ThreadExitNotifier}{ThreadExitNotifier}}\ notifier;}
\DoxyCodeLine{00623\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ notifier;}
\DoxyCodeLine{00624\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00625\ }
\DoxyCodeLine{00626\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ std::mutex\&\ mutex()}
\DoxyCodeLine{00627\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00628\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Must\ be\ static\ because\ the\ ThreadExitNotifier\ could\ be\ destroyed\ while\ unsubscribe\ is\ called}}
\DoxyCodeLine{00629\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ std::mutex\ mutex;}
\DoxyCodeLine{00630\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ mutex;}
\DoxyCodeLine{00631\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00632\ }
\DoxyCodeLine{00633\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00634\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1ThreadExitListener}{ThreadExitListener}}*\ tail;}
\DoxyCodeLine{00635\ \ \ \ \ \};}
\DoxyCodeLine{00636\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00637\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00638\ }
\DoxyCodeLine{00639\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free__num}{static\_is\_lock\_free\_num}}\ \{\ \textcolor{keyword}{enum}\ \{\ value\ =\ 0\ \};\ \};}
\DoxyCodeLine{00640\ \ \ \ \ \textcolor{keyword}{template}<>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free__num}{static\_is\_lock\_free\_num}}<signed\ char>\ \{\ \textcolor{keyword}{enum}\ \{\ value\ =\ ATOMIC\_CHAR\_LOCK\_FREE\ \};\ \};}
\DoxyCodeLine{00641\ \ \ \ \ \textcolor{keyword}{template}<>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free__num}{static\_is\_lock\_free\_num}}<short>\ \{\ \textcolor{keyword}{enum}\ \{\ value\ =\ ATOMIC\_SHORT\_LOCK\_FREE\ \};\ \};}
\DoxyCodeLine{00642\ \ \ \ \ \textcolor{keyword}{template}<>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free__num}{static\_is\_lock\_free\_num}}<int>\ \{\ \textcolor{keyword}{enum}\ \{\ value\ =\ ATOMIC\_INT\_LOCK\_FREE\ \};\ \};}
\DoxyCodeLine{00643\ \ \ \ \ \textcolor{keyword}{template}<>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free__num}{static\_is\_lock\_free\_num}}<long>\ \{\ \textcolor{keyword}{enum}\ \{\ value\ =\ ATOMIC\_LONG\_LOCK\_FREE\ \};\ \};}
\DoxyCodeLine{00644\ \ \ \ \ \textcolor{keyword}{template}<>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free__num}{static\_is\_lock\_free\_num}}<long\ long>\ \{\ \textcolor{keyword}{enum}\ \{\ value\ =\ ATOMIC\_LLONG\_LOCK\_FREE\ \};\ \};}
\DoxyCodeLine{00645\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free}{static\_is\_lock\_free}}\ :\ \mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free__num}{static\_is\_lock\_free\_num}}<typename\ std::make\_signed<T>::type>\ \{\ \ \};}
\DoxyCodeLine{00646\ \ \ \ \ \textcolor{keyword}{template}<>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free}{static\_is\_lock\_free}}<bool>\ \{\ \textcolor{keyword}{enum}\ \{\ value\ =\ ATOMIC\_BOOL\_LOCK\_FREE\ \};\ \};}
\DoxyCodeLine{00647\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free}{static\_is\_lock\_free}}<U*>\ \{\ \textcolor{keyword}{enum}\ \{\ value\ =\ ATOMIC\_POINTER\_LOCK\_FREE\ \};\ \};}
\DoxyCodeLine{00648\ \}}
\DoxyCodeLine{00649\ }
\DoxyCodeLine{00650\ }
\DoxyCodeLine{00651\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}}
\DoxyCodeLine{00652\ \{}
\DoxyCodeLine{00653\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{00654\ \ \ \ \ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue<T,\ Traits>}}\&\ queue);}
\DoxyCodeLine{00655\ }
\DoxyCodeLine{00656\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{00657\ \ \ \ \ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}(\mbox{\hyperlink{classmoodycamel_1_1BlockingConcurrentQueue}{BlockingConcurrentQueue<T,\ Traits>}}\&\ queue);}
\DoxyCodeLine{00658\ }
\DoxyCodeLine{00659\ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}\&\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{00660\ \ \ \ \ \ \ \ \ :\ producer(other.producer)}
\DoxyCodeLine{00661\ \ \ \ \ \{}
\DoxyCodeLine{00662\ \ \ \ \ \ \ \ \ other.producer\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00663\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (producer\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00664\ \ \ \ \ \ \ \ \ \ \ \ \ producer-\/>token\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{00665\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00666\ \ \ \ \ \}}
\DoxyCodeLine{00667\ }
\DoxyCodeLine{00668\ \ \ \ \ \textcolor{keyword}{inline}\ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}\&\ operator=(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}\&\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{00669\ \ \ \ \ \{}
\DoxyCodeLine{00670\ \ \ \ \ \ \ \ \ swap(other);}
\DoxyCodeLine{00671\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{00672\ \ \ \ \ \}}
\DoxyCodeLine{00673\ }
\DoxyCodeLine{00674\ \ \ \ \ \textcolor{keywordtype}{void}\ swap(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{00675\ \ \ \ \ \{}
\DoxyCodeLine{00676\ \ \ \ \ \ \ \ \ std::swap(producer,\ other.producer);}
\DoxyCodeLine{00677\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (producer\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00678\ \ \ \ \ \ \ \ \ \ \ \ \ producer-\/>token\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{00679\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00680\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (other.producer\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00681\ \ \ \ \ \ \ \ \ \ \ \ \ other.producer-\/>token\ =\ \&other;}
\DoxyCodeLine{00682\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00683\ \ \ \ \ \}}
\DoxyCodeLine{00684\ }
\DoxyCodeLine{00685\ \ \ \ \ \textcolor{comment}{//\ A\ token\ is\ always\ valid\ unless:}}
\DoxyCodeLine{00686\ \ \ \ \ \textcolor{comment}{//\ \ \ \ \ 1)\ Memory\ allocation\ failed\ during\ construction}}
\DoxyCodeLine{00687\ \ \ \ \ \textcolor{comment}{//\ \ \ \ \ 2)\ It\ was\ moved\ via\ the\ move\ constructor}}
\DoxyCodeLine{00688\ \ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ (Note:\ assignment\ does\ a\ swap,\ leaving\ both\ potentially\ valid)}}
\DoxyCodeLine{00689\ \ \ \ \ \textcolor{comment}{//\ \ \ \ \ 3)\ The\ associated\ queue\ was\ destroyed}}
\DoxyCodeLine{00690\ \ \ \ \ \textcolor{comment}{//\ Note\ that\ if\ valid()\ returns\ true,\ that\ only\ indicates}}
\DoxyCodeLine{00691\ \ \ \ \ \textcolor{comment}{//\ that\ the\ token\ is\ valid\ for\ use\ with\ a\ specific\ queue,}}
\DoxyCodeLine{00692\ \ \ \ \ \textcolor{comment}{//\ but\ not\ which\ one;\ that's\ up\ to\ the\ user\ to\ track.}}
\DoxyCodeLine{00693\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ valid()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ producer\ !=\ \textcolor{keyword}{nullptr};\ \}}
\DoxyCodeLine{00694\ }
\DoxyCodeLine{00695\ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{\string~ProducerToken}}()}
\DoxyCodeLine{00696\ \ \ \ \ \{}
\DoxyCodeLine{00697\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (producer\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00698\ \ \ \ \ \ \ \ \ \ \ \ \ producer-\/>token\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00699\ \ \ \ \ \ \ \ \ \ \ \ \ producer-\/>inactive.store(\textcolor{keyword}{true},\ std::memory\_order\_release);}
\DoxyCodeLine{00700\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00701\ \ \ \ \ \}}
\DoxyCodeLine{00702\ }
\DoxyCodeLine{00703\ \ \ \ \ \textcolor{comment}{//\ Disable\ copying\ and\ assignment}}
\DoxyCodeLine{00704\ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}\ \textcolor{keyword}{const}\&)\ MOODYCAMEL\_DELETE\_FUNCTION;}
\DoxyCodeLine{00705\ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}\&\ operator=(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}\ \textcolor{keyword}{const}\&)\ MOODYCAMEL\_DELETE\_FUNCTION;}
\DoxyCodeLine{00706\ }
\DoxyCodeLine{00707\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00708\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>\ \textcolor{keyword}{friend}\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}};}
\DoxyCodeLine{00709\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{class\ }ConcurrentQueueTests;}
\DoxyCodeLine{00710\ }
\DoxyCodeLine{00711\ \textcolor{keyword}{protected}:}
\DoxyCodeLine{00712\ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1ConcurrentQueueProducerTypelessBase}{details::ConcurrentQueueProducerTypelessBase}}*\ producer;}
\DoxyCodeLine{00713\ \};}
\DoxyCodeLine{00714\ }
\DoxyCodeLine{00715\ }
\DoxyCodeLine{00716\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}}
\DoxyCodeLine{00717\ \{}
\DoxyCodeLine{00718\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{00719\ \ \ \ \ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue<T,\ Traits>}}\&\ q);}
\DoxyCodeLine{00720\ }
\DoxyCodeLine{00721\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{00722\ \ \ \ \ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}(\mbox{\hyperlink{classmoodycamel_1_1BlockingConcurrentQueue}{BlockingConcurrentQueue<T,\ Traits>}}\&\ q);}
\DoxyCodeLine{00723\ }
\DoxyCodeLine{00724\ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}(\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}\&\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{00725\ \ \ \ \ \ \ \ \ :\ initialOffset(other.initialOffset),\ lastKnownGlobalOffset(other.lastKnownGlobalOffset),\ itemsConsumedFromCurrent(other.itemsConsumedFromCurrent),\ currentProducer(other.currentProducer),\ desiredProducer(other.desiredProducer)}
\DoxyCodeLine{00726\ \ \ \ \ \{}
\DoxyCodeLine{00727\ \ \ \ \ \}}
\DoxyCodeLine{00728\ }
\DoxyCodeLine{00729\ \ \ \ \ \textcolor{keyword}{inline}\ \mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}\&\ operator=(\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}\&\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{00730\ \ \ \ \ \{}
\DoxyCodeLine{00731\ \ \ \ \ \ \ \ \ swap(other);}
\DoxyCodeLine{00732\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{00733\ \ \ \ \ \}}
\DoxyCodeLine{00734\ }
\DoxyCodeLine{00735\ \ \ \ \ \textcolor{keywordtype}{void}\ swap(\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{00736\ \ \ \ \ \{}
\DoxyCodeLine{00737\ \ \ \ \ \ \ \ \ std::swap(initialOffset,\ other.initialOffset);}
\DoxyCodeLine{00738\ \ \ \ \ \ \ \ \ std::swap(lastKnownGlobalOffset,\ other.lastKnownGlobalOffset);}
\DoxyCodeLine{00739\ \ \ \ \ \ \ \ \ std::swap(itemsConsumedFromCurrent,\ other.itemsConsumedFromCurrent);}
\DoxyCodeLine{00740\ \ \ \ \ \ \ \ \ std::swap(currentProducer,\ other.currentProducer);}
\DoxyCodeLine{00741\ \ \ \ \ \ \ \ \ std::swap(desiredProducer,\ other.desiredProducer);}
\DoxyCodeLine{00742\ \ \ \ \ \}}
\DoxyCodeLine{00743\ }
\DoxyCodeLine{00744\ \ \ \ \ \textcolor{comment}{//\ Disable\ copying\ and\ assignment}}
\DoxyCodeLine{00745\ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}(\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}\ \textcolor{keyword}{const}\&)\ MOODYCAMEL\_DELETE\_FUNCTION;}
\DoxyCodeLine{00746\ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}\&\ operator=(\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}\ \textcolor{keyword}{const}\&)\ MOODYCAMEL\_DELETE\_FUNCTION;}
\DoxyCodeLine{00747\ }
\DoxyCodeLine{00748\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00749\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>\ \textcolor{keyword}{friend}\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}};}
\DoxyCodeLine{00750\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{class\ }ConcurrentQueueTests;}
\DoxyCodeLine{00751\ }
\DoxyCodeLine{00752\ \textcolor{keyword}{private}:\ \textcolor{comment}{//\ but\ shared\ with\ ConcurrentQueue}}
\DoxyCodeLine{00753\ \ \ \ \ std::uint32\_t\ initialOffset;}
\DoxyCodeLine{00754\ \ \ \ \ std::uint32\_t\ lastKnownGlobalOffset;}
\DoxyCodeLine{00755\ \ \ \ \ std::uint32\_t\ itemsConsumedFromCurrent;}
\DoxyCodeLine{00756\ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1ConcurrentQueueProducerTypelessBase}{details::ConcurrentQueueProducerTypelessBase}}*\ currentProducer;}
\DoxyCodeLine{00757\ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1ConcurrentQueueProducerTypelessBase}{details::ConcurrentQueueProducerTypelessBase}}*\ desiredProducer;}
\DoxyCodeLine{00758\ \};}
\DoxyCodeLine{00759\ }
\DoxyCodeLine{00760\ \textcolor{comment}{//\ Need\ to\ forward-\/declare\ this\ swap\ because\ it's\ in\ a\ namespace.}}
\DoxyCodeLine{00761\ \textcolor{comment}{//\ See\ http://stackoverflow.com/questions/4492062/why-\/does-\/a-\/c-\/friend-\/class-\/need-\/a-\/forward-\/declaration-\/only-\/in-\/other-\/namespaces}}
\DoxyCodeLine{00762\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{00763\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ swap(\textcolor{keyword}{typename}\ ConcurrentQueue<T,\ Traits>::ImplicitProducerKVP\&\ a,\ \textcolor{keyword}{typename}\ ConcurrentQueue<T,\ Traits>::ImplicitProducerKVP\&\ b)\ MOODYCAMEL\_NOEXCEPT;}
\DoxyCodeLine{00764\ }
\DoxyCodeLine{00765\ }
\DoxyCodeLine{00766\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits\ =\ ConcurrentQueueDefaultTraits>}
\DoxyCodeLine{00767\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}}
\DoxyCodeLine{00768\ \{}
\DoxyCodeLine{00769\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00770\ \ \ \ \ \textcolor{keyword}{typedef}\ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{::moodycamel::ProducerToken}}\ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}};}
\DoxyCodeLine{00771\ \ \ \ \ \textcolor{keyword}{typedef}\ \mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{::moodycamel::ConsumerToken}}\ \mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{consumer\_token\_t}};}
\DoxyCodeLine{00772\ }
\DoxyCodeLine{00773\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ Traits::index\_t\ index\_t;}
\DoxyCodeLine{00774\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ Traits::size\_t\ size\_t;}
\DoxyCodeLine{00775\ }
\DoxyCodeLine{00776\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ BLOCK\_SIZE\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(Traits::BLOCK\_SIZE);}
\DoxyCodeLine{00777\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(Traits::EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD);}
\DoxyCodeLine{00778\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ EXPLICIT\_INITIAL\_INDEX\_SIZE\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(Traits::EXPLICIT\_INITIAL\_INDEX\_SIZE);}
\DoxyCodeLine{00779\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ IMPLICIT\_INITIAL\_INDEX\_SIZE\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(Traits::IMPLICIT\_INITIAL\_INDEX\_SIZE);}
\DoxyCodeLine{00780\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(Traits::INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE);}
\DoxyCodeLine{00781\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ std::uint32\_t\ EXPLICIT\_CONSUMER\_CONSUMPTION\_QUOTA\_BEFORE\_ROTATE\ =\ \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(Traits::EXPLICIT\_CONSUMER\_CONSUMPTION\_QUOTA\_BEFORE\_ROTATE);}
\DoxyCodeLine{00782\ \textcolor{preprocessor}{\#ifdef\ \_MSC\_VER}}
\DoxyCodeLine{00783\ \textcolor{preprocessor}{\#pragma\ warning(push)}}
\DoxyCodeLine{00784\ \textcolor{preprocessor}{\#pragma\ warning(disable:\ 4307)\ \ \ \ \ \ }\textcolor{comment}{//\ +\ integral\ constant\ overflow\ (that's\ what\ the\ ternary\ expression\ is\ for!)}}
\DoxyCodeLine{00785\ \textcolor{preprocessor}{\#pragma\ warning(disable:\ 4309)\ \ \ \ \ \ }\textcolor{comment}{//\ static\_cast:\ Truncation\ of\ constant\ value}}
\DoxyCodeLine{00786\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00787\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ MAX\_SUBQUEUE\_SIZE\ =\ (\mbox{\hyperlink{structmoodycamel_1_1details_1_1const__numeric__max}{details::const\_numeric\_max<size\_t>::value}}\ -\/\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(Traits::MAX\_SUBQUEUE\_SIZE)\ <\ BLOCK\_SIZE)\ ?\ \mbox{\hyperlink{structmoodycamel_1_1details_1_1const__numeric__max}{details::const\_numeric\_max<size\_t>::value}}\ :\ ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(Traits::MAX\_SUBQUEUE\_SIZE)\ +\ (BLOCK\_SIZE\ -\/\ 1))\ /\ BLOCK\_SIZE\ *\ BLOCK\_SIZE);}
\DoxyCodeLine{00788\ \textcolor{preprocessor}{\#ifdef\ \_MSC\_VER}}
\DoxyCodeLine{00789\ \textcolor{preprocessor}{\#pragma\ warning(pop)}}
\DoxyCodeLine{00790\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00791\ }
\DoxyCodeLine{00792\ \ \ \ \ \textcolor{keyword}{static\_assert}(!std::numeric\_limits<size\_t>::is\_signed\ \&\&\ std::is\_integral<size\_t>::value,\ \textcolor{stringliteral}{"{}Traits::size\_t\ must\ be\ an\ unsigned\ integral\ type"{}});}
\DoxyCodeLine{00793\ \ \ \ \ \textcolor{keyword}{static\_assert}(!std::numeric\_limits<index\_t>::is\_signed\ \&\&\ std::is\_integral<index\_t>::value,\ \textcolor{stringliteral}{"{}Traits::index\_t\ must\ be\ an\ unsigned\ integral\ type"{}});}
\DoxyCodeLine{00794\ \ \ \ \ \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(index\_t)\ >=\ \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}),\ \textcolor{stringliteral}{"{}Traits::index\_t\ must\ be\ at\ least\ as\ wide\ as\ Traits::size\_t"{}});}
\DoxyCodeLine{00795\ \ \ \ \ \textcolor{keyword}{static\_assert}((BLOCK\_SIZE\ >\ 1)\ \&\&\ !(BLOCK\_SIZE\ \&\ (BLOCK\_SIZE\ -\/\ 1)),\ \textcolor{stringliteral}{"{}Traits::BLOCK\_SIZE\ must\ be\ a\ power\ of\ 2\ (and\ at\ least\ 2)"{}});}
\DoxyCodeLine{00796\ \ \ \ \ \textcolor{keyword}{static\_assert}((EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD\ >\ 1)\ \&\&\ !(EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD\ \&\ (EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD\ -\/\ 1)),\ \textcolor{stringliteral}{"{}Traits::EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD\ must\ be\ a\ power\ of\ 2\ (and\ greater\ than\ 1)"{}});}
\DoxyCodeLine{00797\ \ \ \ \ \textcolor{keyword}{static\_assert}((EXPLICIT\_INITIAL\_INDEX\_SIZE\ >\ 1)\ \&\&\ !(EXPLICIT\_INITIAL\_INDEX\_SIZE\ \&\ (EXPLICIT\_INITIAL\_INDEX\_SIZE\ -\/\ 1)),\ \textcolor{stringliteral}{"{}Traits::EXPLICIT\_INITIAL\_INDEX\_SIZE\ must\ be\ a\ power\ of\ 2\ (and\ greater\ than\ 1)"{}});}
\DoxyCodeLine{00798\ \ \ \ \ \textcolor{keyword}{static\_assert}((IMPLICIT\_INITIAL\_INDEX\_SIZE\ >\ 1)\ \&\&\ !(IMPLICIT\_INITIAL\_INDEX\_SIZE\ \&\ (IMPLICIT\_INITIAL\_INDEX\_SIZE\ -\/\ 1)),\ \textcolor{stringliteral}{"{}Traits::IMPLICIT\_INITIAL\_INDEX\_SIZE\ must\ be\ a\ power\ of\ 2\ (and\ greater\ than\ 1)"{}});}
\DoxyCodeLine{00799\ \ \ \ \ \textcolor{keyword}{static\_assert}((INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ ==\ 0)\ ||\ !(INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ \&\ (INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ -\/\ 1)),\ \textcolor{stringliteral}{"{}Traits::INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ must\ be\ a\ power\ of\ 2"{}});}
\DoxyCodeLine{00800\ \ \ \ \ \textcolor{keyword}{static\_assert}(INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ ==\ 0\ ||\ INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ >=\ 1,\ \textcolor{stringliteral}{"{}Traits::INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ must\ be\ at\ least\ 1\ (or\ 0\ to\ disable\ implicit\ enqueueing)"{}});}
\DoxyCodeLine{00801\ }
\DoxyCodeLine{00802\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00803\ \ \ \ \ \textcolor{comment}{//\ Creates\ a\ queue\ with\ at\ least\ \`{}capacity`\ element\ slots;\ note\ that\ the}}
\DoxyCodeLine{00804\ \ \ \ \ \textcolor{comment}{//\ actual\ number\ of\ elements\ that\ can\ be\ inserted\ without\ additional\ memory}}
\DoxyCodeLine{00805\ \ \ \ \ \textcolor{comment}{//\ allocation\ depends\ on\ the\ number\ of\ producers\ and\ the\ block\ size\ (e.g.\ if}}
\DoxyCodeLine{00806\ \ \ \ \ \textcolor{comment}{//\ the\ block\ size\ is\ equal\ to\ \`{}capacity`,\ only\ a\ single\ block\ will\ be\ allocated}}
\DoxyCodeLine{00807\ \ \ \ \ \textcolor{comment}{//\ up-\/front,\ which\ means\ only\ a\ single\ producer\ will\ be\ able\ to\ enqueue\ elements}}
\DoxyCodeLine{00808\ \ \ \ \ \textcolor{comment}{//\ without\ an\ extra\ allocation\ -\/-\/\ blocks\ aren't\ shared\ between\ producers).}}
\DoxyCodeLine{00809\ \ \ \ \ \textcolor{comment}{//\ This\ method\ is\ not\ thread\ safe\ -\/-\/\ it\ is\ up\ to\ the\ user\ to\ ensure\ that\ the}}
\DoxyCodeLine{00810\ \ \ \ \ \textcolor{comment}{//\ queue\ is\ fully\ constructed\ before\ it\ starts\ being\ used\ by\ other\ threads\ (this}}
\DoxyCodeLine{00811\ \ \ \ \ \textcolor{comment}{//\ includes\ making\ the\ memory\ effects\ of\ construction\ visible,\ possibly\ with\ a}}
\DoxyCodeLine{00812\ \ \ \ \ \textcolor{comment}{//\ memory\ barrier).}}
\DoxyCodeLine{00813\ \ \ \ \ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}(\textcolor{keywordtype}{size\_t}\ capacity\ =\ 32\ *\ BLOCK\_SIZE)}
\DoxyCodeLine{00814\ \ \ \ \ \ \ \ \ :\ producerListTail(\textcolor{keyword}{nullptr}),}
\DoxyCodeLine{00815\ \ \ \ \ \ \ \ \ producerCount(0),}
\DoxyCodeLine{00816\ \ \ \ \ \ \ \ \ initialBlockPoolIndex(0),}
\DoxyCodeLine{00817\ \ \ \ \ \ \ \ \ nextExplicitConsumerId(0),}
\DoxyCodeLine{00818\ \ \ \ \ \ \ \ \ globalExplicitConsumerOffset(0)}
\DoxyCodeLine{00819\ \ \ \ \ \{}
\DoxyCodeLine{00820\ \ \ \ \ \ \ \ \ implicitProducerHashResizeInProgress.clear(std::memory\_order\_relaxed);}
\DoxyCodeLine{00821\ \ \ \ \ \ \ \ \ populate\_initial\_implicit\_producer\_hash();}
\DoxyCodeLine{00822\ \ \ \ \ \ \ \ \ populate\_initial\_block\_list(capacity\ /\ BLOCK\_SIZE\ +\ ((capacity\ \&\ (BLOCK\_SIZE\ -\/\ 1))\ ==\ 0\ ?\ 0\ :\ 1));}
\DoxyCodeLine{00823\ }
\DoxyCodeLine{00824\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_QUEUE\_INTERNAL\_DEBUG}}
\DoxyCodeLine{00825\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Track\ all\ the\ producers\ using\ a\ fully-\/resolved\ typed\ list\ for}}
\DoxyCodeLine{00826\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ each\ kind;\ this\ makes\ it\ possible\ to\ debug\ them\ starting\ from}}
\DoxyCodeLine{00827\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ root\ queue\ object\ (otherwise\ wacky\ casts\ are\ needed\ that}}
\DoxyCodeLine{00828\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ don't\ compile\ in\ the\ debugger's\ expression\ evaluator).}}
\DoxyCodeLine{00829\ \ \ \ \ \ \ \ \ explicitProducers.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00830\ \ \ \ \ \ \ \ \ implicitProducers.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00831\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00832\ \ \ \ \ \}}
\DoxyCodeLine{00833\ }
\DoxyCodeLine{00834\ \ \ \ \ \textcolor{comment}{//\ Computes\ the\ correct\ amount\ of\ pre-\/allocated\ blocks\ for\ you\ based}}
\DoxyCodeLine{00835\ \ \ \ \ \textcolor{comment}{//\ on\ the\ minimum\ number\ of\ elements\ you\ want\ available\ at\ any\ given}}
\DoxyCodeLine{00836\ \ \ \ \ \textcolor{comment}{//\ time,\ and\ the\ maximum\ concurrent\ number\ of\ each\ type\ of\ producer.}}
\DoxyCodeLine{00837\ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}(\textcolor{keywordtype}{size\_t}\ minCapacity,\ \textcolor{keywordtype}{size\_t}\ maxExplicitProducers,\ \textcolor{keywordtype}{size\_t}\ maxImplicitProducers)}
\DoxyCodeLine{00838\ \ \ \ \ \ \ \ \ :\ producerListTail(\textcolor{keyword}{nullptr}),}
\DoxyCodeLine{00839\ \ \ \ \ \ \ \ \ producerCount(0),}
\DoxyCodeLine{00840\ \ \ \ \ \ \ \ \ initialBlockPoolIndex(0),}
\DoxyCodeLine{00841\ \ \ \ \ \ \ \ \ nextExplicitConsumerId(0),}
\DoxyCodeLine{00842\ \ \ \ \ \ \ \ \ globalExplicitConsumerOffset(0)}
\DoxyCodeLine{00843\ \ \ \ \ \{}
\DoxyCodeLine{00844\ \ \ \ \ \ \ \ \ implicitProducerHashResizeInProgress.clear(std::memory\_order\_relaxed);}
\DoxyCodeLine{00845\ \ \ \ \ \ \ \ \ populate\_initial\_implicit\_producer\_hash();}
\DoxyCodeLine{00846\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ blocks\ =\ (((minCapacity\ +\ BLOCK\_SIZE\ -\/\ 1)\ /\ BLOCK\_SIZE)\ -\/\ 1)\ *\ (maxExplicitProducers\ +\ 1)\ +\ 2\ *\ (maxExplicitProducers\ +\ maxImplicitProducers);}
\DoxyCodeLine{00847\ \ \ \ \ \ \ \ \ populate\_initial\_block\_list(blocks);}
\DoxyCodeLine{00848\ }
\DoxyCodeLine{00849\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_QUEUE\_INTERNAL\_DEBUG}}
\DoxyCodeLine{00850\ \ \ \ \ \ \ \ \ explicitProducers.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00851\ \ \ \ \ \ \ \ \ implicitProducers.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00852\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00853\ \ \ \ \ \}}
\DoxyCodeLine{00854\ }
\DoxyCodeLine{00855\ \ \ \ \ \textcolor{comment}{//\ Note:\ The\ queue\ should\ not\ be\ accessed\ concurrently\ while\ it's}}
\DoxyCodeLine{00856\ \ \ \ \ \textcolor{comment}{//\ being\ deleted.\ It's\ up\ to\ the\ user\ to\ synchronize\ this.}}
\DoxyCodeLine{00857\ \ \ \ \ \textcolor{comment}{//\ This\ method\ is\ not\ thread\ safe.}}
\DoxyCodeLine{00858\ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{\string~ConcurrentQueue}}()}
\DoxyCodeLine{00859\ \ \ \ \ \{}
\DoxyCodeLine{00860\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Destroy\ producers}}
\DoxyCodeLine{00861\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ ptr\ =\ producerListTail.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{00862\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (ptr\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00863\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ next\ =\ ptr-\/>next\_prod();}
\DoxyCodeLine{00864\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr-\/>token\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00865\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ptr-\/>token-\/>producer\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00866\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00867\ \ \ \ \ \ \ \ \ \ \ \ \ destroy(ptr);}
\DoxyCodeLine{00868\ \ \ \ \ \ \ \ \ \ \ \ \ ptr\ =\ next;}
\DoxyCodeLine{00869\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00870\ }
\DoxyCodeLine{00871\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Destroy\ implicit\ producer\ hash\ tables}}
\DoxyCodeLine{00872\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ !=\ 0)\ \{}
\DoxyCodeLine{00873\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ hash\ =\ implicitProducerHash.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{00874\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (hash\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00875\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prev\ =\ hash-\/>prev;}
\DoxyCodeLine{00876\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (prev\ !=\ \textcolor{keyword}{nullptr})\ \{\ \ \ \ \ \ \textcolor{comment}{//\ The\ last\ hash\ is\ part\ of\ this\ object\ and\ was\ not\ allocated\ dynamically}}
\DoxyCodeLine{00877\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ hash-\/>capacity;\ ++i)\ \{}
\DoxyCodeLine{00878\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ hash-\/>entries[i].\string~ImplicitProducerKVP();}
\DoxyCodeLine{00879\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00880\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ hash-\/>\string~ImplicitProducerHash();}
\DoxyCodeLine{00881\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (Traits::free)(hash);}
\DoxyCodeLine{00882\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00883\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ hash\ =\ prev;}
\DoxyCodeLine{00884\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00885\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00886\ }
\DoxyCodeLine{00887\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Destroy\ global\ free\ list}}
\DoxyCodeLine{00888\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ freeList.head\_unsafe();}
\DoxyCodeLine{00889\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (block\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00890\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ next\ =\ block-\/>freeListNext.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{00891\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block-\/>dynamicallyAllocated)\ \{}
\DoxyCodeLine{00892\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ destroy(block);}
\DoxyCodeLine{00893\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00894\ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ next;}
\DoxyCodeLine{00895\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00896\ }
\DoxyCodeLine{00897\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Destroy\ initial\ free\ list}}
\DoxyCodeLine{00898\ \ \ \ \ \ \ \ \ destroy\_array(initialBlockPool,\ initialBlockPoolSize);}
\DoxyCodeLine{00899\ \ \ \ \ \}}
\DoxyCodeLine{00900\ }
\DoxyCodeLine{00901\ \ \ \ \ \textcolor{comment}{//\ Disable\ copying\ and\ copy\ assignment}}
\DoxyCodeLine{00902\ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}\ \textcolor{keyword}{const}\&)\ MOODYCAMEL\_DELETE\_FUNCTION;}
\DoxyCodeLine{00903\ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}\&\ operator=(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}\ \textcolor{keyword}{const}\&)\ MOODYCAMEL\_DELETE\_FUNCTION;}
\DoxyCodeLine{00904\ }
\DoxyCodeLine{00905\ \ \ \ \ \textcolor{comment}{//\ Moving\ is\ supported,\ but\ note\ that\ it\ is\ *not*\ a\ thread-\/safe\ operation.}}
\DoxyCodeLine{00906\ \ \ \ \ \textcolor{comment}{//\ Nobody\ can\ use\ the\ queue\ while\ it's\ being\ moved,\ and\ the\ memory\ effects}}
\DoxyCodeLine{00907\ \ \ \ \ \textcolor{comment}{//\ of\ that\ move\ must\ be\ propagated\ to\ other\ threads\ before\ they\ can\ use\ it.}}
\DoxyCodeLine{00908\ \ \ \ \ \textcolor{comment}{//\ Note:\ When\ a\ queue\ is\ moved,\ its\ tokens\ are\ still\ valid\ but\ can\ only\ be}}
\DoxyCodeLine{00909\ \ \ \ \ \textcolor{comment}{//\ used\ with\ the\ destination\ queue\ (i.e.\ semantically\ they\ are\ moved\ along}}
\DoxyCodeLine{00910\ \ \ \ \ \textcolor{comment}{//\ with\ the\ queue\ itself).}}
\DoxyCodeLine{00911\ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}\&\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{00912\ \ \ \ \ \ \ \ \ :\ producerListTail(other.producerListTail.load(std::memory\_order\_relaxed)),}
\DoxyCodeLine{00913\ \ \ \ \ \ \ \ \ producerCount(other.producerCount.load(std::memory\_order\_relaxed)),}
\DoxyCodeLine{00914\ \ \ \ \ \ \ \ \ initialBlockPoolIndex(other.initialBlockPoolIndex.load(std::memory\_order\_relaxed)),}
\DoxyCodeLine{00915\ \ \ \ \ \ \ \ \ initialBlockPool(other.initialBlockPool),}
\DoxyCodeLine{00916\ \ \ \ \ \ \ \ \ initialBlockPoolSize(other.initialBlockPoolSize),}
\DoxyCodeLine{00917\ \ \ \ \ \ \ \ \ freeList(std::move(other.freeList)),}
\DoxyCodeLine{00918\ \ \ \ \ \ \ \ \ nextExplicitConsumerId(other.nextExplicitConsumerId.load(std::memory\_order\_relaxed)),}
\DoxyCodeLine{00919\ \ \ \ \ \ \ \ \ globalExplicitConsumerOffset(other.globalExplicitConsumerOffset.load(std::memory\_order\_relaxed))}
\DoxyCodeLine{00920\ \ \ \ \ \{}
\DoxyCodeLine{00921\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Move\ the\ other\ one\ into\ this,\ and\ leave\ the\ other\ one\ as\ an\ empty\ queue}}
\DoxyCodeLine{00922\ \ \ \ \ \ \ \ \ implicitProducerHashResizeInProgress.clear(std::memory\_order\_relaxed);}
\DoxyCodeLine{00923\ \ \ \ \ \ \ \ \ populate\_initial\_implicit\_producer\_hash();}
\DoxyCodeLine{00924\ \ \ \ \ \ \ \ \ swap\_implicit\_producer\_hashes(other);}
\DoxyCodeLine{00925\ }
\DoxyCodeLine{00926\ \ \ \ \ \ \ \ \ other.producerListTail.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00927\ \ \ \ \ \ \ \ \ other.producerCount.store(0,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00928\ \ \ \ \ \ \ \ \ other.nextExplicitConsumerId.store(0,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00929\ \ \ \ \ \ \ \ \ other.globalExplicitConsumerOffset.store(0,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00930\ }
\DoxyCodeLine{00931\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_QUEUE\_INTERNAL\_DEBUG}}
\DoxyCodeLine{00932\ \ \ \ \ \ \ \ \ explicitProducers.store(other.explicitProducers.load(std::memory\_order\_relaxed),\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00933\ \ \ \ \ \ \ \ \ other.explicitProducers.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00934\ \ \ \ \ \ \ \ \ implicitProducers.store(other.implicitProducers.load(std::memory\_order\_relaxed),\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00935\ \ \ \ \ \ \ \ \ other.implicitProducers.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00936\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00937\ }
\DoxyCodeLine{00938\ \ \ \ \ \ \ \ \ other.initialBlockPoolIndex.store(0,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00939\ \ \ \ \ \ \ \ \ other.initialBlockPoolSize\ =\ 0;}
\DoxyCodeLine{00940\ \ \ \ \ \ \ \ \ other.initialBlockPool\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00941\ }
\DoxyCodeLine{00942\ \ \ \ \ \ \ \ \ reown\_producers();}
\DoxyCodeLine{00943\ \ \ \ \ \}}
\DoxyCodeLine{00944\ }
\DoxyCodeLine{00945\ \ \ \ \ \textcolor{keyword}{inline}\ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}\&\ operator=(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}\&\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{00946\ \ \ \ \ \{}
\DoxyCodeLine{00947\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ swap\_internal(other);}
\DoxyCodeLine{00948\ \ \ \ \ \}}
\DoxyCodeLine{00949\ }
\DoxyCodeLine{00950\ \ \ \ \ \textcolor{comment}{//\ Swaps\ this\ queue's\ state\ with\ the\ other's.\ Not\ thread-\/safe.}}
\DoxyCodeLine{00951\ \ \ \ \ \textcolor{comment}{//\ Swapping\ two\ queues\ does\ not\ invalidate\ their\ tokens,\ however}}
\DoxyCodeLine{00952\ \ \ \ \ \textcolor{comment}{//\ the\ tokens\ that\ were\ created\ for\ one\ queue\ must\ be\ used\ with}}
\DoxyCodeLine{00953\ \ \ \ \ \textcolor{comment}{//\ only\ the\ swapped\ queue\ (i.e.\ the\ tokens\ are\ tied\ to\ the}}
\DoxyCodeLine{00954\ \ \ \ \ \textcolor{comment}{//\ queue's\ movable\ state,\ not\ the\ object\ itself).}}
\DoxyCodeLine{00955\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ swap(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{00956\ \ \ \ \ \{}
\DoxyCodeLine{00957\ \ \ \ \ \ \ \ \ swap\_internal(other);}
\DoxyCodeLine{00958\ \ \ \ \ \}}
\DoxyCodeLine{00959\ }
\DoxyCodeLine{00960\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00961\ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}\&\ swap\_internal(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}\&\ other)}
\DoxyCodeLine{00962\ \ \ \ \ \{}
\DoxyCodeLine{00963\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{this}\ ==\ \&other)\ \{}
\DoxyCodeLine{00964\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{00965\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00966\ }
\DoxyCodeLine{00967\ \ \ \ \ \ \ \ \ details::swap\_relaxed(producerListTail,\ other.producerListTail);}
\DoxyCodeLine{00968\ \ \ \ \ \ \ \ \ details::swap\_relaxed(producerCount,\ other.producerCount);}
\DoxyCodeLine{00969\ \ \ \ \ \ \ \ \ details::swap\_relaxed(initialBlockPoolIndex,\ other.initialBlockPoolIndex);}
\DoxyCodeLine{00970\ \ \ \ \ \ \ \ \ std::swap(initialBlockPool,\ other.initialBlockPool);}
\DoxyCodeLine{00971\ \ \ \ \ \ \ \ \ std::swap(initialBlockPoolSize,\ other.initialBlockPoolSize);}
\DoxyCodeLine{00972\ \ \ \ \ \ \ \ \ freeList.swap(other.freeList);}
\DoxyCodeLine{00973\ \ \ \ \ \ \ \ \ details::swap\_relaxed(nextExplicitConsumerId,\ other.nextExplicitConsumerId);}
\DoxyCodeLine{00974\ \ \ \ \ \ \ \ \ details::swap\_relaxed(globalExplicitConsumerOffset,\ other.globalExplicitConsumerOffset);}
\DoxyCodeLine{00975\ }
\DoxyCodeLine{00976\ \ \ \ \ \ \ \ \ swap\_implicit\_producer\_hashes(other);}
\DoxyCodeLine{00977\ }
\DoxyCodeLine{00978\ \ \ \ \ \ \ \ \ reown\_producers();}
\DoxyCodeLine{00979\ \ \ \ \ \ \ \ \ other.reown\_producers();}
\DoxyCodeLine{00980\ }
\DoxyCodeLine{00981\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_QUEUE\_INTERNAL\_DEBUG}}
\DoxyCodeLine{00982\ \ \ \ \ \ \ \ \ details::swap\_relaxed(explicitProducers,\ other.explicitProducers);}
\DoxyCodeLine{00983\ \ \ \ \ \ \ \ \ details::swap\_relaxed(implicitProducers,\ other.implicitProducers);}
\DoxyCodeLine{00984\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00985\ }
\DoxyCodeLine{00986\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{00987\ \ \ \ \ \}}
\DoxyCodeLine{00988\ }
\DoxyCodeLine{00989\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00990\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ a\ single\ item\ (by\ copying\ it).}}
\DoxyCodeLine{00991\ \ \ \ \ \textcolor{comment}{//\ Allocates\ memory\ if\ required.\ Only\ fails\ if\ memory\ allocation\ fails\ (or\ implicit}}
\DoxyCodeLine{00992\ \ \ \ \ \textcolor{comment}{//\ production\ is\ disabled\ because\ Traits::INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ is\ 0,}}
\DoxyCodeLine{00993\ \ \ \ \ \textcolor{comment}{//\ or\ Traits::MAX\_SUBQUEUE\_SIZE\ has\ been\ defined\ and\ would\ be\ surpassed).}}
\DoxyCodeLine{00994\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{00995\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ enqueue(T\ \textcolor{keyword}{const}\&\ item)}
\DoxyCodeLine{00996\ \ \ \ \ \{}
\DoxyCodeLine{00997\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ ==\ 0)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00998\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{return}\ inner\_enqueue<CanAlloc>(item);}
\DoxyCodeLine{00999\ \ \ \ \ \}}
\DoxyCodeLine{01000\ }
\DoxyCodeLine{01001\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ a\ single\ item\ (by\ moving\ it,\ if\ possible).}}
\DoxyCodeLine{01002\ \ \ \ \ \textcolor{comment}{//\ Allocates\ memory\ if\ required.\ Only\ fails\ if\ memory\ allocation\ fails\ (or\ implicit}}
\DoxyCodeLine{01003\ \ \ \ \ \textcolor{comment}{//\ production\ is\ disabled\ because\ Traits::INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ is\ 0,}}
\DoxyCodeLine{01004\ \ \ \ \ \textcolor{comment}{//\ or\ Traits::MAX\_SUBQUEUE\_SIZE\ has\ been\ defined\ and\ would\ be\ surpassed).}}
\DoxyCodeLine{01005\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01006\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ enqueue(T\&\&\ item)}
\DoxyCodeLine{01007\ \ \ \ \ \{}
\DoxyCodeLine{01008\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ ==\ 0)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01009\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{return}\ inner\_enqueue<CanAlloc>(std::move(item));}
\DoxyCodeLine{01010\ \ \ \ \ \}}
\DoxyCodeLine{01011\ }
\DoxyCodeLine{01012\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ a\ single\ item\ (by\ copying\ it)\ using\ an\ explicit\ producer\ token.}}
\DoxyCodeLine{01013\ \ \ \ \ \textcolor{comment}{//\ Allocates\ memory\ if\ required.\ Only\ fails\ if\ memory\ allocation\ fails\ (or}}
\DoxyCodeLine{01014\ \ \ \ \ \textcolor{comment}{//\ Traits::MAX\_SUBQUEUE\_SIZE\ has\ been\ defined\ and\ would\ be\ surpassed).}}
\DoxyCodeLine{01015\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01016\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ enqueue(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}}\ \textcolor{keyword}{const}\&\ token,\ T\ \textcolor{keyword}{const}\&\ item)}
\DoxyCodeLine{01017\ \ \ \ \ \{}
\DoxyCodeLine{01018\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ inner\_enqueue<CanAlloc>(token,\ item);}
\DoxyCodeLine{01019\ \ \ \ \ \}}
\DoxyCodeLine{01020\ }
\DoxyCodeLine{01021\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ a\ single\ item\ (by\ moving\ it,\ if\ possible)\ using\ an\ explicit\ producer\ token.}}
\DoxyCodeLine{01022\ \ \ \ \ \textcolor{comment}{//\ Allocates\ memory\ if\ required.\ Only\ fails\ if\ memory\ allocation\ fails\ (or}}
\DoxyCodeLine{01023\ \ \ \ \ \textcolor{comment}{//\ Traits::MAX\_SUBQUEUE\_SIZE\ has\ been\ defined\ and\ would\ be\ surpassed).}}
\DoxyCodeLine{01024\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01025\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ enqueue(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}}\ \textcolor{keyword}{const}\&\ token,\ T\&\&\ item)}
\DoxyCodeLine{01026\ \ \ \ \ \{}
\DoxyCodeLine{01027\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ inner\_enqueue<CanAlloc>(token,\ std::move(item));}
\DoxyCodeLine{01028\ \ \ \ \ \}}
\DoxyCodeLine{01029\ }
\DoxyCodeLine{01030\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ several\ items.}}
\DoxyCodeLine{01031\ \ \ \ \ \textcolor{comment}{//\ Allocates\ memory\ if\ required.\ Only\ fails\ if\ memory\ allocation\ fails\ (or}}
\DoxyCodeLine{01032\ \ \ \ \ \textcolor{comment}{//\ implicit\ production\ is\ disabled\ because\ Traits::INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE}}
\DoxyCodeLine{01033\ \ \ \ \ \textcolor{comment}{//\ is\ 0,\ or\ Traits::MAX\_SUBQUEUE\_SIZE\ has\ been\ defined\ and\ would\ be\ surpassed).}}
\DoxyCodeLine{01034\ \ \ \ \ \textcolor{comment}{//\ Note:\ Use\ std::make\_move\_iterator\ if\ the\ elements\ should\ be\ moved\ instead\ of\ copied.}}
\DoxyCodeLine{01035\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01036\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{01037\ \ \ \ \ \textcolor{keywordtype}{bool}\ enqueue\_bulk(It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{01038\ \ \ \ \ \{}
\DoxyCodeLine{01039\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ ==\ 0)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01040\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{return}\ inner\_enqueue\_bulk<CanAlloc>(itemFirst,\ count);}
\DoxyCodeLine{01041\ \ \ \ \ \}}
\DoxyCodeLine{01042\ }
\DoxyCodeLine{01043\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ several\ items\ using\ an\ explicit\ producer\ token.}}
\DoxyCodeLine{01044\ \ \ \ \ \textcolor{comment}{//\ Allocates\ memory\ if\ required.\ Only\ fails\ if\ memory\ allocation\ fails}}
\DoxyCodeLine{01045\ \ \ \ \ \textcolor{comment}{//\ (or\ Traits::MAX\_SUBQUEUE\_SIZE\ has\ been\ defined\ and\ would\ be\ surpassed).}}
\DoxyCodeLine{01046\ \ \ \ \ \textcolor{comment}{//\ Note:\ Use\ std::make\_move\_iterator\ if\ the\ elements\ should\ be\ moved}}
\DoxyCodeLine{01047\ \ \ \ \ \textcolor{comment}{//\ instead\ of\ copied.}}
\DoxyCodeLine{01048\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01049\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{01050\ \ \ \ \ \textcolor{keywordtype}{bool}\ enqueue\_bulk(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}}\ \textcolor{keyword}{const}\&\ token,\ It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{01051\ \ \ \ \ \{}
\DoxyCodeLine{01052\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ inner\_enqueue\_bulk<CanAlloc>(token,\ itemFirst,\ count);}
\DoxyCodeLine{01053\ \ \ \ \ \}}
\DoxyCodeLine{01054\ }
\DoxyCodeLine{01055\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ a\ single\ item\ (by\ copying\ it).}}
\DoxyCodeLine{01056\ \ \ \ \ \textcolor{comment}{//\ Does\ not\ allocate\ memory.\ Fails\ if\ not\ enough\ room\ to\ enqueue\ (or\ implicit}}
\DoxyCodeLine{01057\ \ \ \ \ \textcolor{comment}{//\ production\ is\ disabled\ because\ Traits::INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE}}
\DoxyCodeLine{01058\ \ \ \ \ \textcolor{comment}{//\ is\ 0).}}
\DoxyCodeLine{01059\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01060\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ try\_enqueue(T\ \textcolor{keyword}{const}\&\ item)}
\DoxyCodeLine{01061\ \ \ \ \ \{}
\DoxyCodeLine{01062\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ ==\ 0)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01063\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{return}\ inner\_enqueue<CannotAlloc>(item);}
\DoxyCodeLine{01064\ \ \ \ \ \}}
\DoxyCodeLine{01065\ }
\DoxyCodeLine{01066\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ a\ single\ item\ (by\ moving\ it,\ if\ possible).}}
\DoxyCodeLine{01067\ \ \ \ \ \textcolor{comment}{//\ Does\ not\ allocate\ memory\ (except\ for\ one-\/time\ implicit\ producer).}}
\DoxyCodeLine{01068\ \ \ \ \ \textcolor{comment}{//\ Fails\ if\ not\ enough\ room\ to\ enqueue\ (or\ implicit\ production\ is}}
\DoxyCodeLine{01069\ \ \ \ \ \textcolor{comment}{//\ disabled\ because\ Traits::INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ is\ 0).}}
\DoxyCodeLine{01070\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01071\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ try\_enqueue(T\&\&\ item)}
\DoxyCodeLine{01072\ \ \ \ \ \{}
\DoxyCodeLine{01073\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ ==\ 0)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01074\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{return}\ inner\_enqueue<CannotAlloc>(std::move(item));}
\DoxyCodeLine{01075\ \ \ \ \ \}}
\DoxyCodeLine{01076\ }
\DoxyCodeLine{01077\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ a\ single\ item\ (by\ copying\ it)\ using\ an\ explicit\ producer\ token.}}
\DoxyCodeLine{01078\ \ \ \ \ \textcolor{comment}{//\ Does\ not\ allocate\ memory.\ Fails\ if\ not\ enough\ room\ to\ enqueue.}}
\DoxyCodeLine{01079\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01080\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ try\_enqueue(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}}\ \textcolor{keyword}{const}\&\ token,\ T\ \textcolor{keyword}{const}\&\ item)}
\DoxyCodeLine{01081\ \ \ \ \ \{}
\DoxyCodeLine{01082\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ inner\_enqueue<CannotAlloc>(token,\ item);}
\DoxyCodeLine{01083\ \ \ \ \ \}}
\DoxyCodeLine{01084\ }
\DoxyCodeLine{01085\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ a\ single\ item\ (by\ moving\ it,\ if\ possible)\ using\ an\ explicit\ producer\ token.}}
\DoxyCodeLine{01086\ \ \ \ \ \textcolor{comment}{//\ Does\ not\ allocate\ memory.\ Fails\ if\ not\ enough\ room\ to\ enqueue.}}
\DoxyCodeLine{01087\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01088\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ try\_enqueue(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}}\ \textcolor{keyword}{const}\&\ token,\ T\&\&\ item)}
\DoxyCodeLine{01089\ \ \ \ \ \{}
\DoxyCodeLine{01090\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ inner\_enqueue<CannotAlloc>(token,\ std::move(item));}
\DoxyCodeLine{01091\ \ \ \ \ \}}
\DoxyCodeLine{01092\ }
\DoxyCodeLine{01093\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ several\ items.}}
\DoxyCodeLine{01094\ \ \ \ \ \textcolor{comment}{//\ Does\ not\ allocate\ memory\ (except\ for\ one-\/time\ implicit\ producer).}}
\DoxyCodeLine{01095\ \ \ \ \ \textcolor{comment}{//\ Fails\ if\ not\ enough\ room\ to\ enqueue\ (or\ implicit\ production\ is}}
\DoxyCodeLine{01096\ \ \ \ \ \textcolor{comment}{//\ disabled\ because\ Traits::INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ is\ 0).}}
\DoxyCodeLine{01097\ \ \ \ \ \textcolor{comment}{//\ Note:\ Use\ std::make\_move\_iterator\ if\ the\ elements\ should\ be\ moved}}
\DoxyCodeLine{01098\ \ \ \ \ \textcolor{comment}{//\ instead\ of\ copied.}}
\DoxyCodeLine{01099\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01100\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{01101\ \ \ \ \ \textcolor{keywordtype}{bool}\ try\_enqueue\_bulk(It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{01102\ \ \ \ \ \{}
\DoxyCodeLine{01103\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ ==\ 0)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01104\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{return}\ inner\_enqueue\_bulk<CannotAlloc>(itemFirst,\ count);}
\DoxyCodeLine{01105\ \ \ \ \ \}}
\DoxyCodeLine{01106\ }
\DoxyCodeLine{01107\ \ \ \ \ \textcolor{comment}{//\ Enqueues\ several\ items\ using\ an\ explicit\ producer\ token.}}
\DoxyCodeLine{01108\ \ \ \ \ \textcolor{comment}{//\ Does\ not\ allocate\ memory.\ Fails\ if\ not\ enough\ room\ to\ enqueue.}}
\DoxyCodeLine{01109\ \ \ \ \ \textcolor{comment}{//\ Note:\ Use\ std::make\_move\_iterator\ if\ the\ elements\ should\ be\ moved}}
\DoxyCodeLine{01110\ \ \ \ \ \textcolor{comment}{//\ instead\ of\ copied.}}
\DoxyCodeLine{01111\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01112\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{01113\ \ \ \ \ \textcolor{keywordtype}{bool}\ try\_enqueue\_bulk(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}}\ \textcolor{keyword}{const}\&\ token,\ It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{01114\ \ \ \ \ \{}
\DoxyCodeLine{01115\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ inner\_enqueue\_bulk<CannotAlloc>(token,\ itemFirst,\ count);}
\DoxyCodeLine{01116\ \ \ \ \ \}}
\DoxyCodeLine{01117\ }
\DoxyCodeLine{01118\ }
\DoxyCodeLine{01119\ }
\DoxyCodeLine{01120\ \ \ \ \ \textcolor{comment}{//\ Attempts\ to\ dequeue\ from\ the\ queue.}}
\DoxyCodeLine{01121\ \ \ \ \ \textcolor{comment}{//\ Returns\ false\ if\ all\ producer\ streams\ appeared\ empty\ at\ the\ time\ they}}
\DoxyCodeLine{01122\ \ \ \ \ \textcolor{comment}{//\ were\ checked\ (so,\ the\ queue\ is\ likely\ but\ not\ guaranteed\ to\ be\ empty).}}
\DoxyCodeLine{01123\ \ \ \ \ \textcolor{comment}{//\ Never\ allocates.\ Thread-\/safe.}}
\DoxyCodeLine{01124\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01125\ \ \ \ \ \textcolor{keywordtype}{bool}\ try\_dequeue(U\&\ item)}
\DoxyCodeLine{01126\ \ \ \ \ \{}
\DoxyCodeLine{01127\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Instead\ of\ simply\ trying\ each\ producer\ in\ turn\ (which\ could\ cause\ needless\ contention\ on\ the\ first}}
\DoxyCodeLine{01128\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ producer),\ we\ score\ them\ heuristically.}}
\DoxyCodeLine{01129\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ nonEmptyCount\ =\ 0;}
\DoxyCodeLine{01130\ \ \ \ \ \ \ \ \ ProducerBase*\ best\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01131\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ bestSize\ =\ 0;}
\DoxyCodeLine{01132\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ ptr\ =\ producerListTail.load(std::memory\_order\_acquire);\ nonEmptyCount\ <\ 3\ \&\&\ ptr\ !=\ \textcolor{keyword}{nullptr};\ ptr\ =\ ptr-\/>next\_prod())\ \{}
\DoxyCodeLine{01133\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ size\ =\ ptr-\/>size\_approx();}
\DoxyCodeLine{01134\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (size\ >\ 0)\ \{}
\DoxyCodeLine{01135\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (size\ >\ bestSize)\ \{}
\DoxyCodeLine{01136\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bestSize\ =\ size;}
\DoxyCodeLine{01137\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ best\ =\ ptr;}
\DoxyCodeLine{01138\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01139\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++nonEmptyCount;}
\DoxyCodeLine{01140\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01141\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01142\ }
\DoxyCodeLine{01143\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ there\ was\ at\ least\ one\ non-\/empty\ queue\ but\ it\ appears\ empty\ at\ the\ time}}
\DoxyCodeLine{01144\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ we\ try\ to\ dequeue\ from\ it,\ we\ need\ to\ make\ sure\ every\ queue's\ been\ tried}}
\DoxyCodeLine{01145\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (nonEmptyCount\ >\ 0)\ \{}
\DoxyCodeLine{01146\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((details::likely)(best-\/>dequeue(item)))\ \{}
\DoxyCodeLine{01147\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01148\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01149\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ ptr\ =\ producerListTail.load(std::memory\_order\_acquire);\ ptr\ !=\ \textcolor{keyword}{nullptr};\ ptr\ =\ ptr-\/>next\_prod())\ \{}
\DoxyCodeLine{01150\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr\ !=\ best\ \&\&\ ptr-\/>dequeue(item))\ \{}
\DoxyCodeLine{01151\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01152\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01153\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01154\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01155\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01156\ \ \ \ \ \}}
\DoxyCodeLine{01157\ }
\DoxyCodeLine{01158\ \ \ \ \ \textcolor{comment}{//\ Attempts\ to\ dequeue\ from\ the\ queue.}}
\DoxyCodeLine{01159\ \ \ \ \ \textcolor{comment}{//\ Returns\ false\ if\ all\ producer\ streams\ appeared\ empty\ at\ the\ time\ they}}
\DoxyCodeLine{01160\ \ \ \ \ \textcolor{comment}{//\ were\ checked\ (so,\ the\ queue\ is\ likely\ but\ not\ guaranteed\ to\ be\ empty).}}
\DoxyCodeLine{01161\ \ \ \ \ \textcolor{comment}{//\ This\ differs\ from\ the\ try\_dequeue(item)\ method\ in\ that\ this\ one\ does}}
\DoxyCodeLine{01162\ \ \ \ \ \textcolor{comment}{//\ not\ attempt\ to\ reduce\ contention\ by\ interleaving\ the\ order\ that\ producer}}
\DoxyCodeLine{01163\ \ \ \ \ \textcolor{comment}{//\ streams\ are\ dequeued\ from.\ So,\ using\ this\ method\ can\ reduce\ overall\ throughput}}
\DoxyCodeLine{01164\ \ \ \ \ \textcolor{comment}{//\ under\ contention,\ but\ will\ give\ more\ predictable\ results\ in\ single-\/threaded}}
\DoxyCodeLine{01165\ \ \ \ \ \textcolor{comment}{//\ consumer\ scenarios.\ This\ is\ mostly\ only\ useful\ for\ internal\ unit\ tests.}}
\DoxyCodeLine{01166\ \ \ \ \ \textcolor{comment}{//\ Never\ allocates.\ Thread-\/safe.}}
\DoxyCodeLine{01167\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01168\ \ \ \ \ \textcolor{keywordtype}{bool}\ try\_dequeue\_non\_interleaved(U\&\ item)}
\DoxyCodeLine{01169\ \ \ \ \ \{}
\DoxyCodeLine{01170\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ ptr\ =\ producerListTail.load(std::memory\_order\_acquire);\ ptr\ !=\ \textcolor{keyword}{nullptr};\ ptr\ =\ ptr-\/>next\_prod())\ \{}
\DoxyCodeLine{01171\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr-\/>dequeue(item))\ \{}
\DoxyCodeLine{01172\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01173\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01174\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01175\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01176\ \ \ \ \ \}}
\DoxyCodeLine{01177\ }
\DoxyCodeLine{01178\ \ \ \ \ \textcolor{comment}{//\ Attempts\ to\ dequeue\ from\ the\ queue\ using\ an\ explicit\ consumer\ token.}}
\DoxyCodeLine{01179\ \ \ \ \ \textcolor{comment}{//\ Returns\ false\ if\ all\ producer\ streams\ appeared\ empty\ at\ the\ time\ they}}
\DoxyCodeLine{01180\ \ \ \ \ \textcolor{comment}{//\ were\ checked\ (so,\ the\ queue\ is\ likely\ but\ not\ guaranteed\ to\ be\ empty).}}
\DoxyCodeLine{01181\ \ \ \ \ \textcolor{comment}{//\ Never\ allocates.\ Thread-\/safe.}}
\DoxyCodeLine{01182\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01183\ \ \ \ \ \textcolor{keywordtype}{bool}\ try\_dequeue(\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{consumer\_token\_t}}\&\ token,\ U\&\ item)}
\DoxyCodeLine{01184\ \ \ \ \ \{}
\DoxyCodeLine{01185\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ idea\ is\ roughly\ as\ follows:}}
\DoxyCodeLine{01186\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Every\ 256\ items\ from\ one\ producer,\ make\ everyone\ rotate\ (increase\ the\ global\ offset)\ -\/>\ this\ means\ the\ highest\ efficiency\ consumer\ dictates\ the\ rotation\ speed\ of\ everyone\ else,\ more\ or\ less}}
\DoxyCodeLine{01187\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ you\ see\ that\ the\ global\ offset\ has\ changed,\ you\ must\ reset\ your\ consumption\ counter\ and\ move\ to\ your\ designated\ place}}
\DoxyCodeLine{01188\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ there's\ no\ items\ where\ you're\ supposed\ to\ be,\ keep\ moving\ until\ you\ find\ a\ producer\ with\ some\ items}}
\DoxyCodeLine{01189\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ global\ offset\ has\ not\ changed\ but\ you've\ run\ out\ of\ items\ to\ consume,\ move\ over\ from\ your\ current\ position\ until\ you\ find\ an\ producer\ with\ something\ in\ it}}
\DoxyCodeLine{01190\ }
\DoxyCodeLine{01191\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (token.desiredProducer\ ==\ \textcolor{keyword}{nullptr}\ ||\ token.lastKnownGlobalOffset\ !=\ globalExplicitConsumerOffset.load(std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{01192\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!update\_current\_producer\_after\_rotation(token))\ \{}
\DoxyCodeLine{01193\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01194\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01195\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01196\ }
\DoxyCodeLine{01197\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ there\ was\ at\ least\ one\ non-\/empty\ queue\ but\ it\ appears\ empty\ at\ the\ time}}
\DoxyCodeLine{01198\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ we\ try\ to\ dequeue\ from\ it,\ we\ need\ to\ make\ sure\ every\ queue's\ been\ tried}}
\DoxyCodeLine{01199\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{static\_cast<}ProducerBase*\textcolor{keyword}{>}(token.currentProducer)-\/>dequeue(item))\ \{}
\DoxyCodeLine{01200\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (++token.itemsConsumedFromCurrent\ ==\ EXPLICIT\_CONSUMER\_CONSUMPTION\_QUOTA\_BEFORE\_ROTATE)\ \{}
\DoxyCodeLine{01201\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ globalExplicitConsumerOffset.fetch\_add(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{01202\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01203\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01204\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01205\ }
\DoxyCodeLine{01206\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tail\ =\ producerListTail.load(std::memory\_order\_acquire);}
\DoxyCodeLine{01207\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ ptr\ =\ \textcolor{keyword}{static\_cast<}ProducerBase*\textcolor{keyword}{>}(token.currentProducer)-\/>next\_prod();}
\DoxyCodeLine{01208\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01209\ \ \ \ \ \ \ \ \ \ \ \ \ ptr\ =\ tail;}
\DoxyCodeLine{01210\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01211\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (ptr\ !=\ \textcolor{keyword}{static\_cast<}ProducerBase*\textcolor{keyword}{>}(token.currentProducer))\ \{}
\DoxyCodeLine{01212\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr-\/>dequeue(item))\ \{}
\DoxyCodeLine{01213\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ token.currentProducer\ =\ ptr;}
\DoxyCodeLine{01214\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ token.itemsConsumedFromCurrent\ =\ 1;}
\DoxyCodeLine{01215\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01216\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01217\ \ \ \ \ \ \ \ \ \ \ \ \ ptr\ =\ ptr-\/>next\_prod();}
\DoxyCodeLine{01218\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01219\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ptr\ =\ tail;}
\DoxyCodeLine{01220\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01221\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01222\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01223\ \ \ \ \ \}}
\DoxyCodeLine{01224\ }
\DoxyCodeLine{01225\ \ \ \ \ \textcolor{comment}{//\ Attempts\ to\ dequeue\ several\ elements\ from\ the\ queue.}}
\DoxyCodeLine{01226\ \ \ \ \ \textcolor{comment}{//\ Returns\ the\ number\ of\ items\ actually\ dequeued.}}
\DoxyCodeLine{01227\ \ \ \ \ \textcolor{comment}{//\ Returns\ 0\ if\ all\ producer\ streams\ appeared\ empty\ at\ the\ time\ they}}
\DoxyCodeLine{01228\ \ \ \ \ \textcolor{comment}{//\ were\ checked\ (so,\ the\ queue\ is\ likely\ but\ not\ guaranteed\ to\ be\ empty).}}
\DoxyCodeLine{01229\ \ \ \ \ \textcolor{comment}{//\ Never\ allocates.\ Thread-\/safe.}}
\DoxyCodeLine{01230\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{01231\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ try\_dequeue\_bulk(It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ max)}
\DoxyCodeLine{01232\ \ \ \ \ \{}
\DoxyCodeLine{01233\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ count\ =\ 0;}
\DoxyCodeLine{01234\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ ptr\ =\ producerListTail.load(std::memory\_order\_acquire);\ ptr\ !=\ \textcolor{keyword}{nullptr};\ ptr\ =\ ptr-\/>next\_prod())\ \{}
\DoxyCodeLine{01235\ \ \ \ \ \ \ \ \ \ \ \ \ count\ +=\ ptr-\/>dequeue\_bulk(itemFirst,\ max\ -\/\ count);}
\DoxyCodeLine{01236\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (count\ ==\ max)\ \{}
\DoxyCodeLine{01237\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{01238\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01239\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01240\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ count;}
\DoxyCodeLine{01241\ \ \ \ \ \}}
\DoxyCodeLine{01242\ }
\DoxyCodeLine{01243\ \ \ \ \ \textcolor{comment}{//\ Attempts\ to\ dequeue\ several\ elements\ from\ the\ queue\ using\ an\ explicit\ consumer\ token.}}
\DoxyCodeLine{01244\ \ \ \ \ \textcolor{comment}{//\ Returns\ the\ number\ of\ items\ actually\ dequeued.}}
\DoxyCodeLine{01245\ \ \ \ \ \textcolor{comment}{//\ Returns\ 0\ if\ all\ producer\ streams\ appeared\ empty\ at\ the\ time\ they}}
\DoxyCodeLine{01246\ \ \ \ \ \textcolor{comment}{//\ were\ checked\ (so,\ the\ queue\ is\ likely\ but\ not\ guaranteed\ to\ be\ empty).}}
\DoxyCodeLine{01247\ \ \ \ \ \textcolor{comment}{//\ Never\ allocates.\ Thread-\/safe.}}
\DoxyCodeLine{01248\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{01249\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ try\_dequeue\_bulk(\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{consumer\_token\_t}}\&\ token,\ It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ max)}
\DoxyCodeLine{01250\ \ \ \ \ \{}
\DoxyCodeLine{01251\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (token.desiredProducer\ ==\ \textcolor{keyword}{nullptr}\ ||\ token.lastKnownGlobalOffset\ !=\ globalExplicitConsumerOffset.load(std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{01252\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!update\_current\_producer\_after\_rotation(token))\ \{}
\DoxyCodeLine{01253\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{01254\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01255\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01256\ }
\DoxyCodeLine{01257\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ count\ =\ \textcolor{keyword}{static\_cast<}ProducerBase*\textcolor{keyword}{>}(token.currentProducer)-\/>dequeue\_bulk(itemFirst,\ max);}
\DoxyCodeLine{01258\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (count\ ==\ max)\ \{}
\DoxyCodeLine{01259\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((token.itemsConsumedFromCurrent\ +=\ \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(max))\ >=\ EXPLICIT\_CONSUMER\_CONSUMPTION\_QUOTA\_BEFORE\_ROTATE)\ \{}
\DoxyCodeLine{01260\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ globalExplicitConsumerOffset.fetch\_add(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{01261\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01262\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ max;}
\DoxyCodeLine{01263\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01264\ \ \ \ \ \ \ \ \ token.itemsConsumedFromCurrent\ +=\ \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(count);}
\DoxyCodeLine{01265\ \ \ \ \ \ \ \ \ max\ -\/=\ count;}
\DoxyCodeLine{01266\ }
\DoxyCodeLine{01267\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tail\ =\ producerListTail.load(std::memory\_order\_acquire);}
\DoxyCodeLine{01268\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ ptr\ =\ \textcolor{keyword}{static\_cast<}ProducerBase*\textcolor{keyword}{>}(token.currentProducer)-\/>next\_prod();}
\DoxyCodeLine{01269\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01270\ \ \ \ \ \ \ \ \ \ \ \ \ ptr\ =\ tail;}
\DoxyCodeLine{01271\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01272\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (ptr\ !=\ \textcolor{keyword}{static\_cast<}ProducerBase*\textcolor{keyword}{>}(token.currentProducer))\ \{}
\DoxyCodeLine{01273\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ dequeued\ =\ ptr-\/>dequeue\_bulk(itemFirst,\ max);}
\DoxyCodeLine{01274\ \ \ \ \ \ \ \ \ \ \ \ \ count\ +=\ dequeued;}
\DoxyCodeLine{01275\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (dequeued\ !=\ 0)\ \{}
\DoxyCodeLine{01276\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ token.currentProducer\ =\ ptr;}
\DoxyCodeLine{01277\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ token.itemsConsumedFromCurrent\ =\ \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(dequeued);}
\DoxyCodeLine{01278\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01279\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (dequeued\ ==\ max)\ \{}
\DoxyCodeLine{01280\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{01281\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01282\ \ \ \ \ \ \ \ \ \ \ \ \ max\ -\/=\ dequeued;}
\DoxyCodeLine{01283\ \ \ \ \ \ \ \ \ \ \ \ \ ptr\ =\ ptr-\/>next\_prod();}
\DoxyCodeLine{01284\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01285\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ptr\ =\ tail;}
\DoxyCodeLine{01286\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01287\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01288\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ count;}
\DoxyCodeLine{01289\ \ \ \ \ \}}
\DoxyCodeLine{01290\ }
\DoxyCodeLine{01291\ }
\DoxyCodeLine{01292\ }
\DoxyCodeLine{01293\ \ \ \ \ \textcolor{comment}{//\ Attempts\ to\ dequeue\ from\ a\ specific\ producer's\ inner\ queue.}}
\DoxyCodeLine{01294\ \ \ \ \ \textcolor{comment}{//\ If\ you\ happen\ to\ know\ which\ producer\ you\ want\ to\ dequeue\ from,\ this}}
\DoxyCodeLine{01295\ \ \ \ \ \textcolor{comment}{//\ is\ significantly\ faster\ than\ using\ the\ general-\/case\ try\_dequeue\ methods.}}
\DoxyCodeLine{01296\ \ \ \ \ \textcolor{comment}{//\ Returns\ false\ if\ the\ producer's\ queue\ appeared\ empty\ at\ the\ time\ it}}
\DoxyCodeLine{01297\ \ \ \ \ \textcolor{comment}{//\ was\ checked\ (so,\ the\ queue\ is\ likely\ but\ not\ guaranteed\ to\ be\ empty).}}
\DoxyCodeLine{01298\ \ \ \ \ \textcolor{comment}{//\ Never\ allocates.\ Thread-\/safe.}}
\DoxyCodeLine{01299\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01300\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ try\_dequeue\_from\_producer(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}}\ \textcolor{keyword}{const}\&\ producer,\ U\&\ item)}
\DoxyCodeLine{01301\ \ \ \ \ \{}
\DoxyCodeLine{01302\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}ExplicitProducer*\textcolor{keyword}{>}(producer.producer)-\/>dequeue(item);}
\DoxyCodeLine{01303\ \ \ \ \ \}}
\DoxyCodeLine{01304\ }
\DoxyCodeLine{01305\ \ \ \ \ \textcolor{comment}{//\ Attempts\ to\ dequeue\ several\ elements\ from\ a\ specific\ producer's\ inner\ queue.}}
\DoxyCodeLine{01306\ \ \ \ \ \textcolor{comment}{//\ Returns\ the\ number\ of\ items\ actually\ dequeued.}}
\DoxyCodeLine{01307\ \ \ \ \ \textcolor{comment}{//\ If\ you\ happen\ to\ know\ which\ producer\ you\ want\ to\ dequeue\ from,\ this}}
\DoxyCodeLine{01308\ \ \ \ \ \textcolor{comment}{//\ is\ significantly\ faster\ than\ using\ the\ general-\/case\ try\_dequeue\ methods.}}
\DoxyCodeLine{01309\ \ \ \ \ \textcolor{comment}{//\ Returns\ 0\ if\ the\ producer's\ queue\ appeared\ empty\ at\ the\ time\ it}}
\DoxyCodeLine{01310\ \ \ \ \ \textcolor{comment}{//\ was\ checked\ (so,\ the\ queue\ is\ likely\ but\ not\ guaranteed\ to\ be\ empty).}}
\DoxyCodeLine{01311\ \ \ \ \ \textcolor{comment}{//\ Never\ allocates.\ Thread-\/safe.}}
\DoxyCodeLine{01312\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{01313\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{size\_t}\ try\_dequeue\_bulk\_from\_producer(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}}\ \textcolor{keyword}{const}\&\ producer,\ It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ max)}
\DoxyCodeLine{01314\ \ \ \ \ \{}
\DoxyCodeLine{01315\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}ExplicitProducer*\textcolor{keyword}{>}(producer.producer)-\/>dequeue\_bulk(itemFirst,\ max);}
\DoxyCodeLine{01316\ \ \ \ \ \}}
\DoxyCodeLine{01317\ }
\DoxyCodeLine{01318\ }
\DoxyCodeLine{01319\ \ \ \ \ \textcolor{comment}{//\ Returns\ an\ estimate\ of\ the\ total\ number\ of\ elements\ currently\ in\ the\ queue.\ This}}
\DoxyCodeLine{01320\ \ \ \ \ \textcolor{comment}{//\ estimate\ is\ only\ accurate\ if\ the\ queue\ has\ completely\ stabilized\ before\ it\ is\ called}}
\DoxyCodeLine{01321\ \ \ \ \ \textcolor{comment}{//\ (i.e.\ all\ enqueue\ and\ dequeue\ operations\ have\ completed\ and\ their\ memory\ effects\ are}}
\DoxyCodeLine{01322\ \ \ \ \ \textcolor{comment}{//\ visible\ on\ the\ calling\ thread,\ and\ no\ further\ operations\ start\ while\ this\ method\ is}}
\DoxyCodeLine{01323\ \ \ \ \ \textcolor{comment}{//\ being\ called).}}
\DoxyCodeLine{01324\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01325\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ size\_approx()\textcolor{keyword}{\ const}}
\DoxyCodeLine{01326\ \textcolor{keyword}{\ \ \ \ }\{}
\DoxyCodeLine{01327\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ size\ =\ 0;}
\DoxyCodeLine{01328\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ ptr\ =\ producerListTail.load(std::memory\_order\_acquire);\ ptr\ !=\ \textcolor{keyword}{nullptr};\ ptr\ =\ ptr-\/>next\_prod())\ \{}
\DoxyCodeLine{01329\ \ \ \ \ \ \ \ \ \ \ \ \ size\ +=\ ptr-\/>size\_approx();}
\DoxyCodeLine{01330\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01331\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ size;}
\DoxyCodeLine{01332\ \ \ \ \ \}}
\DoxyCodeLine{01333\ }
\DoxyCodeLine{01334\ }
\DoxyCodeLine{01335\ \ \ \ \ \textcolor{comment}{//\ Returns\ true\ if\ the\ underlying\ atomic\ variables\ used\ by}}
\DoxyCodeLine{01336\ \ \ \ \ \textcolor{comment}{//\ the\ queue\ are\ lock-\/free\ (they\ should\ be\ on\ most\ platforms).}}
\DoxyCodeLine{01337\ \ \ \ \ \textcolor{comment}{//\ Thread-\/safe.}}
\DoxyCodeLine{01338\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ is\_lock\_free()}
\DoxyCodeLine{01339\ \ \ \ \ \{}
\DoxyCodeLine{01340\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}}
\DoxyCodeLine{01341\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free}{details::static\_is\_lock\_free<bool>::value}}\ ==\ 2\ \&\&}
\DoxyCodeLine{01342\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free}{details::static\_is\_lock\_free<size\_t>::value}}\ ==\ 2\ \&\&}
\DoxyCodeLine{01343\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free}{details::static\_is\_lock\_free<std::uint32\_t>::value}}\ ==\ 2\ \&\&}
\DoxyCodeLine{01344\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free}{details::static\_is\_lock\_free<index\_t>::value}}\ ==\ 2\ \&\&}
\DoxyCodeLine{01345\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free}{details::static\_is\_lock\_free<void*>::value}}\ ==\ 2\ \&\&}
\DoxyCodeLine{01346\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1static__is__lock__free}{details::static\_is\_lock\_free<typename\ details::thread\_id\_converter<details::thread\_id\_t>::thread\_id\_numeric\_size\_t}}>::value\ ==\ 2;}
\DoxyCodeLine{01347\ \ \ \ \ \}}
\DoxyCodeLine{01348\ }
\DoxyCodeLine{01349\ }
\DoxyCodeLine{01350\ \textcolor{keyword}{private}:}
\DoxyCodeLine{01351\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}};}
\DoxyCodeLine{01352\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}};}
\DoxyCodeLine{01353\ \ \ \ \ \textcolor{keyword}{struct\ }ExplicitProducer;}
\DoxyCodeLine{01354\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{struct\ }ExplicitProducer;}
\DoxyCodeLine{01355\ \ \ \ \ \textcolor{keyword}{struct\ }ImplicitProducer;}
\DoxyCodeLine{01356\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{struct\ }ImplicitProducer;}
\DoxyCodeLine{01357\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{class\ }ConcurrentQueueTests;}
\DoxyCodeLine{01358\ }
\DoxyCodeLine{01359\ \ \ \ \ \textcolor{keyword}{enum}\ AllocationMode\ \{\ CanAlloc,\ CannotAlloc\ \};}
\DoxyCodeLine{01360\ }
\DoxyCodeLine{01361\ }
\DoxyCodeLine{01363\ \ \ \ \ \textcolor{comment}{//\ Queue\ methods}}
\DoxyCodeLine{01365\ }
\DoxyCodeLine{01366\ \ \ \ \ \textcolor{keyword}{template}<AllocationMode\ canAlloc,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01367\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ inner\_enqueue(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}}\ \textcolor{keyword}{const}\&\ token,\ U\&\&\ element)}
\DoxyCodeLine{01368\ \ \ \ \ \{}
\DoxyCodeLine{01369\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}ExplicitProducer*\textcolor{keyword}{>}(token.producer)-\/>ConcurrentQueue::ExplicitProducer::template\ enqueue<canAlloc>(std::forward<U>(element));}
\DoxyCodeLine{01370\ \ \ \ \ \}}
\DoxyCodeLine{01371\ }
\DoxyCodeLine{01372\ \ \ \ \ \textcolor{keyword}{template}<AllocationMode\ canAlloc,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01373\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ inner\_enqueue(U\&\&\ element)}
\DoxyCodeLine{01374\ \ \ \ \ \{}
\DoxyCodeLine{01375\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ producer\ =\ get\_or\_add\_implicit\_producer();}
\DoxyCodeLine{01376\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ producer\ ==\ \textcolor{keyword}{nullptr}\ ?\ false\ :\ producer-\/>ConcurrentQueue::ImplicitProducer::template\ enqueue<canAlloc>(std::forward<U>(element));}
\DoxyCodeLine{01377\ \ \ \ \ \}}
\DoxyCodeLine{01378\ }
\DoxyCodeLine{01379\ \ \ \ \ \textcolor{keyword}{template}<AllocationMode\ canAlloc,\ \textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{01380\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ inner\_enqueue\_bulk(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{producer\_token\_t}}\ \textcolor{keyword}{const}\&\ token,\ It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{01381\ \ \ \ \ \{}
\DoxyCodeLine{01382\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}ExplicitProducer*\textcolor{keyword}{>}(token.producer)-\/>ConcurrentQueue::ExplicitProducer::template\ enqueue\_bulk<canAlloc>(itemFirst,\ count);}
\DoxyCodeLine{01383\ \ \ \ \ \}}
\DoxyCodeLine{01384\ }
\DoxyCodeLine{01385\ \ \ \ \ \textcolor{keyword}{template}<AllocationMode\ canAlloc,\ \textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{01386\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ inner\_enqueue\_bulk(It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{01387\ \ \ \ \ \{}
\DoxyCodeLine{01388\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ producer\ =\ get\_or\_add\_implicit\_producer();}
\DoxyCodeLine{01389\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ producer\ ==\ \textcolor{keyword}{nullptr}\ ?\ false\ :\ producer-\/>ConcurrentQueue::ImplicitProducer::template\ enqueue\_bulk<canAlloc>(itemFirst,\ count);}
\DoxyCodeLine{01390\ \ \ \ \ \}}
\DoxyCodeLine{01391\ }
\DoxyCodeLine{01392\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ update\_current\_producer\_after\_rotation(\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{consumer\_token\_t}}\&\ token)}
\DoxyCodeLine{01393\ \ \ \ \ \{}
\DoxyCodeLine{01394\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Ah,\ there's\ been\ a\ rotation,\ figure\ out\ where\ we\ should\ be!}}
\DoxyCodeLine{01395\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tail\ =\ producerListTail.load(std::memory\_order\_acquire);}
\DoxyCodeLine{01396\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (token.desiredProducer\ ==\ \textcolor{keyword}{nullptr}\ \&\&\ tail\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01397\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01398\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01399\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prodCount\ =\ producerCount.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01400\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ globalOffset\ =\ globalExplicitConsumerOffset.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01401\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((details::unlikely)(token.desiredProducer\ ==\ \textcolor{keyword}{nullptr}))\ \{}
\DoxyCodeLine{01402\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Aha,\ first\ time\ we're\ dequeueing\ anything.}}
\DoxyCodeLine{01403\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Figure\ out\ our\ local\ position}}
\DoxyCodeLine{01404\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note:\ offset\ is\ from\ start,\ not\ end,\ but\ we're\ traversing\ from\ end\ -\/-\/\ subtract\ from\ count\ first}}
\DoxyCodeLine{01405\ \ \ \ \ \ \ \ \ \ \ \ \ std::uint32\_t\ offset\ =\ prodCount\ -\/\ 1\ -\/\ (token.initialOffset\ \%\ prodCount);}
\DoxyCodeLine{01406\ \ \ \ \ \ \ \ \ \ \ \ \ token.desiredProducer\ =\ tail;}
\DoxyCodeLine{01407\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (std::uint32\_t\ i\ =\ 0;\ i\ !=\ offset;\ ++i)\ \{}
\DoxyCodeLine{01408\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ token.desiredProducer\ =\ \textcolor{keyword}{static\_cast<}ProducerBase*\textcolor{keyword}{>}(token.desiredProducer)-\/>next\_prod();}
\DoxyCodeLine{01409\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (token.desiredProducer\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01410\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ token.desiredProducer\ =\ tail;}
\DoxyCodeLine{01411\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01412\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01413\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01414\ }
\DoxyCodeLine{01415\ \ \ \ \ \ \ \ \ std::uint32\_t\ delta\ =\ globalOffset\ -\/\ token.lastKnownGlobalOffset;}
\DoxyCodeLine{01416\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (delta\ >=\ prodCount)\ \{}
\DoxyCodeLine{01417\ \ \ \ \ \ \ \ \ \ \ \ \ delta\ =\ delta\ \%\ prodCount;}
\DoxyCodeLine{01418\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01419\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (std::uint32\_t\ i\ =\ 0;\ i\ !=\ delta;\ ++i)\ \{}
\DoxyCodeLine{01420\ \ \ \ \ \ \ \ \ \ \ \ \ token.desiredProducer\ =\ \textcolor{keyword}{static\_cast<}ProducerBase*\textcolor{keyword}{>}(token.desiredProducer)-\/>next\_prod();}
\DoxyCodeLine{01421\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (token.desiredProducer\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01422\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ token.desiredProducer\ =\ tail;}
\DoxyCodeLine{01423\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01424\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01425\ }
\DoxyCodeLine{01426\ \ \ \ \ \ \ \ \ token.lastKnownGlobalOffset\ =\ globalOffset;}
\DoxyCodeLine{01427\ \ \ \ \ \ \ \ \ token.currentProducer\ =\ token.desiredProducer;}
\DoxyCodeLine{01428\ \ \ \ \ \ \ \ \ token.itemsConsumedFromCurrent\ =\ 0;}
\DoxyCodeLine{01429\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01430\ \ \ \ \ \}}
\DoxyCodeLine{01431\ }
\DoxyCodeLine{01432\ }
\DoxyCodeLine{01434\ \ \ \ \ \textcolor{comment}{//\ Free\ list}}
\DoxyCodeLine{01436\ }
\DoxyCodeLine{01437\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ N>}
\DoxyCodeLine{01438\ \ \ \ \ \textcolor{keyword}{struct\ }FreeListNode}
\DoxyCodeLine{01439\ \ \ \ \ \{}
\DoxyCodeLine{01440\ \ \ \ \ \ \ \ \ FreeListNode()\ :\ freeListRefs(0),\ freeListNext(\textcolor{keyword}{nullptr})\ \{\ \}}
\DoxyCodeLine{01441\ }
\DoxyCodeLine{01442\ \ \ \ \ \ \ \ \ std::atomic<std::uint32\_t>\ freeListRefs;}
\DoxyCodeLine{01443\ \ \ \ \ \ \ \ \ std::atomic<N*>\ freeListNext;}
\DoxyCodeLine{01444\ \ \ \ \ \};}
\DoxyCodeLine{01445\ }
\DoxyCodeLine{01446\ \ \ \ \ \textcolor{comment}{//\ A\ simple\ CAS-\/based\ lock-\/free\ free\ list.\ Not\ the\ fastest\ thing\ in\ the\ world\ under\ heavy\ contention,\ but}}
\DoxyCodeLine{01447\ \ \ \ \ \textcolor{comment}{//\ simple\ and\ correct\ (assuming\ nodes\ are\ never\ freed\ until\ after\ the\ free\ list\ is\ destroyed),\ and\ fairly}}
\DoxyCodeLine{01448\ \ \ \ \ \textcolor{comment}{//\ speedy\ under\ low\ contention.}}
\DoxyCodeLine{01449\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ N>\ \ \ \ \ \ \ \ \textcolor{comment}{//\ N\ must\ inherit\ FreeListNode\ or\ have\ the\ same\ fields\ (and\ initialization\ of\ them)}}
\DoxyCodeLine{01450\ \ \ \ \ \textcolor{keyword}{struct\ }FreeList}
\DoxyCodeLine{01451\ \ \ \ \ \{}
\DoxyCodeLine{01452\ \ \ \ \ \ \ \ \ FreeList()\ :\ freeListHead(\textcolor{keyword}{nullptr})\ \{\ \}}
\DoxyCodeLine{01453\ \ \ \ \ \ \ \ \ FreeList(FreeList\&\&\ other)\ :\ freeListHead(other.freeListHead.load(std::memory\_order\_relaxed))\ \{\ other.freeListHead.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);\ \}}
\DoxyCodeLine{01454\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}\ swap(FreeList\&\ other)\ \{\ details::swap\_relaxed(freeListHead,\ other.freeListHead);\ \}}
\DoxyCodeLine{01455\ }
\DoxyCodeLine{01456\ \ \ \ \ \ \ \ \ FreeList(FreeList\ \textcolor{keyword}{const}\&)\ MOODYCAMEL\_DELETE\_FUNCTION;}
\DoxyCodeLine{01457\ \ \ \ \ \ \ \ \ FreeList\&\ operator=(FreeList\ \textcolor{keyword}{const}\&)\ MOODYCAMEL\_DELETE\_FUNCTION;}
\DoxyCodeLine{01458\ }
\DoxyCodeLine{01459\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ add(N*\ node)}
\DoxyCodeLine{01460\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01461\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_FREELIST}}
\DoxyCodeLine{01462\ \ \ \ \ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(mutex);}
\DoxyCodeLine{01463\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01464\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ know\ that\ the\ should-\/be-\/on-\/freelist\ bit\ is\ 0\ at\ this\ point,\ so\ it's\ safe\ to}}
\DoxyCodeLine{01465\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ set\ it\ using\ a\ fetch\_add}}
\DoxyCodeLine{01466\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node-\/>freeListRefs.fetch\_add(SHOULD\_BE\_ON\_FREELIST,\ std::memory\_order\_acq\_rel)\ ==\ 0)\ \{}
\DoxyCodeLine{01467\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Oh\ look!\ We\ were\ the\ last\ ones\ referencing\ this\ node,\ and\ we\ know}}
\DoxyCodeLine{01468\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ we\ want\ to\ add\ it\ to\ the\ free\ list,\ so\ let's\ do\ it!}}
\DoxyCodeLine{01469\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ add\_knowing\_refcount\_is\_zero(node);}
\DoxyCodeLine{01470\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01471\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01472\ }
\DoxyCodeLine{01473\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ N*\ try\_get()}
\DoxyCodeLine{01474\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01475\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_FREELIST}}
\DoxyCodeLine{01476\ \ \ \ \ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(mutex);}
\DoxyCodeLine{01477\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01478\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ head\ =\ freeListHead.load(std::memory\_order\_acquire);}
\DoxyCodeLine{01479\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (head\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01480\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prevHead\ =\ head;}
\DoxyCodeLine{01481\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ refs\ =\ head-\/>freeListRefs.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01482\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((refs\ \&\ REFS\_MASK)\ ==\ 0\ ||\ !head-\/>freeListRefs.compare\_exchange\_strong(refs,\ refs\ +\ 1,\ std::memory\_order\_acquire,\ std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{01483\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ head\ =\ freeListHead.load(std::memory\_order\_acquire);}
\DoxyCodeLine{01484\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{01485\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01486\ }
\DoxyCodeLine{01487\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Good,\ reference\ count\ has\ been\ incremented\ (it\ wasn't\ at\ zero),\ which\ means\ we\ can\ read\ the}}
\DoxyCodeLine{01488\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ next\ and\ not\ worry\ about\ it\ changing\ between\ now\ and\ the\ time\ we\ do\ the\ CAS}}
\DoxyCodeLine{01489\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ next\ =\ head-\/>freeListNext.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01490\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (freeListHead.compare\_exchange\_strong(head,\ next,\ std::memory\_order\_acquire,\ std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{01491\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Yay,\ got\ the\ node.\ This\ means\ it\ was\ on\ the\ list,\ which\ means\ shouldBeOnFreeList\ must\ be\ false\ no}}
\DoxyCodeLine{01492\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ matter\ the\ refcount\ (because\ nobody\ else\ knows\ it's\ been\ taken\ off\ yet,\ it\ can't\ have\ been\ put\ back\ on).}}
\DoxyCodeLine{01493\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert((head-\/>freeListRefs.load(std::memory\_order\_relaxed)\ \&\ SHOULD\_BE\_ON\_FREELIST)\ ==\ 0);}
\DoxyCodeLine{01494\ }
\DoxyCodeLine{01495\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Decrease\ refcount\ twice,\ once\ for\ our\ ref,\ and\ once\ for\ the\ list's\ ref}}
\DoxyCodeLine{01496\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ head-\/>freeListRefs.fetch\_sub(2,\ std::memory\_order\_release);}
\DoxyCodeLine{01497\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ head;}
\DoxyCodeLine{01498\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01499\ }
\DoxyCodeLine{01500\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ OK,\ the\ head\ must\ have\ changed\ on\ us,\ but\ we\ still\ need\ to\ decrease\ the\ refcount\ we\ increased.}}
\DoxyCodeLine{01501\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ we\ don't\ need\ to\ release\ any\ memory\ effects,\ but\ we\ do\ need\ to\ ensure\ that\ the\ reference}}
\DoxyCodeLine{01502\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ count\ decrement\ happens-\/after\ the\ CAS\ on\ the\ head.}}
\DoxyCodeLine{01503\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ refs\ =\ prevHead-\/>freeListRefs.fetch\_sub(1,\ std::memory\_order\_acq\_rel);}
\DoxyCodeLine{01504\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (refs\ ==\ SHOULD\_BE\_ON\_FREELIST\ +\ 1)\ \{}
\DoxyCodeLine{01505\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ add\_knowing\_refcount\_is\_zero(prevHead);}
\DoxyCodeLine{01506\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01507\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01508\ }
\DoxyCodeLine{01509\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01510\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01511\ }
\DoxyCodeLine{01512\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Useful\ for\ traversing\ the\ list\ when\ there's\ no\ contention\ (e.g.\ to\ destroy\ remaining\ nodes)}}
\DoxyCodeLine{01513\ \ \ \ \ \ \ \ \ N*\ head\_unsafe()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ freeListHead.load(std::memory\_order\_relaxed);\ \}}
\DoxyCodeLine{01514\ }
\DoxyCodeLine{01515\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01516\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ add\_knowing\_refcount\_is\_zero(N*\ node)}
\DoxyCodeLine{01517\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01518\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Since\ the\ refcount\ is\ zero,\ and\ nobody\ can\ increase\ it\ once\ it's\ zero\ (except\ us,\ and\ we\ run}}
\DoxyCodeLine{01519\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ only\ one\ copy\ of\ this\ method\ per\ node\ at\ a\ time,\ i.e.\ the\ single\ thread\ case),\ then\ we\ know}}
\DoxyCodeLine{01520\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ we\ can\ safely\ change\ the\ next\ pointer\ of\ the\ node;\ however,\ once\ the\ refcount\ is\ back\ above}}
\DoxyCodeLine{01521\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ zero,\ then\ other\ threads\ could\ increase\ it\ (happens\ under\ heavy\ contention,\ when\ the\ refcount}}
\DoxyCodeLine{01522\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ goes\ to\ zero\ in\ between\ a\ load\ and\ a\ refcount\ increment\ of\ a\ node\ in\ try\_get,\ then\ back\ up\ to}}
\DoxyCodeLine{01523\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ something\ non-\/zero,\ then\ the\ refcount\ increment\ is\ done\ by\ the\ other\ thread)\ -\/-\/\ so,\ if\ the\ CAS}}
\DoxyCodeLine{01524\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ to\ add\ the\ node\ to\ the\ actual\ list\ fails,\ decrease\ the\ refcount\ and\ leave\ the\ add\ operation\ to}}
\DoxyCodeLine{01525\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ next\ thread\ who\ puts\ the\ refcount\ back\ at\ zero\ (which\ could\ be\ us,\ hence\ the\ loop).}}
\DoxyCodeLine{01526\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ head\ =\ freeListHead.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01527\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{01528\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node-\/>freeListNext.store(head,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{01529\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node-\/>freeListRefs.store(1,\ std::memory\_order\_release);}
\DoxyCodeLine{01530\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!freeListHead.compare\_exchange\_strong(head,\ node,\ std::memory\_order\_release,\ std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{01531\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Hmm,\ the\ add\ failed,\ but\ we\ can\ only\ try\ again\ when\ the\ refcount\ goes\ back\ to\ zero}}
\DoxyCodeLine{01532\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node-\/>freeListRefs.fetch\_add(SHOULD\_BE\_ON\_FREELIST\ -\/\ 1,\ std::memory\_order\_release)\ ==\ 1)\ \{}
\DoxyCodeLine{01533\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{01534\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01535\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01536\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{01537\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01538\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01539\ }
\DoxyCodeLine{01540\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01541\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Implemented\ like\ a\ stack,\ but\ where\ node\ order\ doesn't\ matter\ (nodes\ are\ inserted\ out\ of\ order\ under\ contention)}}
\DoxyCodeLine{01542\ \ \ \ \ \ \ \ \ std::atomic<N*>\ freeListHead;}
\DoxyCodeLine{01543\ }
\DoxyCodeLine{01544\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ std::uint32\_t\ REFS\_MASK\ =\ 0x7FFFFFFF;}
\DoxyCodeLine{01545\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ std::uint32\_t\ SHOULD\_BE\_ON\_FREELIST\ =\ 0x80000000;}
\DoxyCodeLine{01546\ }
\DoxyCodeLine{01547\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_FREELIST}}
\DoxyCodeLine{01548\ \ \ \ \ \ \ \ \ debug::DebugMutex\ mutex;}
\DoxyCodeLine{01549\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01550\ \ \ \ \ \};}
\DoxyCodeLine{01551\ }
\DoxyCodeLine{01552\ }
\DoxyCodeLine{01554\ \ \ \ \ \textcolor{comment}{//\ Block}}
\DoxyCodeLine{01556\ }
\DoxyCodeLine{01557\ \ \ \ \ \textcolor{keyword}{enum}\ InnerQueueContext\ \{\ implicit\_context\ =\ 0,\ explicit\_context\ =\ 1\ \};}
\DoxyCodeLine{01558\ }
\DoxyCodeLine{01559\ \ \ \ \ \textcolor{keyword}{struct\ }Block}
\DoxyCodeLine{01560\ \ \ \ \ \{}
\DoxyCodeLine{01561\ \ \ \ \ \ \ \ \ Block()}
\DoxyCodeLine{01562\ \ \ \ \ \ \ \ \ \ \ \ \ :\ next(\textcolor{keyword}{nullptr}),\ elementsCompletelyDequeued(0),\ freeListRefs(0),\ freeListNext(\textcolor{keyword}{nullptr}),\ dynamicallyAllocated(\textcolor{keyword}{true})}
\DoxyCodeLine{01563\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01564\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{01565\ \ \ \ \ \ \ \ \ \ \ \ \ owner\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01566\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01567\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01568\ }
\DoxyCodeLine{01569\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<InnerQueueContext\ context>}
\DoxyCodeLine{01570\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ MOODYCAMEL\_NO\_TSAN\ is\_empty()\textcolor{keyword}{\ const}}
\DoxyCodeLine{01571\ \textcolor{keyword}{\ \ \ \ \ \ \ \ }\{}
\DoxyCodeLine{01572\ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (context\ ==\ explicit\_context\ \&\&\ BLOCK\_SIZE\ <=\ EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD)\ \{}
\DoxyCodeLine{01573\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Check\ flags}}
\DoxyCodeLine{01574\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ BLOCK\_SIZE;\ ++i)\ \{}
\DoxyCodeLine{01575\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!emptyFlags[i].load(std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{01576\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01577\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01578\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01579\ }
\DoxyCodeLine{01580\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Aha,\ empty;\ make\ sure\ we\ have\ all\ other\ memory\ effects\ that\ happened\ before\ the\ empty\ flags\ were\ set}}
\DoxyCodeLine{01581\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic\_thread\_fence(std::memory\_order\_acquire);}
\DoxyCodeLine{01582\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01583\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01584\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01585\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Check\ counter}}
\DoxyCodeLine{01586\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (elementsCompletelyDequeued.load(std::memory\_order\_relaxed)\ ==\ BLOCK\_SIZE)\ \{}
\DoxyCodeLine{01587\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic\_thread\_fence(std::memory\_order\_acquire);}
\DoxyCodeLine{01588\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01589\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01590\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(elementsCompletelyDequeued.load(std::memory\_order\_relaxed)\ <=\ BLOCK\_SIZE);}
\DoxyCodeLine{01591\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01592\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01593\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01594\ }
\DoxyCodeLine{01595\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Returns\ true\ if\ the\ block\ is\ now\ empty\ (does\ not\ apply\ in\ explicit\ context)}}
\DoxyCodeLine{01596\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<InnerQueueContext\ context>}
\DoxyCodeLine{01597\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ set\_empty(MOODYCAMEL\_MAYBE\_UNUSED\ index\_t\ i)}
\DoxyCodeLine{01598\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01599\ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (context\ ==\ explicit\_context\ \&\&\ BLOCK\_SIZE\ <=\ EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD)\ \{}
\DoxyCodeLine{01600\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Set\ flag}}
\DoxyCodeLine{01601\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(!emptyFlags[BLOCK\_SIZE\ -\/\ 1\ -\/\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(i\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))].load(std::memory\_order\_relaxed));}
\DoxyCodeLine{01602\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ emptyFlags[BLOCK\_SIZE\ -\/\ 1\ -\/\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(i\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))].store(\textcolor{keyword}{true},\ std::memory\_order\_release);}
\DoxyCodeLine{01603\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01604\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01605\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01606\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Increment\ counter}}
\DoxyCodeLine{01607\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prevVal\ =\ elementsCompletelyDequeued.fetch\_add(1,\ std::memory\_order\_release);}
\DoxyCodeLine{01608\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(prevVal\ <\ BLOCK\_SIZE);}
\DoxyCodeLine{01609\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ prevVal\ ==\ BLOCK\_SIZE\ -\/\ 1;}
\DoxyCodeLine{01610\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01611\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01612\ }
\DoxyCodeLine{01613\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Sets\ multiple\ contiguous\ item\ statuses\ to\ 'empty'\ (assumes\ no\ wrapping\ and\ count\ >\ 0).}}
\DoxyCodeLine{01614\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Returns\ true\ if\ the\ block\ is\ now\ empty\ (does\ not\ apply\ in\ explicit\ context).}}
\DoxyCodeLine{01615\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<InnerQueueContext\ context>}
\DoxyCodeLine{01616\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ MOODYCAMEL\_NO\_TSAN\ set\_many\_empty(MOODYCAMEL\_MAYBE\_UNUSED\ index\_t\ i,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{01617\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01618\ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (context\ ==\ explicit\_context\ \&\&\ BLOCK\_SIZE\ <=\ EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD)\ \{}
\DoxyCodeLine{01619\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Set\ flags}}
\DoxyCodeLine{01620\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic\_thread\_fence(std::memory\_order\_release);}
\DoxyCodeLine{01621\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i\ =\ BLOCK\_SIZE\ -\/\ 1\ -\/\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(i\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ -\/\ count\ +\ 1;}
\DoxyCodeLine{01622\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ j\ =\ 0;\ j\ !=\ count;\ ++j)\ \{}
\DoxyCodeLine{01623\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(!emptyFlags[i\ +\ j].load(std::memory\_order\_relaxed));}
\DoxyCodeLine{01624\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ emptyFlags[i\ +\ j].store(\textcolor{keyword}{true},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{01625\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01626\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01627\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01628\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01629\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Increment\ counter}}
\DoxyCodeLine{01630\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prevVal\ =\ elementsCompletelyDequeued.fetch\_add(count,\ std::memory\_order\_release);}
\DoxyCodeLine{01631\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(prevVal\ +\ count\ <=\ BLOCK\_SIZE);}
\DoxyCodeLine{01632\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ prevVal\ +\ count\ ==\ BLOCK\_SIZE;}
\DoxyCodeLine{01633\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01634\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01635\ }
\DoxyCodeLine{01636\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<InnerQueueContext\ context>}
\DoxyCodeLine{01637\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ set\_all\_empty()}
\DoxyCodeLine{01638\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01639\ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (context\ ==\ explicit\_context\ \&\&\ BLOCK\_SIZE\ <=\ EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD)\ \{}
\DoxyCodeLine{01640\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Set\ all\ flags}}
\DoxyCodeLine{01641\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ BLOCK\_SIZE;\ ++i)\ \{}
\DoxyCodeLine{01642\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ emptyFlags[i].store(\textcolor{keyword}{true},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{01643\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01644\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01645\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01646\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Reset\ counter}}
\DoxyCodeLine{01647\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ elementsCompletelyDequeued.store(BLOCK\_SIZE,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{01648\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01649\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01650\ }
\DoxyCodeLine{01651\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<InnerQueueContext\ context>}
\DoxyCodeLine{01652\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ reset\_empty()}
\DoxyCodeLine{01653\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01654\ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (context\ ==\ explicit\_context\ \&\&\ BLOCK\_SIZE\ <=\ EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD)\ \{}
\DoxyCodeLine{01655\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Reset\ flags}}
\DoxyCodeLine{01656\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ BLOCK\_SIZE;\ ++i)\ \{}
\DoxyCodeLine{01657\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ emptyFlags[i].store(\textcolor{keyword}{false},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{01658\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01659\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01660\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01661\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Reset\ counter}}
\DoxyCodeLine{01662\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ elementsCompletelyDequeued.store(0,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{01663\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01664\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01665\ }
\DoxyCodeLine{01666\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ T*\ operator[](index\_t\ idx)\ MOODYCAMEL\_NOEXCEPT\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(elements))\ +\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(idx\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1));\ \}}
\DoxyCodeLine{01667\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ T\ \textcolor{keyword}{const}*\ operator[](index\_t\ idx)\ \textcolor{keyword}{const}\ MOODYCAMEL\_NOEXCEPT\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}T\ const*\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\ const*\textcolor{keyword}{>}(elements))\ +\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(idx\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1));\ \}}
\DoxyCodeLine{01668\ }
\DoxyCodeLine{01669\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01670\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(std::alignment\_of<T>::value\ <=\ \textcolor{keyword}{sizeof}(T),\ \textcolor{stringliteral}{"{}The\ queue\ does\ not\ support\ types\ with\ an\ alignment\ greater\ than\ their\ size\ at\ this\ time"{}});}
\DoxyCodeLine{01671\ \ \ \ \ \ \ \ \ MOODYCAMEL\_ALIGNED\_TYPE\_LIKE(\textcolor{keywordtype}{char}[\textcolor{keyword}{sizeof}(T)\ *\ BLOCK\_SIZE],\ T)\ elements;}
\DoxyCodeLine{01672\ \ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01673\ \ \ \ \ \ \ \ \ Block*\ next;}
\DoxyCodeLine{01674\ \ \ \ \ \ \ \ \ std::atomic<size\_t>\ elementsCompletelyDequeued;}
\DoxyCodeLine{01675\ \ \ \ \ \ \ \ \ std::atomic<bool>\ emptyFlags[BLOCK\_SIZE\ <=\ EXPLICIT\_BLOCK\_EMPTY\_COUNTER\_THRESHOLD\ ?\ BLOCK\_SIZE\ :\ 1];}
\DoxyCodeLine{01676\ \ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01677\ \ \ \ \ \ \ \ \ std::atomic<std::uint32\_t>\ freeListRefs;}
\DoxyCodeLine{01678\ \ \ \ \ \ \ \ \ std::atomic<Block*>\ freeListNext;}
\DoxyCodeLine{01679\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ dynamicallyAllocated;\ \ \ \ \ \ \textcolor{comment}{//\ Perhaps\ a\ better\ name\ for\ this\ would\ be\ 'isNotPartOfInitialBlockPool'}}
\DoxyCodeLine{01680\ }
\DoxyCodeLine{01681\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{01682\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}*\ owner;}
\DoxyCodeLine{01683\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01684\ \ \ \ \ \};}
\DoxyCodeLine{01685\ \ \ \ \ \textcolor{keyword}{static\_assert}(std::alignment\_of<Block>::value\ >=\ std::alignment\_of<T>::value,\ \textcolor{stringliteral}{"{}Internal\ error:\ Blocks\ must\ be\ at\ least\ as\ aligned\ as\ the\ type\ they\ are\ wrapping"{}});}
\DoxyCodeLine{01686\ }
\DoxyCodeLine{01687\ }
\DoxyCodeLine{01688\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{01689\ \textcolor{keyword}{public}:}
\DoxyCodeLine{01690\ \ \ \ \ \textcolor{keyword}{struct\ }MemStats;}
\DoxyCodeLine{01691\ \textcolor{keyword}{private}:}
\DoxyCodeLine{01692\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01693\ }
\DoxyCodeLine{01695\ \ \ \ \ \textcolor{comment}{//\ Producer\ base}}
\DoxyCodeLine{01697\ }
\DoxyCodeLine{01698\ \ \ \ \ \textcolor{keyword}{struct\ }ProducerBase\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{structmoodycamel_1_1details_1_1ConcurrentQueueProducerTypelessBase}{details::ConcurrentQueueProducerTypelessBase}}}
\DoxyCodeLine{01699\ \ \ \ \ \{}
\DoxyCodeLine{01700\ \ \ \ \ \ \ \ \ ProducerBase(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}*\ parent\_,\ \textcolor{keywordtype}{bool}\ isExplicit\_)\ :}
\DoxyCodeLine{01701\ \ \ \ \ \ \ \ \ \ \ \ \ tailIndex(0),}
\DoxyCodeLine{01702\ \ \ \ \ \ \ \ \ \ \ \ \ headIndex(0),}
\DoxyCodeLine{01703\ \ \ \ \ \ \ \ \ \ \ \ \ dequeueOptimisticCount(0),}
\DoxyCodeLine{01704\ \ \ \ \ \ \ \ \ \ \ \ \ dequeueOvercommit(0),}
\DoxyCodeLine{01705\ \ \ \ \ \ \ \ \ \ \ \ \ tailBlock(\textcolor{keyword}{nullptr}),}
\DoxyCodeLine{01706\ \ \ \ \ \ \ \ \ \ \ \ \ isExplicit(isExplicit\_),}
\DoxyCodeLine{01707\ \ \ \ \ \ \ \ \ \ \ \ \ parent(parent\_)}
\DoxyCodeLine{01708\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01709\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01710\ }
\DoxyCodeLine{01711\ \ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \string~ProducerBase()\ \{\ \}}
\DoxyCodeLine{01712\ }
\DoxyCodeLine{01713\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01714\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ dequeue(U\&\ element)}
\DoxyCodeLine{01715\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01716\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (isExplicit)\ \{}
\DoxyCodeLine{01717\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}ExplicitProducer*\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>dequeue(element);}
\DoxyCodeLine{01718\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01719\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01720\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}ImplicitProducer*\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>dequeue(element);}
\DoxyCodeLine{01721\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01722\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01723\ }
\DoxyCodeLine{01724\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{01725\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{size\_t}\ dequeue\_bulk(It\&\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ max)}
\DoxyCodeLine{01726\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01727\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (isExplicit)\ \{}
\DoxyCodeLine{01728\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}ExplicitProducer*\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>dequeue\_bulk(itemFirst,\ max);}
\DoxyCodeLine{01729\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01730\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01731\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}ImplicitProducer*\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>dequeue\_bulk(itemFirst,\ max);}
\DoxyCodeLine{01732\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01733\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01734\ }
\DoxyCodeLine{01735\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ ProducerBase*\ next\_prod()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}ProducerBase*\textcolor{keyword}{>}(next);\ \}}
\DoxyCodeLine{01736\ }
\DoxyCodeLine{01737\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{size\_t}\ size\_approx()\textcolor{keyword}{\ const}}
\DoxyCodeLine{01738\ \textcolor{keyword}{\ \ \ \ \ \ \ \ }\{}
\DoxyCodeLine{01739\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tail\ =\ tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01740\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ head\ =\ headIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01741\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ details::circular\_less\_than(head,\ tail)\ ?\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(tail\ -\/\ head)\ :\ 0;}
\DoxyCodeLine{01742\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01743\ }
\DoxyCodeLine{01744\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ index\_t\ getTail()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ tailIndex.load(std::memory\_order\_relaxed);\ \}}
\DoxyCodeLine{01745\ \ \ \ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{01746\ \ \ \ \ \ \ \ \ std::atomic<index\_t>\ tailIndex;\ \ \ \ \ \textcolor{comment}{//\ Where\ to\ enqueue\ to\ next}}
\DoxyCodeLine{01747\ \ \ \ \ \ \ \ \ std::atomic<index\_t>\ headIndex;\ \ \ \ \ \textcolor{comment}{//\ Where\ to\ dequeue\ from\ next}}
\DoxyCodeLine{01748\ }
\DoxyCodeLine{01749\ \ \ \ \ \ \ \ \ std::atomic<index\_t>\ dequeueOptimisticCount;}
\DoxyCodeLine{01750\ \ \ \ \ \ \ \ \ std::atomic<index\_t>\ dequeueOvercommit;}
\DoxyCodeLine{01751\ }
\DoxyCodeLine{01752\ \ \ \ \ \ \ \ \ Block*\ tailBlock;}
\DoxyCodeLine{01753\ }
\DoxyCodeLine{01754\ \ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01755\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ isExplicit;}
\DoxyCodeLine{01756\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}*\ parent;}
\DoxyCodeLine{01757\ }
\DoxyCodeLine{01758\ \ \ \ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{01759\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{01760\ \ \ \ \ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{struct\ }MemStats;}
\DoxyCodeLine{01761\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01762\ \ \ \ \ \};}
\DoxyCodeLine{01763\ }
\DoxyCodeLine{01764\ }
\DoxyCodeLine{01766\ \ \ \ \ \textcolor{comment}{//\ Explicit\ queue}}
\DoxyCodeLine{01768\ }
\DoxyCodeLine{01769\ \ \ \ \ \textcolor{keyword}{struct\ }ExplicitProducer\ :\ \textcolor{keyword}{public}\ ProducerBase}
\DoxyCodeLine{01770\ \ \ \ \ \{}
\DoxyCodeLine{01771\ \ \ \ \ \ \ \ \ \textcolor{keyword}{explicit}\ ExplicitProducer(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}*\ parent\_)\ :}
\DoxyCodeLine{01772\ \ \ \ \ \ \ \ \ \ \ \ \ ProducerBase(parent\_,\ \textcolor{keyword}{true}),}
\DoxyCodeLine{01773\ \ \ \ \ \ \ \ \ \ \ \ \ blockIndex(\textcolor{keyword}{nullptr}),}
\DoxyCodeLine{01774\ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexSlotsUsed(0),}
\DoxyCodeLine{01775\ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexSize(EXPLICIT\_INITIAL\_INDEX\_SIZE\ >>\ 1),}
\DoxyCodeLine{01776\ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexFront(0),}
\DoxyCodeLine{01777\ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexEntries(\textcolor{keyword}{nullptr}),}
\DoxyCodeLine{01778\ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexRaw(\textcolor{keyword}{nullptr})}
\DoxyCodeLine{01779\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01780\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ poolBasedIndexSize\ =\ details::ceil\_to\_pow\_2(parent\_-\/>initialBlockPoolSize)\ >>\ 1;}
\DoxyCodeLine{01781\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (poolBasedIndexSize\ >\ pr\_blockIndexSize)\ \{}
\DoxyCodeLine{01782\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexSize\ =\ poolBasedIndexSize;}
\DoxyCodeLine{01783\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01784\ }
\DoxyCodeLine{01785\ \ \ \ \ \ \ \ \ \ \ \ \ new\_block\_index(0);\ \ \ \ \ \textcolor{comment}{//\ This\ creates\ an\ index\ with\ double\ the\ number\ of\ current\ entries,\ i.e.\ EXPLICIT\_INITIAL\_INDEX\_SIZE}}
\DoxyCodeLine{01786\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01787\ }
\DoxyCodeLine{01788\ \ \ \ \ \ \ \ \ \string~ExplicitProducer()}
\DoxyCodeLine{01789\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01790\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Destruct\ any\ elements\ not\ yet\ dequeued.}}
\DoxyCodeLine{01791\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Since\ we're\ in\ the\ destructor,\ we\ can\ assume\ all\ elements}}
\DoxyCodeLine{01792\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ are\ either\ completely\ dequeued\ or\ completely\ not\ (no\ halfways).}}
\DoxyCodeLine{01793\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (this-\/>tailBlock\ !=\ \textcolor{keyword}{nullptr})\ \{\ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ this\ means\ there\ must\ be\ a\ block\ index\ too}}
\DoxyCodeLine{01794\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ First\ find\ the\ block\ that's\ partially\ dequeued,\ if\ any}}
\DoxyCodeLine{01795\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Block*\ halfDequeuedBlock\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01796\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((this-\/>headIndex.load(std::memory\_order\_relaxed)\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ !=\ 0)\ \{}
\DoxyCodeLine{01797\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ head's\ not\ on\ a\ block\ boundary,\ meaning\ a\ block\ somewhere\ is\ partially\ dequeued}}
\DoxyCodeLine{01798\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ (or\ the\ head\ block\ is\ the\ tail\ block\ and\ was\ fully\ dequeued,\ but\ the\ head/tail\ are\ still\ not\ on\ a\ boundary)}}
\DoxyCodeLine{01799\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ i\ =\ (pr\_blockIndexFront\ -\/\ pr\_blockIndexSlotsUsed)\ \&\ (pr\_blockIndexSize\ -\/\ 1);}
\DoxyCodeLine{01800\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (details::circular\_less\_than<index\_t>(pr\_blockIndexEntries[i].base\ +\ BLOCK\_SIZE,\ this-\/>headIndex.load(std::memory\_order\_relaxed)))\ \{}
\DoxyCodeLine{01801\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i\ =\ (i\ +\ 1)\ \&\ (pr\_blockIndexSize\ -\/\ 1);}
\DoxyCodeLine{01802\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01803\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(details::circular\_less\_than<index\_t>(pr\_blockIndexEntries[i].base,\ this-\/>headIndex.load(std::memory\_order\_relaxed)));}
\DoxyCodeLine{01804\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ halfDequeuedBlock\ =\ pr\_blockIndexEntries[i].block;}
\DoxyCodeLine{01805\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01806\ }
\DoxyCodeLine{01807\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Start\ at\ the\ head\ block\ (note\ the\ first\ line\ in\ the\ loop\ gives\ us\ the\ head\ from\ the\ tail\ on\ the\ first\ iteration)}}
\DoxyCodeLine{01808\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ this-\/>tailBlock;}
\DoxyCodeLine{01809\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{01810\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ block-\/>next;}
\DoxyCodeLine{01811\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block-\/>ConcurrentQueue::Block::template\ is\_empty<explicit\_context>())\ \{}
\DoxyCodeLine{01812\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{01813\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01814\ }
\DoxyCodeLine{01815\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ \ \ \textcolor{comment}{//\ Offset\ into\ block}}
\DoxyCodeLine{01816\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block\ ==\ halfDequeuedBlock)\ \{}
\DoxyCodeLine{01817\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(this-\/>headIndex.load(std::memory\_order\_relaxed)\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1));}
\DoxyCodeLine{01818\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01819\ }
\DoxyCodeLine{01820\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Walk\ through\ all\ the\ items\ in\ the\ block;\ if\ this\ is\ the\ tail\ block,\ we\ need\ to\ stop\ when\ we\ reach\ the\ tail\ index}}
\DoxyCodeLine{01821\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ lastValidIndex\ =\ (this-\/>tailIndex.load(std::memory\_order\_relaxed)\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ ==\ 0\ ?\ BLOCK\_SIZE\ :\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(this-\/>tailIndex.load(std::memory\_order\_relaxed)\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1));}
\DoxyCodeLine{01822\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (i\ !=\ BLOCK\_SIZE\ \&\&\ (block\ !=\ this-\/>tailBlock\ ||\ i\ !=\ lastValidIndex))\ \{}
\DoxyCodeLine{01823\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (*block)[i++]-\/>\string~T();}
\DoxyCodeLine{01824\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01825\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (block\ !=\ this-\/>tailBlock);}
\DoxyCodeLine{01826\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01827\ }
\DoxyCodeLine{01828\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Destroy\ all\ blocks\ that\ we\ own}}
\DoxyCodeLine{01829\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (this-\/>tailBlock\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01830\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ this-\/>tailBlock;}
\DoxyCodeLine{01831\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{01832\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ nextBlock\ =\ block-\/>next;}
\DoxyCodeLine{01833\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>parent-\/>add\_block\_to\_free\_list(block);}
\DoxyCodeLine{01834\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ nextBlock;}
\DoxyCodeLine{01835\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (block\ !=\ this-\/>tailBlock);}
\DoxyCodeLine{01836\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01837\ }
\DoxyCodeLine{01838\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Destroy\ the\ block\ indices}}
\DoxyCodeLine{01839\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ header\ =\ \textcolor{keyword}{static\_cast<}BlockIndexHeader*\textcolor{keyword}{>}(pr\_blockIndexRaw);}
\DoxyCodeLine{01840\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (header\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01841\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prev\ =\ \textcolor{keyword}{static\_cast<}BlockIndexHeader*\textcolor{keyword}{>}(header-\/>prev);}
\DoxyCodeLine{01842\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ header-\/>\string~BlockIndexHeader();}
\DoxyCodeLine{01843\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (Traits::free)(header);}
\DoxyCodeLine{01844\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ header\ =\ prev;}
\DoxyCodeLine{01845\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01846\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01847\ }
\DoxyCodeLine{01848\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<AllocationMode\ allocMode,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01849\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ enqueue(U\&\&\ element)}
\DoxyCodeLine{01850\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01851\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ currentTailIndex\ =\ this-\/>tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01852\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ newTailIndex\ =\ 1\ +\ currentTailIndex;}
\DoxyCodeLine{01853\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((currentTailIndex\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ ==\ 0)\ \{}
\DoxyCodeLine{01854\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ reached\ the\ end\ of\ a\ block,\ start\ a\ new\ one}}
\DoxyCodeLine{01855\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ startBlock\ =\ this-\/>tailBlock;}
\DoxyCodeLine{01856\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ originalBlockIndexSlotsUsed\ =\ pr\_blockIndexSlotsUsed;}
\DoxyCodeLine{01857\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (this-\/>tailBlock\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ this-\/>tailBlock-\/>next-\/>ConcurrentQueue::Block::template\ is\_empty<explicit\_context>())\ \{}
\DoxyCodeLine{01858\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ can\ re-\/use\ the\ block\ ahead\ of\ us,\ it's\ empty!}}
\DoxyCodeLine{01859\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ this-\/>tailBlock-\/>next;}
\DoxyCodeLine{01860\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock-\/>ConcurrentQueue::Block::template\ reset\_empty<explicit\_context>();}
\DoxyCodeLine{01861\ }
\DoxyCodeLine{01862\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We'll\ put\ the\ block\ on\ the\ block\ index\ (guaranteed\ to\ be\ room\ since\ we're\ conceptually\ removing\ the}}
\DoxyCodeLine{01863\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ last\ block\ from\ it\ first\ -\/-\/\ except\ instead\ of\ removing\ then\ adding,\ we\ can\ just\ overwrite).}}
\DoxyCodeLine{01864\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ there\ must\ be\ a\ valid\ block\ index\ here,\ since\ even\ if\ allocation\ failed\ in\ the\ ctor,}}
\DoxyCodeLine{01865\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ it\ would\ have\ been\ re-\/attempted\ when\ adding\ the\ first\ block\ to\ the\ queue;\ since\ there\ is\ such}}
\DoxyCodeLine{01866\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ a\ block,\ a\ block\ index\ must\ have\ been\ successfully\ allocated.}}
\DoxyCodeLine{01867\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01868\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01869\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Whatever\ head\ value\ we\ see\ here\ is\ >=\ the\ last\ value\ we\ saw\ here\ (relatively),}}
\DoxyCodeLine{01870\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ and\ <=\ its\ current\ value.\ Since\ we\ have\ the\ most\ recent\ tail,\ the\ head\ must\ be}}
\DoxyCodeLine{01871\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ <=\ to\ it.}}
\DoxyCodeLine{01872\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ head\ =\ this-\/>headIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01873\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(!details::circular\_less\_than<index\_t>(currentTailIndex,\ head));}
\DoxyCodeLine{01874\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!details::circular\_less\_than<index\_t>(head,\ currentTailIndex\ +\ BLOCK\_SIZE)}
\DoxyCodeLine{01875\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ||\ (MAX\_SUBQUEUE\_SIZE\ !=\ \mbox{\hyperlink{structmoodycamel_1_1details_1_1const__numeric__max}{details::const\_numeric\_max<size\_t>::value}}\ \&\&\ (MAX\_SUBQUEUE\_SIZE\ ==\ 0\ ||\ MAX\_SUBQUEUE\_SIZE\ -\/\ BLOCK\_SIZE\ <\ currentTailIndex\ -\/\ head)))\ \{}
\DoxyCodeLine{01876\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ can't\ enqueue\ in\ another\ block\ because\ there's\ not\ enough\ leeway\ -\/-\/\ the}}
\DoxyCodeLine{01877\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ tail\ could\ surpass\ the\ head\ by\ the\ time\ the\ block\ fills\ up!\ (Or\ we'll\ exceed}}
\DoxyCodeLine{01878\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ size\ limit,\ if\ the\ second\ part\ of\ the\ condition\ was\ true.)}}
\DoxyCodeLine{01879\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01880\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01881\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We're\ going\ to\ need\ a\ new\ block;\ check\ that\ the\ block\ index\ has\ room}}
\DoxyCodeLine{01882\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (pr\_blockIndexRaw\ ==\ \textcolor{keyword}{nullptr}\ ||\ pr\_blockIndexSlotsUsed\ ==\ pr\_blockIndexSize)\ \{}
\DoxyCodeLine{01883\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Hmm,\ the\ circular\ block\ index\ is\ already\ full\ -\/-\/\ we'll\ need}}
\DoxyCodeLine{01884\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ to\ allocate\ a\ new\ index.\ Note\ pr\_blockIndexRaw\ can\ only\ be\ nullptr\ if}}
\DoxyCodeLine{01885\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ initial\ allocation\ failed\ in\ the\ constructor.}}
\DoxyCodeLine{01886\ }
\DoxyCodeLine{01887\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (allocMode\ ==\ CannotAlloc)\ \{}
\DoxyCodeLine{01888\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01889\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01890\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (!new\_block\_index(pr\_blockIndexSlotsUsed))\ \{}
\DoxyCodeLine{01891\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01892\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01893\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01894\ }
\DoxyCodeLine{01895\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Insert\ a\ new\ block\ in\ the\ circular\ linked\ list}}
\DoxyCodeLine{01896\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ newBlock\ =\ this-\/>parent-\/>ConcurrentQueue::template\ requisition\_block<allocMode>();}
\DoxyCodeLine{01897\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (newBlock\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01898\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01899\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01900\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{01901\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>owner\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{01902\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01903\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>ConcurrentQueue::Block::template\ reset\_empty<explicit\_context>();}
\DoxyCodeLine{01904\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (this-\/>tailBlock\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01905\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>next\ =\ newBlock;}
\DoxyCodeLine{01906\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01907\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01908\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>next\ =\ this-\/>tailBlock-\/>next;}
\DoxyCodeLine{01909\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock-\/>next\ =\ newBlock;}
\DoxyCodeLine{01910\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01911\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ newBlock;}
\DoxyCodeLine{01912\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++pr\_blockIndexSlotsUsed;}
\DoxyCodeLine{01913\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01914\ }
\DoxyCodeLine{01915\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (!MOODYCAMEL\_NOEXCEPT\_CTOR(T,\ U,\ \textcolor{keyword}{new}\ (\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}))\ T(std::forward<U>(element))))\ \{}
\DoxyCodeLine{01916\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ constructor\ may\ throw.\ We\ want\ the\ element\ not\ to\ appear\ in\ the\ queue\ in}}
\DoxyCodeLine{01917\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ that\ case\ (without\ corrupting\ the\ queue):}}
\DoxyCodeLine{01918\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_TRY\ \{}
\DoxyCodeLine{01919\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ ((*this-\/>tailBlock)[currentTailIndex])\ T(std::forward<U>(element));}
\DoxyCodeLine{01920\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01921\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CATCH\ (...)\ \{}
\DoxyCodeLine{01922\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Revert\ change\ to\ the\ current\ block,\ but\ leave\ the\ new\ block\ available}}
\DoxyCodeLine{01923\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ for\ next\ time}}
\DoxyCodeLine{01924\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexSlotsUsed\ =\ originalBlockIndexSlotsUsed;}
\DoxyCodeLine{01925\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ startBlock\ ==\ \textcolor{keyword}{nullptr}\ ?\ this-\/>tailBlock\ :\ startBlock;}
\DoxyCodeLine{01926\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_RETHROW;}
\DoxyCodeLine{01927\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01928\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01929\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01930\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)startBlock;}
\DoxyCodeLine{01931\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)originalBlockIndexSlotsUsed;}
\DoxyCodeLine{01932\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01933\ }
\DoxyCodeLine{01934\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Add\ block\ to\ block\ index}}
\DoxyCodeLine{01935\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ entry\ =\ blockIndex.load(std::memory\_order\_relaxed)-\/>entries[pr\_blockIndexFront];}
\DoxyCodeLine{01936\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry.base\ =\ currentTailIndex;}
\DoxyCodeLine{01937\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry.block\ =\ this-\/>tailBlock;}
\DoxyCodeLine{01938\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ blockIndex.load(std::memory\_order\_relaxed)-\/>front.store(pr\_blockIndexFront,\ std::memory\_order\_release);}
\DoxyCodeLine{01939\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexFront\ =\ (pr\_blockIndexFront\ +\ 1)\ \&\ (pr\_blockIndexSize\ -\/\ 1);}
\DoxyCodeLine{01940\ }
\DoxyCodeLine{01941\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (!MOODYCAMEL\_NOEXCEPT\_CTOR(T,\ U,\ \textcolor{keyword}{new}\ (\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}))\ T(std::forward<U>(element))))\ \{}
\DoxyCodeLine{01942\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailIndex.store(newTailIndex,\ std::memory\_order\_release);}
\DoxyCodeLine{01943\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01944\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01945\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01946\ }
\DoxyCodeLine{01947\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Enqueue}}
\DoxyCodeLine{01948\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ ((*this-\/>tailBlock)[currentTailIndex])\ T(std::forward<U>(element));}
\DoxyCodeLine{01949\ }
\DoxyCodeLine{01950\ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailIndex.store(newTailIndex,\ std::memory\_order\_release);}
\DoxyCodeLine{01951\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01952\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01953\ }
\DoxyCodeLine{01954\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01955\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ MOODYCAMEL\_NO\_TSAN\ dequeue(U\&\ element)}
\DoxyCodeLine{01956\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{01957\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tail\ =\ this-\/>tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01958\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ overcommit\ =\ this-\/>dequeueOvercommit.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{01959\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (details::circular\_less\_than<index\_t>(this-\/>dequeueOptimisticCount.load(std::memory\_order\_relaxed)\ -\/\ overcommit,\ tail))\ \{}
\DoxyCodeLine{01960\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Might\ be\ something\ to\ dequeue,\ let's\ give\ it\ a\ try}}
\DoxyCodeLine{01961\ }
\DoxyCodeLine{01962\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ this\ if\ is\ purely\ for\ performance\ purposes\ in\ the\ common\ case\ when\ the\ queue\ is}}
\DoxyCodeLine{01963\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ empty\ and\ the\ values\ are\ eventually\ consistent\ -\/-\/\ we\ may\ enter\ here\ spuriously.}}
\DoxyCodeLine{01964\ }
\DoxyCodeLine{01965\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ whatever\ the\ values\ of\ overcommit\ and\ tail\ are,\ they\ are\ not\ going\ to\ change\ (unless\ we}}
\DoxyCodeLine{01966\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ change\ them)\ and\ must\ be\ the\ same\ value\ at\ this\ point\ (inside\ the\ if)\ as\ when\ the\ if\ condition\ was}}
\DoxyCodeLine{01967\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ evaluated.}}
\DoxyCodeLine{01968\ }
\DoxyCodeLine{01969\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ insert\ an\ acquire\ fence\ here\ to\ synchronize-\/with\ the\ release\ upon\ incrementing\ dequeueOvercommit\ below.}}
\DoxyCodeLine{01970\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ This\ ensures\ that\ whatever\ the\ value\ we\ got\ loaded\ into\ overcommit,\ the\ load\ of\ dequeueOptisticCount\ in}}
\DoxyCodeLine{01971\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ fetch\_add\ below\ will\ result\ in\ a\ value\ at\ least\ as\ recent\ as\ that\ (and\ therefore\ at\ least\ as\ large).}}
\DoxyCodeLine{01972\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ I\ believe\ a\ compiler\ (signal)\ fence\ here\ would\ be\ sufficient\ due\ to\ the\ nature\ of\ fetch\_add\ (all}}
\DoxyCodeLine{01973\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ read-\/modify-\/write\ operations\ are\ guaranteed\ to\ work\ on\ the\ latest\ value\ in\ the\ modification\ order),\ but}}
\DoxyCodeLine{01974\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ unfortunately\ that\ can't\ be\ shown\ to\ be\ correct\ using\ only\ the\ C++11\ standard.}}
\DoxyCodeLine{01975\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ See\ http://stackoverflow.com/questions/18223161/what-\/are-\/the-\/c11-\/memory-\/ordering-\/guarantees-\/in-\/this-\/corner-\/case}}
\DoxyCodeLine{01976\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic\_thread\_fence(std::memory\_order\_acquire);}
\DoxyCodeLine{01977\ }
\DoxyCodeLine{01978\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Increment\ optimistic\ counter,\ then\ check\ if\ it\ went\ over\ the\ boundary}}
\DoxyCodeLine{01979\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ myDequeueCount\ =\ this-\/>dequeueOptimisticCount.fetch\_add(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{01980\ }
\DoxyCodeLine{01981\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ since\ dequeueOvercommit\ must\ be\ <=\ dequeueOptimisticCount\ (because\ dequeueOvercommit\ is\ only\ ever}}
\DoxyCodeLine{01982\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ incremented\ after\ dequeueOptimisticCount\ -\/-\/\ this\ is\ enforced\ in\ the\ \`{}else`\ block\ below),\ and\ since\ we\ now}}
\DoxyCodeLine{01983\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ have\ a\ version\ of\ dequeueOptimisticCount\ that\ is\ at\ least\ as\ recent\ as\ overcommit\ (due\ to\ the\ release\ upon}}
\DoxyCodeLine{01984\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ incrementing\ dequeueOvercommit\ and\ the\ acquire\ above\ that\ synchronizes\ with\ it),\ overcommit\ <=\ myDequeueCount.}}
\DoxyCodeLine{01985\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ However,\ we\ can't\ assert\ this\ since\ both\ dequeueOptimisticCount\ and\ dequeueOvercommit\ may\ (independently)}}
\DoxyCodeLine{01986\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ overflow;\ in\ such\ a\ case,\ though,\ the\ logic\ still\ holds\ since\ the\ difference\ between\ the\ two\ is\ maintained.}}
\DoxyCodeLine{01987\ }
\DoxyCodeLine{01988\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ we\ reload\ tail\ here\ in\ case\ it\ changed;\ it\ will\ be\ the\ same\ value\ as\ before\ or\ greater,\ since}}
\DoxyCodeLine{01989\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ this\ load\ is\ sequenced\ after\ (happens\ after)\ the\ earlier\ load\ above.\ This\ is\ supported\ by\ read-\/read}}
\DoxyCodeLine{01990\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ coherency\ (as\ defined\ in\ the\ standard),\ explained\ here:\ http://en.cppreference.com/w/cpp/atomic/memory\_order}}
\DoxyCodeLine{01991\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tail\ =\ this-\/>tailIndex.load(std::memory\_order\_acquire);}
\DoxyCodeLine{01992\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((details::likely)(details::circular\_less\_than<index\_t>(myDequeueCount\ -\/\ overcommit,\ tail)))\ \{}
\DoxyCodeLine{01993\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Guaranteed\ to\ be\ at\ least\ one\ element\ to\ dequeue!}}
\DoxyCodeLine{01994\ }
\DoxyCodeLine{01995\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ the\ index.\ Note\ that\ since\ there's\ guaranteed\ to\ be\ at\ least\ one\ element,\ this}}
\DoxyCodeLine{01996\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ will\ never\ exceed\ tail.\ We\ need\ to\ do\ an\ acquire-\/release\ fence\ here\ since\ it's\ possible}}
\DoxyCodeLine{01997\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ that\ whatever\ condition\ got\ us\ to\ this\ point\ was\ for\ an\ earlier\ enqueued\ element\ (that}}
\DoxyCodeLine{01998\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ we\ already\ see\ the\ memory\ effects\ for),\ but\ that\ by\ the\ time\ we\ increment\ somebody\ else}}
\DoxyCodeLine{01999\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ has\ incremented\ it,\ and\ we\ need\ to\ see\ the\ memory\ effects\ for\ *that*\ element,\ which\ is}}
\DoxyCodeLine{02000\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ in\ such\ a\ case\ is\ necessarily\ visible\ on\ the\ thread\ that\ incremented\ it\ in\ the\ first}}
\DoxyCodeLine{02001\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ place\ with\ the\ more\ current\ condition\ (they\ must\ have\ acquired\ a\ tail\ that\ is\ at\ least}}
\DoxyCodeLine{02002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ as\ recent).}}
\DoxyCodeLine{02003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ index\ =\ this-\/>headIndex.fetch\_add(1,\ std::memory\_order\_acq\_rel);}
\DoxyCodeLine{02004\ }
\DoxyCodeLine{02005\ }
\DoxyCodeLine{02006\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Determine\ which\ block\ the\ element\ is\ in}}
\DoxyCodeLine{02007\ }
\DoxyCodeLine{02008\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ localBlockIndex\ =\ blockIndex.load(std::memory\_order\_acquire);}
\DoxyCodeLine{02009\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ localBlockIndexHead\ =\ localBlockIndex-\/>front.load(std::memory\_order\_acquire);}
\DoxyCodeLine{02010\ }
\DoxyCodeLine{02011\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ need\ to\ be\ careful\ here\ about\ subtracting\ and\ dividing\ because\ of\ index\ wrap-\/around.}}
\DoxyCodeLine{02012\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ When\ an\ index\ wraps,\ we\ need\ to\ preserve\ the\ sign\ of\ the\ offset\ when\ dividing\ it\ by\ the}}
\DoxyCodeLine{02013\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ block\ size\ (in\ order\ to\ get\ a\ correct\ signed\ block\ count\ offset\ in\ all\ cases):}}
\DoxyCodeLine{02014\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ headBase\ =\ localBlockIndex-\/>entries[localBlockIndexHead].base;}
\DoxyCodeLine{02015\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ blockBaseIndex\ =\ index\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1);}
\DoxyCodeLine{02016\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ offset\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}typename\ std::make\_signed<index\_t>::type\textcolor{keyword}{>}(blockBaseIndex\ -\/\ headBase)\ /\ \textcolor{keyword}{static\_cast<}typename\ std::make\_signed<index\_t>::type\textcolor{keyword}{>}(BLOCK\_SIZE));}
\DoxyCodeLine{02017\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ localBlockIndex-\/>entries[(localBlockIndexHead\ +\ offset)\ \&\ (localBlockIndex-\/>size\ -\/\ 1)].block;}
\DoxyCodeLine{02018\ }
\DoxyCodeLine{02019\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Dequeue}}
\DoxyCodeLine{02020\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ el\ =\ *((*block)[index]);}
\DoxyCodeLine{02021\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!MOODYCAMEL\_NOEXCEPT\_ASSIGN(T,\ T\&\&,\ element\ =\ std::move(el)))\ \{}
\DoxyCodeLine{02022\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Make\ sure\ the\ element\ is\ still\ fully\ dequeued\ and\ destroyed\ even\ if\ the\ assignment}}
\DoxyCodeLine{02023\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ throws}}
\DoxyCodeLine{02024\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }Guard\ \{}
\DoxyCodeLine{02025\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Block*\ block;}
\DoxyCodeLine{02026\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ index;}
\DoxyCodeLine{02027\ }
\DoxyCodeLine{02028\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \string~Guard()}
\DoxyCodeLine{02029\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02030\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (*block)[index]-\/>\string~T();}
\DoxyCodeLine{02031\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block-\/>ConcurrentQueue::Block::template\ set\_empty<explicit\_context>(index);}
\DoxyCodeLine{02032\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02033\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ guard\ =\ \{\ block,\ index\ \};}
\DoxyCodeLine{02034\ }
\DoxyCodeLine{02035\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ element\ =\ std::move(el);\ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02036\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02037\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02038\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ element\ =\ std::move(el);\ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02039\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ el.\string~T();\ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02040\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block-\/>ConcurrentQueue::Block::template\ set\_empty<explicit\_context>(index);}
\DoxyCodeLine{02041\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02042\ }
\DoxyCodeLine{02043\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02044\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02045\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02046\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Wasn't\ anything\ to\ dequeue\ after\ all;\ make\ the\ effective\ dequeue\ count\ eventually\ consistent}}
\DoxyCodeLine{02047\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>dequeueOvercommit.fetch\_add(1,\ std::memory\_order\_release);\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Release\ so\ that\ the\ fetch\_add\ on\ dequeueOptimisticCount\ is\ guaranteed\ to\ happen\ before\ this\ write}}
\DoxyCodeLine{02048\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02049\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02050\ }
\DoxyCodeLine{02051\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02052\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02053\ }
\DoxyCodeLine{02054\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<AllocationMode\ allocMode,\ \textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{02055\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ MOODYCAMEL\_NO\_TSAN\ enqueue\_bulk(It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{02056\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02057\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ First,\ we\ need\ to\ make\ sure\ we\ have\ enough\ room\ to\ enqueue\ all\ of\ the\ elements;}}
\DoxyCodeLine{02058\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ this\ means\ pre-\/allocating\ blocks\ and\ putting\ them\ in\ the\ block\ index\ (but\ only\ if}}
\DoxyCodeLine{02059\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ all\ the\ allocations\ succeeded).}}
\DoxyCodeLine{02060\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ startTailIndex\ =\ this-\/>tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02061\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ startBlock\ =\ this-\/>tailBlock;}
\DoxyCodeLine{02062\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ originalBlockIndexFront\ =\ pr\_blockIndexFront;}
\DoxyCodeLine{02063\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ originalBlockIndexSlotsUsed\ =\ pr\_blockIndexSlotsUsed;}
\DoxyCodeLine{02064\ }
\DoxyCodeLine{02065\ \ \ \ \ \ \ \ \ \ \ \ \ Block*\ firstAllocatedBlock\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{02066\ }
\DoxyCodeLine{02067\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Figure\ out\ how\ many\ blocks\ we'll\ need\ to\ allocate,\ and\ do\ so}}
\DoxyCodeLine{02068\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ blockBaseDiff\ =\ ((startTailIndex\ +\ count\ -\/\ 1)\ \&\ \string~\textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ -\/\ ((startTailIndex\ -\/\ 1)\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1));}
\DoxyCodeLine{02069\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ currentTailIndex\ =\ (startTailIndex\ -\/\ 1)\ \&\ \string~\textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1);}
\DoxyCodeLine{02070\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (blockBaseDiff\ >\ 0)\ \{}
\DoxyCodeLine{02071\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Allocate\ as\ many\ blocks\ as\ possible\ from\ ahead}}
\DoxyCodeLine{02072\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (blockBaseDiff\ >\ 0\ \&\&\ this-\/>tailBlock\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ this-\/>tailBlock-\/>next\ !=\ firstAllocatedBlock\ \&\&\ this-\/>tailBlock-\/>next-\/>ConcurrentQueue::Block::template\ is\_empty<explicit\_context>())\ \{}
\DoxyCodeLine{02073\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ blockBaseDiff\ -\/=\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02074\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ +=\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02075\ }
\DoxyCodeLine{02076\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ this-\/>tailBlock-\/>next;}
\DoxyCodeLine{02077\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ firstAllocatedBlock\ =\ firstAllocatedBlock\ ==\ \textcolor{keyword}{nullptr}\ ?\ this-\/>tailBlock\ :\ firstAllocatedBlock;}
\DoxyCodeLine{02078\ }
\DoxyCodeLine{02079\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ entry\ =\ blockIndex.load(std::memory\_order\_relaxed)-\/>entries[pr\_blockIndexFront];}
\DoxyCodeLine{02080\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry.base\ =\ currentTailIndex;}
\DoxyCodeLine{02081\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry.block\ =\ this-\/>tailBlock;}
\DoxyCodeLine{02082\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexFront\ =\ (pr\_blockIndexFront\ +\ 1)\ \&\ (pr\_blockIndexSize\ -\/\ 1);}
\DoxyCodeLine{02083\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02084\ }
\DoxyCodeLine{02085\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Now\ allocate\ as\ many\ blocks\ as\ necessary\ from\ the\ block\ pool}}
\DoxyCodeLine{02086\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (blockBaseDiff\ >\ 0)\ \{}
\DoxyCodeLine{02087\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ blockBaseDiff\ -\/=\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02088\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ +=\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02089\ }
\DoxyCodeLine{02090\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ head\ =\ this-\/>headIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02091\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(!details::circular\_less\_than<index\_t>(currentTailIndex,\ head));}
\DoxyCodeLine{02092\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ full\ =\ !details::circular\_less\_than<index\_t>(head,\ currentTailIndex\ +\ BLOCK\_SIZE)\ ||\ (MAX\_SUBQUEUE\_SIZE\ !=\ \mbox{\hyperlink{structmoodycamel_1_1details_1_1const__numeric__max}{details::const\_numeric\_max<size\_t>::value}}\ \&\&\ (MAX\_SUBQUEUE\_SIZE\ ==\ 0\ ||\ MAX\_SUBQUEUE\_SIZE\ -\/\ BLOCK\_SIZE\ <\ currentTailIndex\ -\/\ head));}
\DoxyCodeLine{02093\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (pr\_blockIndexRaw\ ==\ \textcolor{keyword}{nullptr}\ ||\ pr\_blockIndexSlotsUsed\ ==\ pr\_blockIndexSize\ ||\ full)\ \{}
\DoxyCodeLine{02094\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (allocMode\ ==\ CannotAlloc)\ \{}
\DoxyCodeLine{02095\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Failed\ to\ allocate,\ undo\ changes\ (but\ keep\ injected\ blocks)}}
\DoxyCodeLine{02096\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexFront\ =\ originalBlockIndexFront;}
\DoxyCodeLine{02097\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexSlotsUsed\ =\ originalBlockIndexSlotsUsed;}
\DoxyCodeLine{02098\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ startBlock\ ==\ \textcolor{keyword}{nullptr}\ ?\ firstAllocatedBlock\ :\ startBlock;}
\DoxyCodeLine{02099\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02100\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02101\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (full\ ||\ !new\_block\_index(originalBlockIndexSlotsUsed))\ \{}
\DoxyCodeLine{02102\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Failed\ to\ allocate,\ undo\ changes\ (but\ keep\ injected\ blocks)}}
\DoxyCodeLine{02103\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexFront\ =\ originalBlockIndexFront;}
\DoxyCodeLine{02104\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexSlotsUsed\ =\ originalBlockIndexSlotsUsed;}
\DoxyCodeLine{02105\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ startBlock\ ==\ \textcolor{keyword}{nullptr}\ ?\ firstAllocatedBlock\ :\ startBlock;}
\DoxyCodeLine{02106\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02107\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02108\ }
\DoxyCodeLine{02109\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ pr\_blockIndexFront\ is\ updated\ inside\ new\_block\_index,\ so\ we\ need\ to}}
\DoxyCodeLine{02110\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ update\ our\ fallback\ value\ too\ (since\ we\ keep\ the\ new\ index\ even\ if\ we}}
\DoxyCodeLine{02111\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ later\ fail)}}
\DoxyCodeLine{02112\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ originalBlockIndexFront\ =\ originalBlockIndexSlotsUsed;}
\DoxyCodeLine{02113\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02114\ }
\DoxyCodeLine{02115\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Insert\ a\ new\ block\ in\ the\ circular\ linked\ list}}
\DoxyCodeLine{02116\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ newBlock\ =\ this-\/>parent-\/>ConcurrentQueue::template\ requisition\_block<allocMode>();}
\DoxyCodeLine{02117\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (newBlock\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02118\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexFront\ =\ originalBlockIndexFront;}
\DoxyCodeLine{02119\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexSlotsUsed\ =\ originalBlockIndexSlotsUsed;}
\DoxyCodeLine{02120\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ startBlock\ ==\ \textcolor{keyword}{nullptr}\ ?\ firstAllocatedBlock\ :\ startBlock;}
\DoxyCodeLine{02121\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02122\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02123\ }
\DoxyCodeLine{02124\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{02125\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>owner\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{02126\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02127\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>ConcurrentQueue::Block::template\ set\_all\_empty<explicit\_context>();}
\DoxyCodeLine{02128\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (this-\/>tailBlock\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02129\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>next\ =\ newBlock;}
\DoxyCodeLine{02130\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02131\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02132\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>next\ =\ this-\/>tailBlock-\/>next;}
\DoxyCodeLine{02133\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock-\/>next\ =\ newBlock;}
\DoxyCodeLine{02134\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02135\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ newBlock;}
\DoxyCodeLine{02136\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ firstAllocatedBlock\ =\ firstAllocatedBlock\ ==\ \textcolor{keyword}{nullptr}\ ?\ this-\/>tailBlock\ :\ firstAllocatedBlock;}
\DoxyCodeLine{02137\ }
\DoxyCodeLine{02138\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++pr\_blockIndexSlotsUsed;}
\DoxyCodeLine{02139\ }
\DoxyCodeLine{02140\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ entry\ =\ blockIndex.load(std::memory\_order\_relaxed)-\/>entries[pr\_blockIndexFront];}
\DoxyCodeLine{02141\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry.base\ =\ currentTailIndex;}
\DoxyCodeLine{02142\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry.block\ =\ this-\/>tailBlock;}
\DoxyCodeLine{02143\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexFront\ =\ (pr\_blockIndexFront\ +\ 1)\ \&\ (pr\_blockIndexSize\ -\/\ 1);}
\DoxyCodeLine{02144\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02145\ }
\DoxyCodeLine{02146\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Excellent,\ all\ allocations\ succeeded.\ Reset\ each\ block's\ emptiness\ before\ we\ fill\ them\ up,\ and}}
\DoxyCodeLine{02147\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ publish\ the\ new\ block\ index\ front}}
\DoxyCodeLine{02148\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ firstAllocatedBlock;}
\DoxyCodeLine{02149\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{02150\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block-\/>ConcurrentQueue::Block::template\ reset\_empty<explicit\_context>();}
\DoxyCodeLine{02151\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block\ ==\ this-\/>tailBlock)\ \{}
\DoxyCodeLine{02152\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02153\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02154\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ block-\/>next;}
\DoxyCodeLine{02155\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02156\ }
\DoxyCodeLine{02157\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (MOODYCAMEL\_NOEXCEPT\_CTOR(T,\ \textcolor{keyword}{decltype}(*itemFirst),\ \textcolor{keyword}{new}\ (\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}))\ T(details::deref\_noexcept(itemFirst))))\ \{}
\DoxyCodeLine{02158\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ blockIndex.load(std::memory\_order\_relaxed)-\/>front.store((pr\_blockIndexFront\ -\/\ 1)\ \&\ (pr\_blockIndexSize\ -\/\ 1),\ std::memory\_order\_release);}
\DoxyCodeLine{02159\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02160\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02161\ }
\DoxyCodeLine{02162\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Enqueue,\ one\ block\ at\ a\ time}}
\DoxyCodeLine{02163\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ newTailIndex\ =\ startTailIndex\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(count);}
\DoxyCodeLine{02164\ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ =\ startTailIndex;}
\DoxyCodeLine{02165\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ endBlock\ =\ this-\/>tailBlock;}
\DoxyCodeLine{02166\ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ startBlock;}
\DoxyCodeLine{02167\ \ \ \ \ \ \ \ \ \ \ \ \ assert((startTailIndex\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ !=\ 0\ ||\ firstAllocatedBlock\ !=\ \textcolor{keyword}{nullptr}\ ||\ count\ ==\ 0);}
\DoxyCodeLine{02168\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((startTailIndex\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ ==\ 0\ \&\&\ firstAllocatedBlock\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02169\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ firstAllocatedBlock;}
\DoxyCodeLine{02170\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02171\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{02172\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ stopIndex\ =\ (currentTailIndex\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1))\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02173\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (details::circular\_less\_than<index\_t>(newTailIndex,\ stopIndex))\ \{}
\DoxyCodeLine{02174\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stopIndex\ =\ newTailIndex;}
\DoxyCodeLine{02175\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02176\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (MOODYCAMEL\_NOEXCEPT\_CTOR(T,\ \textcolor{keyword}{decltype}(*itemFirst),\ \textcolor{keyword}{new}\ (\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}))\ T(details::deref\_noexcept(itemFirst))))\ \{}
\DoxyCodeLine{02177\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (currentTailIndex\ !=\ stopIndex)\ \{}
\DoxyCodeLine{02178\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ ((*this-\/>tailBlock)[currentTailIndex++])\ T(*itemFirst++);}
\DoxyCodeLine{02179\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02180\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02181\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02182\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_TRY\ \{}
\DoxyCodeLine{02183\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (currentTailIndex\ !=\ stopIndex)\ \{}
\DoxyCodeLine{02184\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Must\ use\ copy\ constructor\ even\ if\ move\ constructor\ is\ available}}
\DoxyCodeLine{02185\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ because\ we\ may\ have\ to\ revert\ if\ there's\ an\ exception.}}
\DoxyCodeLine{02186\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Sorry\ about\ the\ horrible\ templated\ next\ line,\ but\ it\ was\ the\ only\ way}}
\DoxyCodeLine{02187\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ to\ disable\ moving\ *at\ compile\ time*,\ which\ is\ important\ because\ a\ type}}
\DoxyCodeLine{02188\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ may\ only\ define\ a\ (noexcept)\ move\ constructor,\ and\ so\ calls\ to\ the}}
\DoxyCodeLine{02189\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ cctor\ will\ not\ compile,\ even\ if\ they\ are\ in\ an\ if\ branch\ that\ will\ never}}
\DoxyCodeLine{02190\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ be\ executed}}
\DoxyCodeLine{02191\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ ((*this-\/>tailBlock)[currentTailIndex])\ T(\mbox{\hyperlink{structmoodycamel_1_1details_1_1nomove__if}{details::nomove\_if}}<!MOODYCAMEL\_NOEXCEPT\_CTOR(T,\ \textcolor{keyword}{decltype}(*itemFirst),\ \textcolor{keyword}{new}\ (\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}))\ T(details::deref\_noexcept(itemFirst)))>::eval(*itemFirst));}
\DoxyCodeLine{02192\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++currentTailIndex;}
\DoxyCodeLine{02193\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++itemFirst;}
\DoxyCodeLine{02194\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02195\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02196\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CATCH\ (...)\ \{}
\DoxyCodeLine{02197\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Oh\ dear,\ an\ exception's\ been\ thrown\ -\/-\/\ destroy\ the\ elements\ that}}
\DoxyCodeLine{02198\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ were\ enqueued\ so\ far\ and\ revert\ the\ entire\ bulk\ operation\ (we'll\ keep}}
\DoxyCodeLine{02199\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ any\ allocated\ blocks\ in\ our\ linked\ list\ for\ later,\ though).}}
\DoxyCodeLine{02200\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ constructedStopIndex\ =\ currentTailIndex;}
\DoxyCodeLine{02201\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ lastBlockEnqueued\ =\ this-\/>tailBlock;}
\DoxyCodeLine{02202\ }
\DoxyCodeLine{02203\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexFront\ =\ originalBlockIndexFront;}
\DoxyCodeLine{02204\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexSlotsUsed\ =\ originalBlockIndexSlotsUsed;}
\DoxyCodeLine{02205\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ startBlock\ ==\ \textcolor{keyword}{nullptr}\ ?\ firstAllocatedBlock\ :\ startBlock;}
\DoxyCodeLine{02206\ }
\DoxyCodeLine{02207\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!\mbox{\hyperlink{structmoodycamel_1_1details_1_1is__trivially__destructible}{details::is\_trivially\_destructible<T>::value}})\ \{}
\DoxyCodeLine{02208\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ startBlock;}
\DoxyCodeLine{02209\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((startTailIndex\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ ==\ 0)\ \{}
\DoxyCodeLine{02210\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ firstAllocatedBlock;}
\DoxyCodeLine{02211\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02212\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ =\ startTailIndex;}
\DoxyCodeLine{02213\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{02214\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stopIndex\ =\ (currentTailIndex\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1))\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02215\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (details::circular\_less\_than<index\_t>(constructedStopIndex,\ stopIndex))\ \{}
\DoxyCodeLine{02216\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stopIndex\ =\ constructedStopIndex;}
\DoxyCodeLine{02217\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02218\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (currentTailIndex\ !=\ stopIndex)\ \{}
\DoxyCodeLine{02219\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (*block)[currentTailIndex++]-\/>\string~T();}
\DoxyCodeLine{02220\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02221\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block\ ==\ lastBlockEnqueued)\ \{}
\DoxyCodeLine{02222\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02223\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02224\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ block-\/>next;}
\DoxyCodeLine{02225\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02226\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02227\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_RETHROW;}
\DoxyCodeLine{02228\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02229\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02230\ }
\DoxyCodeLine{02231\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (this-\/>tailBlock\ ==\ endBlock)\ \{}
\DoxyCodeLine{02232\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(currentTailIndex\ ==\ newTailIndex);}
\DoxyCodeLine{02233\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02234\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02235\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ this-\/>tailBlock-\/>next;}
\DoxyCodeLine{02236\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02237\ }
\DoxyCodeLine{02238\ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (!MOODYCAMEL\_NOEXCEPT\_CTOR(T,\ \textcolor{keyword}{decltype}(*itemFirst),\ \textcolor{keyword}{new}\ (\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}))\ T(details::deref\_noexcept(itemFirst))))\ \{}
\DoxyCodeLine{02239\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (firstAllocatedBlock\ !=\ \textcolor{keyword}{nullptr})}
\DoxyCodeLine{02240\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ blockIndex.load(std::memory\_order\_relaxed)-\/>front.store((pr\_blockIndexFront\ -\/\ 1)\ \&\ (pr\_blockIndexSize\ -\/\ 1),\ std::memory\_order\_release);}
\DoxyCodeLine{02241\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02242\ }
\DoxyCodeLine{02243\ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailIndex.store(newTailIndex,\ std::memory\_order\_release);}
\DoxyCodeLine{02244\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02245\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02246\ }
\DoxyCodeLine{02247\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{02248\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ MOODYCAMEL\_NO\_TSAN\ dequeue\_bulk(It\&\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ max)}
\DoxyCodeLine{02249\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02250\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tail\ =\ this-\/>tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02251\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ overcommit\ =\ this-\/>dequeueOvercommit.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02252\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ desiredCount\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(tail\ -\/\ (this-\/>dequeueOptimisticCount.load(std::memory\_order\_relaxed)\ -\/\ overcommit));}
\DoxyCodeLine{02253\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (details::circular\_less\_than<size\_t>(0,\ desiredCount))\ \{}
\DoxyCodeLine{02254\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ desiredCount\ =\ desiredCount\ <\ max\ ?\ desiredCount\ :\ max;}
\DoxyCodeLine{02255\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic\_thread\_fence(std::memory\_order\_acquire);}
\DoxyCodeLine{02256\ }
\DoxyCodeLine{02257\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ myDequeueCount\ =\ this-\/>dequeueOptimisticCount.fetch\_add(desiredCount,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02258\ }
\DoxyCodeLine{02259\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tail\ =\ this-\/>tailIndex.load(std::memory\_order\_acquire);}
\DoxyCodeLine{02260\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ actualCount\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(tail\ -\/\ (myDequeueCount\ -\/\ overcommit));}
\DoxyCodeLine{02261\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (details::circular\_less\_than<size\_t>(0,\ actualCount))\ \{}
\DoxyCodeLine{02262\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ actualCount\ =\ desiredCount\ <\ actualCount\ ?\ desiredCount\ :\ actualCount;}
\DoxyCodeLine{02263\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (actualCount\ <\ desiredCount)\ \{}
\DoxyCodeLine{02264\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>dequeueOvercommit.fetch\_add(desiredCount\ -\/\ actualCount,\ std::memory\_order\_release);}
\DoxyCodeLine{02265\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02266\ }
\DoxyCodeLine{02267\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ the\ first\ index.\ Note\ that\ since\ there's\ guaranteed\ to\ be\ at\ least\ actualCount\ elements,\ this}}
\DoxyCodeLine{02268\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ will\ never\ exceed\ tail.}}
\DoxyCodeLine{02269\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ firstIndex\ =\ this-\/>headIndex.fetch\_add(actualCount,\ std::memory\_order\_acq\_rel);}
\DoxyCodeLine{02270\ }
\DoxyCodeLine{02271\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Determine\ which\ block\ the\ first\ element\ is\ in}}
\DoxyCodeLine{02272\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ localBlockIndex\ =\ blockIndex.load(std::memory\_order\_acquire);}
\DoxyCodeLine{02273\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ localBlockIndexHead\ =\ localBlockIndex-\/>front.load(std::memory\_order\_acquire);}
\DoxyCodeLine{02274\ }
\DoxyCodeLine{02275\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ headBase\ =\ localBlockIndex-\/>entries[localBlockIndexHead].base;}
\DoxyCodeLine{02276\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ firstBlockBaseIndex\ =\ firstIndex\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1);}
\DoxyCodeLine{02277\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ offset\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}typename\ std::make\_signed<index\_t>::type\textcolor{keyword}{>}(firstBlockBaseIndex\ -\/\ headBase)\ /\ \textcolor{keyword}{static\_cast<}typename\ std::make\_signed<index\_t>::type\textcolor{keyword}{>}(BLOCK\_SIZE));}
\DoxyCodeLine{02278\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ indexIndex\ =\ (localBlockIndexHead\ +\ offset)\ \&\ (localBlockIndex-\/>size\ -\/\ 1);}
\DoxyCodeLine{02279\ }
\DoxyCodeLine{02280\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Iterate\ the\ blocks\ and\ dequeue}}
\DoxyCodeLine{02281\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ index\ =\ firstIndex;}
\DoxyCodeLine{02282\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{02283\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ firstIndexInBlock\ =\ index;}
\DoxyCodeLine{02284\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ endIndex\ =\ (index\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1))\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02285\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ endIndex\ =\ details::circular\_less\_than<index\_t>(firstIndex\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(actualCount),\ endIndex)\ ?\ firstIndex\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(actualCount)\ :\ endIndex;}
\DoxyCodeLine{02286\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ localBlockIndex-\/>entries[indexIndex].block;}
\DoxyCodeLine{02287\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (MOODYCAMEL\_NOEXCEPT\_ASSIGN(T,\ T\&\&,\ details::deref\_noexcept(itemFirst)\ =\ std::move((*(*block)[index]))))\ \{}
\DoxyCodeLine{02288\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (index\ !=\ endIndex)\ \{}
\DoxyCodeLine{02289\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ el\ =\ *((*block)[index]);}
\DoxyCodeLine{02290\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *itemFirst++\ =\ std::move(el);}
\DoxyCodeLine{02291\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ el.\string~T();}
\DoxyCodeLine{02292\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++index;}
\DoxyCodeLine{02293\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02294\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02295\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02296\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_TRY\ \{}
\DoxyCodeLine{02297\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (index\ !=\ endIndex)\ \{}
\DoxyCodeLine{02298\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ el\ =\ *((*block)[index]);}
\DoxyCodeLine{02299\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *itemFirst\ =\ std::move(el);}
\DoxyCodeLine{02300\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++itemFirst;}
\DoxyCodeLine{02301\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ el.\string~T();}
\DoxyCodeLine{02302\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++index;}
\DoxyCodeLine{02303\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02304\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02305\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CATCH\ (...)\ \{}
\DoxyCodeLine{02306\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ It's\ too\ late\ to\ revert\ the\ dequeue,\ but\ we\ can\ make\ sure\ that\ all}}
\DoxyCodeLine{02307\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ dequeued\ objects\ are\ properly\ destroyed\ and\ the\ block\ index}}
\DoxyCodeLine{02308\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ (and\ empty\ count)\ are\ properly\ updated\ before\ we\ propagate\ the\ exception}}
\DoxyCodeLine{02309\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{02310\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ localBlockIndex-\/>entries[indexIndex].block;}
\DoxyCodeLine{02311\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (index\ !=\ endIndex)\ \{}
\DoxyCodeLine{02312\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (*block)[index++]-\/>\string~T();}
\DoxyCodeLine{02313\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02314\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block-\/>ConcurrentQueue::Block::template\ set\_many\_empty<explicit\_context>(firstIndexInBlock,\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(endIndex\ -\/\ firstIndexInBlock));}
\DoxyCodeLine{02315\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ indexIndex\ =\ (indexIndex\ +\ 1)\ \&\ (localBlockIndex-\/>size\ -\/\ 1);}
\DoxyCodeLine{02316\ }
\DoxyCodeLine{02317\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ firstIndexInBlock\ =\ index;}
\DoxyCodeLine{02318\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ endIndex\ =\ (index\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1))\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02319\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ endIndex\ =\ details::circular\_less\_than<index\_t>(firstIndex\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(actualCount),\ endIndex)\ ?\ firstIndex\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(actualCount)\ :\ endIndex;}
\DoxyCodeLine{02320\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (index\ !=\ firstIndex\ +\ actualCount);}
\DoxyCodeLine{02321\ }
\DoxyCodeLine{02322\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_RETHROW;}
\DoxyCodeLine{02323\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02324\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02325\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block-\/>ConcurrentQueue::Block::template\ set\_many\_empty<explicit\_context>(firstIndexInBlock,\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(endIndex\ -\/\ firstIndexInBlock));}
\DoxyCodeLine{02326\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ indexIndex\ =\ (indexIndex\ +\ 1)\ \&\ (localBlockIndex-\/>size\ -\/\ 1);}
\DoxyCodeLine{02327\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (index\ !=\ firstIndex\ +\ actualCount);}
\DoxyCodeLine{02328\ }
\DoxyCodeLine{02329\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ actualCount;}
\DoxyCodeLine{02330\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02331\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02332\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Wasn't\ anything\ to\ dequeue\ after\ all;\ make\ the\ effective\ dequeue\ count\ eventually\ consistent}}
\DoxyCodeLine{02333\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>dequeueOvercommit.fetch\_add(desiredCount,\ std::memory\_order\_release);}
\DoxyCodeLine{02334\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02335\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02336\ }
\DoxyCodeLine{02337\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{02338\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02339\ }
\DoxyCodeLine{02340\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02341\ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }BlockIndexEntry}
\DoxyCodeLine{02342\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02343\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ base;}
\DoxyCodeLine{02344\ \ \ \ \ \ \ \ \ \ \ \ \ Block*\ block;}
\DoxyCodeLine{02345\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{02346\ }
\DoxyCodeLine{02347\ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }BlockIndexHeader}
\DoxyCodeLine{02348\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02349\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ size;}
\DoxyCodeLine{02350\ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic<size\_t>\ front;\ \ \ \ \ \ \textcolor{comment}{//\ Current\ slot\ (not\ next,\ like\ pr\_blockIndexFront)}}
\DoxyCodeLine{02351\ \ \ \ \ \ \ \ \ \ \ \ \ BlockIndexEntry*\ entries;}
\DoxyCodeLine{02352\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}*\ prev;}
\DoxyCodeLine{02353\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{02354\ }
\DoxyCodeLine{02355\ }
\DoxyCodeLine{02356\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ new\_block\_index(\textcolor{keywordtype}{size\_t}\ numberOfFilledSlotsToExpose)}
\DoxyCodeLine{02357\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02358\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prevBlockSizeMask\ =\ pr\_blockIndexSize\ -\/\ 1;}
\DoxyCodeLine{02359\ }
\DoxyCodeLine{02360\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Create\ the\ new\ block}}
\DoxyCodeLine{02361\ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexSize\ <<=\ 1;}
\DoxyCodeLine{02362\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ newRawPtr\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}((Traits::malloc)(\textcolor{keyword}{sizeof}(BlockIndexHeader)\ +\ std::alignment\_of<BlockIndexEntry>::value\ -\/\ 1\ +\ \textcolor{keyword}{sizeof}(BlockIndexEntry)\ *\ pr\_blockIndexSize));}
\DoxyCodeLine{02363\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (newRawPtr\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02364\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexSize\ >>=\ 1;\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Reset\ to\ allow\ graceful\ retry}}
\DoxyCodeLine{02365\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02366\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02367\ }
\DoxyCodeLine{02368\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ newBlockIndexEntries\ =\ \textcolor{keyword}{reinterpret\_cast<}BlockIndexEntry*\textcolor{keyword}{>}(details::align\_for<BlockIndexEntry>(newRawPtr\ +\ \textcolor{keyword}{sizeof}(BlockIndexHeader)));}
\DoxyCodeLine{02369\ }
\DoxyCodeLine{02370\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Copy\ in\ all\ the\ old\ indices,\ if\ any}}
\DoxyCodeLine{02371\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ j\ =\ 0;}
\DoxyCodeLine{02372\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (pr\_blockIndexSlotsUsed\ !=\ 0)\ \{}
\DoxyCodeLine{02373\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ i\ =\ (pr\_blockIndexFront\ -\/\ pr\_blockIndexSlotsUsed)\ \&\ prevBlockSizeMask;}
\DoxyCodeLine{02374\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{02375\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlockIndexEntries[j++]\ =\ pr\_blockIndexEntries[i];}
\DoxyCodeLine{02376\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i\ =\ (i\ +\ 1)\ \&\ prevBlockSizeMask;}
\DoxyCodeLine{02377\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (i\ !=\ pr\_blockIndexFront);}
\DoxyCodeLine{02378\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02379\ }
\DoxyCodeLine{02380\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Update\ everything}}
\DoxyCodeLine{02381\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ header\ =\ \textcolor{keyword}{new}\ (newRawPtr)\ BlockIndexHeader;}
\DoxyCodeLine{02382\ \ \ \ \ \ \ \ \ \ \ \ \ header-\/>size\ =\ pr\_blockIndexSize;}
\DoxyCodeLine{02383\ \ \ \ \ \ \ \ \ \ \ \ \ header-\/>front.store(numberOfFilledSlotsToExpose\ -\/\ 1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02384\ \ \ \ \ \ \ \ \ \ \ \ \ header-\/>entries\ =\ newBlockIndexEntries;}
\DoxyCodeLine{02385\ \ \ \ \ \ \ \ \ \ \ \ \ header-\/>prev\ =\ pr\_blockIndexRaw;\ \ \ \ \ \ \ \ \textcolor{comment}{//\ we\ link\ the\ new\ block\ to\ the\ old\ one\ so\ we\ can\ free\ it\ later}}
\DoxyCodeLine{02386\ }
\DoxyCodeLine{02387\ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexFront\ =\ j;}
\DoxyCodeLine{02388\ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexEntries\ =\ newBlockIndexEntries;}
\DoxyCodeLine{02389\ \ \ \ \ \ \ \ \ \ \ \ \ pr\_blockIndexRaw\ =\ newRawPtr;}
\DoxyCodeLine{02390\ \ \ \ \ \ \ \ \ \ \ \ \ blockIndex.store(header,\ std::memory\_order\_release);}
\DoxyCodeLine{02391\ }
\DoxyCodeLine{02392\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02393\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02394\ }
\DoxyCodeLine{02395\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02396\ \ \ \ \ \ \ \ \ std::atomic<BlockIndexHeader*>\ blockIndex;}
\DoxyCodeLine{02397\ }
\DoxyCodeLine{02398\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ To\ be\ used\ by\ producer\ only\ -\/-\/\ consumer\ must\ use\ the\ ones\ in\ referenced\ by\ blockIndex}}
\DoxyCodeLine{02399\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ pr\_blockIndexSlotsUsed;}
\DoxyCodeLine{02400\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ pr\_blockIndexSize;}
\DoxyCodeLine{02401\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ pr\_blockIndexFront;\ \ \ \ \ \ \textcolor{comment}{//\ Next\ slot\ (not\ current)}}
\DoxyCodeLine{02402\ \ \ \ \ \ \ \ \ BlockIndexEntry*\ pr\_blockIndexEntries;}
\DoxyCodeLine{02403\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}*\ pr\_blockIndexRaw;}
\DoxyCodeLine{02404\ }
\DoxyCodeLine{02405\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_QUEUE\_INTERNAL\_DEBUG}}
\DoxyCodeLine{02406\ \ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02407\ \ \ \ \ \ \ \ \ ExplicitProducer*\ nextExplicitProducer;}
\DoxyCodeLine{02408\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02409\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02410\ }
\DoxyCodeLine{02411\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{02412\ \ \ \ \ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{struct\ }MemStats;}
\DoxyCodeLine{02413\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02414\ \ \ \ \ \};}
\DoxyCodeLine{02415\ }
\DoxyCodeLine{02416\ }
\DoxyCodeLine{02418\ \ \ \ \ \textcolor{comment}{//\ Implicit\ queue}}
\DoxyCodeLine{02420\ }
\DoxyCodeLine{02421\ \ \ \ \ \textcolor{keyword}{struct\ }ImplicitProducer\ :\ \textcolor{keyword}{public}\ ProducerBase}
\DoxyCodeLine{02422\ \ \ \ \ \{}
\DoxyCodeLine{02423\ \ \ \ \ \ \ \ \ ImplicitProducer(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}*\ parent\_)\ :}
\DoxyCodeLine{02424\ \ \ \ \ \ \ \ \ \ \ \ \ ProducerBase(parent\_,\ \textcolor{keyword}{false}),}
\DoxyCodeLine{02425\ \ \ \ \ \ \ \ \ \ \ \ \ nextBlockIndexCapacity(IMPLICIT\_INITIAL\_INDEX\_SIZE),}
\DoxyCodeLine{02426\ \ \ \ \ \ \ \ \ \ \ \ \ blockIndex(\textcolor{keyword}{nullptr})}
\DoxyCodeLine{02427\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02428\ \ \ \ \ \ \ \ \ \ \ \ \ new\_block\_index();}
\DoxyCodeLine{02429\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02430\ }
\DoxyCodeLine{02431\ \ \ \ \ \ \ \ \ \string~ImplicitProducer()}
\DoxyCodeLine{02432\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02433\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ since\ we're\ in\ the\ destructor\ we\ can\ assume\ that\ all\ enqueue/dequeue\ operations}}
\DoxyCodeLine{02434\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ completed\ already;\ this\ means\ that\ all\ undequeued\ elements\ are\ placed\ contiguously\ across}}
\DoxyCodeLine{02435\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ contiguous\ blocks,\ and\ that\ only\ the\ first\ and\ last\ remaining\ blocks\ can\ be\ only\ partially}}
\DoxyCodeLine{02436\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ empty\ (all\ other\ remaining\ blocks\ must\ be\ completely\ full).}}
\DoxyCodeLine{02437\ }
\DoxyCodeLine{02438\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED}}
\DoxyCodeLine{02439\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Unregister\ ourselves\ for\ thread\ termination\ notification}}
\DoxyCodeLine{02440\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!this-\/>inactive.load(std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{02441\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ details::ThreadExitNotifier::unsubscribe(\&threadExitListener);}
\DoxyCodeLine{02442\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02443\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02444\ }
\DoxyCodeLine{02445\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Destroy\ all\ remaining\ elements!}}
\DoxyCodeLine{02446\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tail\ =\ this-\/>tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02447\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ index\ =\ this-\/>headIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02448\ \ \ \ \ \ \ \ \ \ \ \ \ Block*\ block\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{02449\ \ \ \ \ \ \ \ \ \ \ \ \ assert(index\ ==\ tail\ ||\ details::circular\_less\_than(index,\ tail));}
\DoxyCodeLine{02450\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ forceFreeLastBlock\ =\ index\ !=\ tail;\ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ we\ enter\ the\ loop,\ then\ the\ last\ (tail)\ block\ will\ not\ be\ freed}}
\DoxyCodeLine{02451\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (index\ !=\ tail)\ \{}
\DoxyCodeLine{02452\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((index\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ ==\ 0\ ||\ block\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02453\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02454\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Free\ the\ old\ block}}
\DoxyCodeLine{02455\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>parent-\/>add\_block\_to\_free\_list(block);}
\DoxyCodeLine{02456\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02457\ }
\DoxyCodeLine{02458\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ get\_block\_index\_entry\_for\_index(index)-\/>value.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02459\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02460\ }
\DoxyCodeLine{02461\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((*block)[index])-\/>\string~T();}
\DoxyCodeLine{02462\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++index;}
\DoxyCodeLine{02463\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02464\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Even\ if\ the\ queue\ is\ empty,\ there's\ still\ one\ block\ that's\ not\ on\ the\ free\ list}}
\DoxyCodeLine{02465\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ (unless\ the\ head\ index\ reached\ the\ end\ of\ it,\ in\ which\ case\ the\ tail\ will\ be\ poised}}
\DoxyCodeLine{02466\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ to\ create\ a\ new\ block).}}
\DoxyCodeLine{02467\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (this-\/>tailBlock\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ (forceFreeLastBlock\ ||\ (tail\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ !=\ 0))\ \{}
\DoxyCodeLine{02468\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>parent-\/>add\_block\_to\_free\_list(this-\/>tailBlock);}
\DoxyCodeLine{02469\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02470\ }
\DoxyCodeLine{02471\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Destroy\ block\ index}}
\DoxyCodeLine{02472\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ localBlockIndex\ =\ blockIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02473\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (localBlockIndex\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02474\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ localBlockIndex-\/>capacity;\ ++i)\ \{}
\DoxyCodeLine{02475\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ localBlockIndex-\/>index[i]-\/>\string~BlockIndexEntry();}
\DoxyCodeLine{02476\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02477\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{02478\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prev\ =\ localBlockIndex-\/>prev;}
\DoxyCodeLine{02479\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ localBlockIndex-\/>\string~BlockIndexHeader();}
\DoxyCodeLine{02480\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (Traits::free)(localBlockIndex);}
\DoxyCodeLine{02481\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ localBlockIndex\ =\ prev;}
\DoxyCodeLine{02482\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (localBlockIndex\ !=\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{02483\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02484\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02485\ }
\DoxyCodeLine{02486\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<AllocationMode\ allocMode,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{02487\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ enqueue(U\&\&\ element)}
\DoxyCodeLine{02488\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02489\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ currentTailIndex\ =\ this-\/>tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02490\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ newTailIndex\ =\ 1\ +\ currentTailIndex;}
\DoxyCodeLine{02491\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((currentTailIndex\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ ==\ 0)\ \{}
\DoxyCodeLine{02492\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ reached\ the\ end\ of\ a\ block,\ start\ a\ new\ one}}
\DoxyCodeLine{02493\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ head\ =\ this-\/>headIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02494\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(!details::circular\_less\_than<index\_t>(currentTailIndex,\ head));}
\DoxyCodeLine{02495\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!details::circular\_less\_than<index\_t>(head,\ currentTailIndex\ +\ BLOCK\_SIZE)\ ||\ (MAX\_SUBQUEUE\_SIZE\ !=\ \mbox{\hyperlink{structmoodycamel_1_1details_1_1const__numeric__max}{details::const\_numeric\_max<size\_t>::value}}\ \&\&\ (MAX\_SUBQUEUE\_SIZE\ ==\ 0\ ||\ MAX\_SUBQUEUE\_SIZE\ -\/\ BLOCK\_SIZE\ <\ currentTailIndex\ -\/\ head)))\ \{}
\DoxyCodeLine{02496\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02497\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02498\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODBLOCKINDEX}}
\DoxyCodeLine{02499\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(mutex);}
\DoxyCodeLine{02500\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02501\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Find\ out\ where\ we'll\ be\ inserting\ this\ block\ in\ the\ block\ index}}
\DoxyCodeLine{02502\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ BlockIndexEntry*\ idxEntry;}
\DoxyCodeLine{02503\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!insert\_block\_index\_entry<allocMode>(idxEntry,\ currentTailIndex))\ \{}
\DoxyCodeLine{02504\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02505\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02506\ }
\DoxyCodeLine{02507\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ ahold\ of\ a\ new\ block}}
\DoxyCodeLine{02508\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ newBlock\ =\ this-\/>parent-\/>ConcurrentQueue::template\ requisition\_block<allocMode>();}
\DoxyCodeLine{02509\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (newBlock\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02510\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ rewind\_block\_index\_tail();}
\DoxyCodeLine{02511\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry-\/>value.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02512\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02513\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02514\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{02515\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>owner\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{02516\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02517\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>ConcurrentQueue::Block::template\ reset\_empty<implicit\_context>();}
\DoxyCodeLine{02518\ }
\DoxyCodeLine{02519\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (!MOODYCAMEL\_NOEXCEPT\_CTOR(T,\ U,\ \textcolor{keyword}{new}\ (\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}))\ T(std::forward<U>(element))))\ \{}
\DoxyCodeLine{02520\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ May\ throw,\ try\ to\ insert\ now\ before\ we\ publish\ the\ fact\ that\ we\ have\ this\ new\ block}}
\DoxyCodeLine{02521\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_TRY\ \{}
\DoxyCodeLine{02522\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ ((*newBlock)[currentTailIndex])\ T(std::forward<U>(element));}
\DoxyCodeLine{02523\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02524\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CATCH\ (...)\ \{}
\DoxyCodeLine{02525\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ rewind\_block\_index\_tail();}
\DoxyCodeLine{02526\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry-\/>value.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02527\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>parent-\/>add\_block\_to\_free\_list(newBlock);}
\DoxyCodeLine{02528\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_RETHROW;}
\DoxyCodeLine{02529\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02530\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02531\ }
\DoxyCodeLine{02532\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Insert\ the\ new\ block\ into\ the\ index}}
\DoxyCodeLine{02533\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry-\/>value.store(newBlock,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02534\ }
\DoxyCodeLine{02535\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ newBlock;}
\DoxyCodeLine{02536\ }
\DoxyCodeLine{02537\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (!MOODYCAMEL\_NOEXCEPT\_CTOR(T,\ U,\ \textcolor{keyword}{new}\ (\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}))\ T(std::forward<U>(element))))\ \{}
\DoxyCodeLine{02538\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailIndex.store(newTailIndex,\ std::memory\_order\_release);}
\DoxyCodeLine{02539\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02540\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02541\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02542\ }
\DoxyCodeLine{02543\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Enqueue}}
\DoxyCodeLine{02544\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ ((*this-\/>tailBlock)[currentTailIndex])\ T(std::forward<U>(element));}
\DoxyCodeLine{02545\ }
\DoxyCodeLine{02546\ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailIndex.store(newTailIndex,\ std::memory\_order\_release);}
\DoxyCodeLine{02547\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02548\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02549\ }
\DoxyCodeLine{02550\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{02551\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ MOODYCAMEL\_NO\_TSAN\ dequeue(U\&\ element)}
\DoxyCodeLine{02552\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02553\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ See\ ExplicitProducer::dequeue\ for\ rationale\ and\ explanation}}
\DoxyCodeLine{02554\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ tail\ =\ this-\/>tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02555\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ overcommit\ =\ this-\/>dequeueOvercommit.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02556\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (details::circular\_less\_than<index\_t>(this-\/>dequeueOptimisticCount.load(std::memory\_order\_relaxed)\ -\/\ overcommit,\ tail))\ \{}
\DoxyCodeLine{02557\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic\_thread\_fence(std::memory\_order\_acquire);}
\DoxyCodeLine{02558\ }
\DoxyCodeLine{02559\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ myDequeueCount\ =\ this-\/>dequeueOptimisticCount.fetch\_add(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02560\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tail\ =\ this-\/>tailIndex.load(std::memory\_order\_acquire);}
\DoxyCodeLine{02561\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((details::likely)(details::circular\_less\_than<index\_t>(myDequeueCount\ -\/\ overcommit,\ tail)))\ \{}
\DoxyCodeLine{02562\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ index\ =\ this-\/>headIndex.fetch\_add(1,\ std::memory\_order\_acq\_rel);}
\DoxyCodeLine{02563\ }
\DoxyCodeLine{02564\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Determine\ which\ block\ the\ element\ is\ in}}
\DoxyCodeLine{02565\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ entry\ =\ get\_block\_index\_entry\_for\_index(index);}
\DoxyCodeLine{02566\ }
\DoxyCodeLine{02567\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Dequeue}}
\DoxyCodeLine{02568\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ entry-\/>value.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02569\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ el\ =\ *((*block)[index]);}
\DoxyCodeLine{02570\ }
\DoxyCodeLine{02571\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!MOODYCAMEL\_NOEXCEPT\_ASSIGN(T,\ T\&\&,\ element\ =\ std::move(el)))\ \{}
\DoxyCodeLine{02572\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODBLOCKINDEX}}
\DoxyCodeLine{02573\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note:\ Acquiring\ the\ mutex\ with\ every\ dequeue\ instead\ of\ only\ when\ a\ block}}
\DoxyCodeLine{02574\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ is\ released\ is\ very\ sub-\/optimal,\ but\ it\ is,\ after\ all,\ purely\ debug\ code.}}
\DoxyCodeLine{02575\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(producer-\/>mutex);}
\DoxyCodeLine{02576\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02577\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }Guard\ \{}
\DoxyCodeLine{02578\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Block*\ block;}
\DoxyCodeLine{02579\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ index;}
\DoxyCodeLine{02580\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ BlockIndexEntry*\ entry;}
\DoxyCodeLine{02581\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}*\ parent;}
\DoxyCodeLine{02582\ }
\DoxyCodeLine{02583\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \string~Guard()}
\DoxyCodeLine{02584\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02585\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (*block)[index]-\/>\string~T();}
\DoxyCodeLine{02586\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block-\/>ConcurrentQueue::Block::template\ set\_empty<implicit\_context>(index))\ \{}
\DoxyCodeLine{02587\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry-\/>value.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02588\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ parent-\/>add\_block\_to\_free\_list(block);}
\DoxyCodeLine{02589\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02590\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02591\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ guard\ =\ \{\ block,\ index,\ entry,\ this-\/>parent\ \};}
\DoxyCodeLine{02592\ }
\DoxyCodeLine{02593\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ element\ =\ std::move(el);\ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02594\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02595\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02596\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ element\ =\ std::move(el);\ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02597\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ el.\string~T();\ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02598\ }
\DoxyCodeLine{02599\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block-\/>ConcurrentQueue::Block::template\ set\_empty<implicit\_context>(index))\ \{}
\DoxyCodeLine{02600\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02601\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODBLOCKINDEX}}
\DoxyCodeLine{02602\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(mutex);}
\DoxyCodeLine{02603\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02604\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Add\ the\ block\ back\ into\ the\ global\ free\ pool\ (and\ remove\ from\ block\ index)}}
\DoxyCodeLine{02605\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry-\/>value.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02606\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02607\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>parent-\/>add\_block\_to\_free\_list(block);\ \ \ \ \ \ \ \ \textcolor{comment}{//\ releases\ the\ above\ store}}
\DoxyCodeLine{02608\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02609\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02610\ }
\DoxyCodeLine{02611\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02612\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02613\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02614\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>dequeueOvercommit.fetch\_add(1,\ std::memory\_order\_release);}
\DoxyCodeLine{02615\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02616\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02617\ }
\DoxyCodeLine{02618\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02619\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02620\ }
\DoxyCodeLine{02621\ \textcolor{preprocessor}{\#ifdef\ \_MSC\_VER}}
\DoxyCodeLine{02622\ \textcolor{preprocessor}{\#pragma\ warning(push)}}
\DoxyCodeLine{02623\ \textcolor{preprocessor}{\#pragma\ warning(disable:\ 4706)\ \ }\textcolor{comment}{//\ assignment\ within\ conditional\ expression}}
\DoxyCodeLine{02624\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02625\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<AllocationMode\ allocMode,\ \textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{02626\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ enqueue\_bulk(It\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{02627\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02628\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ First,\ we\ need\ to\ make\ sure\ we\ have\ enough\ room\ to\ enqueue\ all\ of\ the\ elements;}}
\DoxyCodeLine{02629\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ this\ means\ pre-\/allocating\ blocks\ and\ putting\ them\ in\ the\ block\ index\ (but\ only\ if}}
\DoxyCodeLine{02630\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ all\ the\ allocations\ succeeded).}}
\DoxyCodeLine{02631\ }
\DoxyCodeLine{02632\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ the\ tailBlock\ we\ start\ off\ with\ may\ not\ be\ owned\ by\ us\ any\ more;}}
\DoxyCodeLine{02633\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ this\ happens\ if\ it\ was\ filled\ up\ exactly\ to\ the\ top\ (setting\ tailIndex\ to}}
\DoxyCodeLine{02634\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ first\ index\ of\ the\ next\ block\ which\ is\ not\ yet\ allocated),\ then\ dequeued}}
\DoxyCodeLine{02635\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ completely\ (putting\ it\ on\ the\ free\ list)\ before\ we\ enqueue\ again.}}
\DoxyCodeLine{02636\ }
\DoxyCodeLine{02637\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ startTailIndex\ =\ this-\/>tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02638\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ startBlock\ =\ this-\/>tailBlock;}
\DoxyCodeLine{02639\ \ \ \ \ \ \ \ \ \ \ \ \ Block*\ firstAllocatedBlock\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{02640\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ endBlock\ =\ this-\/>tailBlock;}
\DoxyCodeLine{02641\ }
\DoxyCodeLine{02642\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Figure\ out\ how\ many\ blocks\ we'll\ need\ to\ allocate,\ and\ do\ so}}
\DoxyCodeLine{02643\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ blockBaseDiff\ =\ ((startTailIndex\ +\ count\ -\/\ 1)\ \&\ \string~\textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ -\/\ ((startTailIndex\ -\/\ 1)\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1));}
\DoxyCodeLine{02644\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ currentTailIndex\ =\ (startTailIndex\ -\/\ 1)\ \&\ \string~\textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1);}
\DoxyCodeLine{02645\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (blockBaseDiff\ >\ 0)\ \{}
\DoxyCodeLine{02646\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODBLOCKINDEX}}
\DoxyCodeLine{02647\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(mutex);}
\DoxyCodeLine{02648\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02649\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{02650\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ blockBaseDiff\ -\/=\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02651\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ +=\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02652\ }
\DoxyCodeLine{02653\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Find\ out\ where\ we'll\ be\ inserting\ this\ block\ in\ the\ block\ index}}
\DoxyCodeLine{02654\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ BlockIndexEntry*\ idxEntry\ =\ \textcolor{keyword}{nullptr};\ \ \textcolor{comment}{//\ initialization\ here\ unnecessary\ but\ compiler\ can't\ always\ tell}}
\DoxyCodeLine{02655\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Block*\ newBlock;}
\DoxyCodeLine{02656\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ indexInserted\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{02657\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ head\ =\ this-\/>headIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02658\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(!details::circular\_less\_than<index\_t>(currentTailIndex,\ head));}
\DoxyCodeLine{02659\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ full\ =\ !details::circular\_less\_than<index\_t>(head,\ currentTailIndex\ +\ BLOCK\_SIZE)\ ||\ (MAX\_SUBQUEUE\_SIZE\ !=\ \mbox{\hyperlink{structmoodycamel_1_1details_1_1const__numeric__max}{details::const\_numeric\_max<size\_t>::value}}\ \&\&\ (MAX\_SUBQUEUE\_SIZE\ ==\ 0\ ||\ MAX\_SUBQUEUE\_SIZE\ -\/\ BLOCK\_SIZE\ <\ currentTailIndex\ -\/\ head));}
\DoxyCodeLine{02660\ }
\DoxyCodeLine{02661\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (full\ ||\ !(indexInserted\ =\ insert\_block\_index\_entry<allocMode>(idxEntry,\ currentTailIndex))\ ||\ (newBlock\ =\ this-\/>parent-\/>ConcurrentQueue::template\ requisition\_block<allocMode>())\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02662\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Index\ allocation\ or\ block\ allocation\ failed;\ revert\ any\ other\ allocations}}
\DoxyCodeLine{02663\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ and\ index\ insertions\ done\ so\ far\ for\ this\ operation}}
\DoxyCodeLine{02664\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (indexInserted)\ \{}
\DoxyCodeLine{02665\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ rewind\_block\_index\_tail();}
\DoxyCodeLine{02666\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry-\/>value.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02667\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02668\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ =\ (startTailIndex\ -\/\ 1)\ \&\ \string~\textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1);}
\DoxyCodeLine{02669\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ block\ =\ firstAllocatedBlock;\ block\ !=\ \textcolor{keyword}{nullptr};\ block\ =\ block-\/>next)\ \{}
\DoxyCodeLine{02670\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ +=\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02671\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry\ =\ get\_block\_index\_entry\_for\_index(currentTailIndex);}
\DoxyCodeLine{02672\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry-\/>value.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02673\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ rewind\_block\_index\_tail();}
\DoxyCodeLine{02674\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02675\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>parent-\/>add\_blocks\_to\_free\_list(firstAllocatedBlock);}
\DoxyCodeLine{02676\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ startBlock;}
\DoxyCodeLine{02677\ }
\DoxyCodeLine{02678\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02679\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02680\ }
\DoxyCodeLine{02681\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{02682\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>owner\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{02683\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02684\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>ConcurrentQueue::Block::template\ reset\_empty<implicit\_context>();}
\DoxyCodeLine{02685\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newBlock-\/>next\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{02686\ }
\DoxyCodeLine{02687\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Insert\ the\ new\ block\ into\ the\ index}}
\DoxyCodeLine{02688\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry-\/>value.store(newBlock,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02689\ }
\DoxyCodeLine{02690\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Store\ the\ chain\ of\ blocks\ so\ that\ we\ can\ undo\ if\ later\ allocations\ fail,}}
\DoxyCodeLine{02691\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ and\ so\ that\ we\ can\ find\ the\ blocks\ when\ we\ do\ the\ actual\ enqueueing}}
\DoxyCodeLine{02692\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((startTailIndex\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ !=\ 0\ ||\ firstAllocatedBlock\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02693\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(this-\/>tailBlock\ !=\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{02694\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock-\/>next\ =\ newBlock;}
\DoxyCodeLine{02695\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02696\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ newBlock;}
\DoxyCodeLine{02697\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ endBlock\ =\ newBlock;}
\DoxyCodeLine{02698\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ firstAllocatedBlock\ =\ firstAllocatedBlock\ ==\ \textcolor{keyword}{nullptr}\ ?\ newBlock\ :\ firstAllocatedBlock;}
\DoxyCodeLine{02699\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (blockBaseDiff\ >\ 0);}
\DoxyCodeLine{02700\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02701\ }
\DoxyCodeLine{02702\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Enqueue,\ one\ block\ at\ a\ time}}
\DoxyCodeLine{02703\ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ newTailIndex\ =\ startTailIndex\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(count);}
\DoxyCodeLine{02704\ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ =\ startTailIndex;}
\DoxyCodeLine{02705\ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ startBlock;}
\DoxyCodeLine{02706\ \ \ \ \ \ \ \ \ \ \ \ \ assert((startTailIndex\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ !=\ 0\ ||\ firstAllocatedBlock\ !=\ \textcolor{keyword}{nullptr}\ ||\ count\ ==\ 0);}
\DoxyCodeLine{02707\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((startTailIndex\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ ==\ 0\ \&\&\ firstAllocatedBlock\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02708\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ firstAllocatedBlock;}
\DoxyCodeLine{02709\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02710\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{02711\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ stopIndex\ =\ (currentTailIndex\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1))\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02712\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (details::circular\_less\_than<index\_t>(newTailIndex,\ stopIndex))\ \{}
\DoxyCodeLine{02713\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stopIndex\ =\ newTailIndex;}
\DoxyCodeLine{02714\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02715\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (MOODYCAMEL\_NOEXCEPT\_CTOR(T,\ \textcolor{keyword}{decltype}(*itemFirst),\ \textcolor{keyword}{new}\ (\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}))\ T(details::deref\_noexcept(itemFirst))))\ \{}
\DoxyCodeLine{02716\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (currentTailIndex\ !=\ stopIndex)\ \{}
\DoxyCodeLine{02717\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ ((*this-\/>tailBlock)[currentTailIndex++])\ T(*itemFirst++);}
\DoxyCodeLine{02718\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02719\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02720\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02721\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_TRY\ \{}
\DoxyCodeLine{02722\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (currentTailIndex\ !=\ stopIndex)\ \{}
\DoxyCodeLine{02723\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ ((*this-\/>tailBlock)[currentTailIndex])\ T(\mbox{\hyperlink{structmoodycamel_1_1details_1_1nomove__if}{details::nomove\_if}}<!MOODYCAMEL\_NOEXCEPT\_CTOR(T,\ \textcolor{keyword}{decltype}(*itemFirst),\ \textcolor{keyword}{new}\ (\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}))\ T(details::deref\_noexcept(itemFirst)))>::eval(*itemFirst));}
\DoxyCodeLine{02724\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++currentTailIndex;}
\DoxyCodeLine{02725\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++itemFirst;}
\DoxyCodeLine{02726\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02727\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02728\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CATCH\ (...)\ \{}
\DoxyCodeLine{02729\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ constructedStopIndex\ =\ currentTailIndex;}
\DoxyCodeLine{02730\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ lastBlockEnqueued\ =\ this-\/>tailBlock;}
\DoxyCodeLine{02731\ }
\DoxyCodeLine{02732\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!\mbox{\hyperlink{structmoodycamel_1_1details_1_1is__trivially__destructible}{details::is\_trivially\_destructible<T>::value}})\ \{}
\DoxyCodeLine{02733\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ startBlock;}
\DoxyCodeLine{02734\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((startTailIndex\ \&\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1))\ ==\ 0)\ \{}
\DoxyCodeLine{02735\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ firstAllocatedBlock;}
\DoxyCodeLine{02736\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02737\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ =\ startTailIndex;}
\DoxyCodeLine{02738\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{02739\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stopIndex\ =\ (currentTailIndex\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1))\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02740\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (details::circular\_less\_than<index\_t>(constructedStopIndex,\ stopIndex))\ \{}
\DoxyCodeLine{02741\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stopIndex\ =\ constructedStopIndex;}
\DoxyCodeLine{02742\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02743\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (currentTailIndex\ !=\ stopIndex)\ \{}
\DoxyCodeLine{02744\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (*block)[currentTailIndex++]-\/>\string~T();}
\DoxyCodeLine{02745\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02746\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block\ ==\ lastBlockEnqueued)\ \{}
\DoxyCodeLine{02747\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02748\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02749\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ block-\/>next;}
\DoxyCodeLine{02750\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02751\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02752\ }
\DoxyCodeLine{02753\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ =\ (startTailIndex\ -\/\ 1)\ \&\ \string~\textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE\ -\/\ 1);}
\DoxyCodeLine{02754\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ block\ =\ firstAllocatedBlock;\ block\ !=\ \textcolor{keyword}{nullptr};\ block\ =\ block-\/>next)\ \{}
\DoxyCodeLine{02755\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ currentTailIndex\ +=\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02756\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ idxEntry\ =\ get\_block\_index\_entry\_for\_index(currentTailIndex);}
\DoxyCodeLine{02757\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry-\/>value.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02758\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ rewind\_block\_index\_tail();}
\DoxyCodeLine{02759\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02760\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>parent-\/>add\_blocks\_to\_free\_list(firstAllocatedBlock);}
\DoxyCodeLine{02761\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ startBlock;}
\DoxyCodeLine{02762\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_RETHROW;}
\DoxyCodeLine{02763\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02764\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02765\ }
\DoxyCodeLine{02766\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (this-\/>tailBlock\ ==\ endBlock)\ \{}
\DoxyCodeLine{02767\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(currentTailIndex\ ==\ newTailIndex);}
\DoxyCodeLine{02768\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02769\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02770\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailBlock\ =\ this-\/>tailBlock-\/>next;}
\DoxyCodeLine{02771\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02772\ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>tailIndex.store(newTailIndex,\ std::memory\_order\_release);}
\DoxyCodeLine{02773\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02774\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02775\ \textcolor{preprocessor}{\#ifdef\ \_MSC\_VER}}
\DoxyCodeLine{02776\ \textcolor{preprocessor}{\#pragma\ warning(pop)}}
\DoxyCodeLine{02777\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02778\ }
\DoxyCodeLine{02779\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ It>}
\DoxyCodeLine{02780\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ MOODYCAMEL\_NO\_TSAN\ dequeue\_bulk(It\&\ itemFirst,\ \textcolor{keywordtype}{size\_t}\ max)}
\DoxyCodeLine{02781\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02782\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tail\ =\ this-\/>tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02783\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ overcommit\ =\ this-\/>dequeueOvercommit.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02784\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ desiredCount\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(tail\ -\/\ (this-\/>dequeueOptimisticCount.load(std::memory\_order\_relaxed)\ -\/\ overcommit));}
\DoxyCodeLine{02785\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (details::circular\_less\_than<size\_t>(0,\ desiredCount))\ \{}
\DoxyCodeLine{02786\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ desiredCount\ =\ desiredCount\ <\ max\ ?\ desiredCount\ :\ max;}
\DoxyCodeLine{02787\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic\_thread\_fence(std::memory\_order\_acquire);}
\DoxyCodeLine{02788\ }
\DoxyCodeLine{02789\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ myDequeueCount\ =\ this-\/>dequeueOptimisticCount.fetch\_add(desiredCount,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02790\ }
\DoxyCodeLine{02791\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tail\ =\ this-\/>tailIndex.load(std::memory\_order\_acquire);}
\DoxyCodeLine{02792\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ actualCount\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(tail\ -\/\ (myDequeueCount\ -\/\ overcommit));}
\DoxyCodeLine{02793\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (details::circular\_less\_than<size\_t>(0,\ actualCount))\ \{}
\DoxyCodeLine{02794\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ actualCount\ =\ desiredCount\ <\ actualCount\ ?\ desiredCount\ :\ actualCount;}
\DoxyCodeLine{02795\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (actualCount\ <\ desiredCount)\ \{}
\DoxyCodeLine{02796\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>dequeueOvercommit.fetch\_add(desiredCount\ -\/\ actualCount,\ std::memory\_order\_release);}
\DoxyCodeLine{02797\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02798\ }
\DoxyCodeLine{02799\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ the\ first\ index.\ Note\ that\ since\ there's\ guaranteed\ to\ be\ at\ least\ actualCount\ elements,\ this}}
\DoxyCodeLine{02800\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ will\ never\ exceed\ tail.}}
\DoxyCodeLine{02801\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ firstIndex\ =\ this-\/>headIndex.fetch\_add(actualCount,\ std::memory\_order\_acq\_rel);}
\DoxyCodeLine{02802\ }
\DoxyCodeLine{02803\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Iterate\ the\ blocks\ and\ dequeue}}
\DoxyCodeLine{02804\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ index\ =\ firstIndex;}
\DoxyCodeLine{02805\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ BlockIndexHeader*\ localBlockIndex;}
\DoxyCodeLine{02806\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ indexIndex\ =\ get\_block\_index\_index\_for\_index(index,\ localBlockIndex);}
\DoxyCodeLine{02807\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{02808\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ blockStartIndex\ =\ index;}
\DoxyCodeLine{02809\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\_t\ endIndex\ =\ (index\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1))\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02810\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ endIndex\ =\ details::circular\_less\_than<index\_t>(firstIndex\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(actualCount),\ endIndex)\ ?\ firstIndex\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(actualCount)\ :\ endIndex;}
\DoxyCodeLine{02811\ }
\DoxyCodeLine{02812\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ entry\ =\ localBlockIndex-\/>index[indexIndex];}
\DoxyCodeLine{02813\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ entry-\/>value.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02814\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (MOODYCAMEL\_NOEXCEPT\_ASSIGN(T,\ T\&\&,\ details::deref\_noexcept(itemFirst)\ =\ std::move((*(*block)[index]))))\ \{}
\DoxyCodeLine{02815\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (index\ !=\ endIndex)\ \{}
\DoxyCodeLine{02816\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ el\ =\ *((*block)[index]);}
\DoxyCodeLine{02817\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *itemFirst++\ =\ std::move(el);}
\DoxyCodeLine{02818\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ el.\string~T();}
\DoxyCodeLine{02819\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++index;}
\DoxyCodeLine{02820\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02821\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02822\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02823\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_TRY\ \{}
\DoxyCodeLine{02824\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (index\ !=\ endIndex)\ \{}
\DoxyCodeLine{02825\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ el\ =\ *((*block)[index]);}
\DoxyCodeLine{02826\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *itemFirst\ =\ std::move(el);}
\DoxyCodeLine{02827\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++itemFirst;}
\DoxyCodeLine{02828\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ el.\string~T();}
\DoxyCodeLine{02829\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++index;}
\DoxyCodeLine{02830\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02831\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02832\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CATCH\ (...)\ \{}
\DoxyCodeLine{02833\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{02834\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry\ =\ localBlockIndex-\/>index[indexIndex];}
\DoxyCodeLine{02835\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ entry-\/>value.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02836\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (index\ !=\ endIndex)\ \{}
\DoxyCodeLine{02837\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (*block)[index++]-\/>\string~T();}
\DoxyCodeLine{02838\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02839\ }
\DoxyCodeLine{02840\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block-\/>ConcurrentQueue::Block::template\ set\_many\_empty<implicit\_context>(blockStartIndex,\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(endIndex\ -\/\ blockStartIndex)))\ \{}
\DoxyCodeLine{02841\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODBLOCKINDEX}}
\DoxyCodeLine{02842\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(mutex);}
\DoxyCodeLine{02843\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02844\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry-\/>value.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02845\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>parent-\/>add\_block\_to\_free\_list(block);}
\DoxyCodeLine{02846\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02847\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ indexIndex\ =\ (indexIndex\ +\ 1)\ \&\ (localBlockIndex-\/>capacity\ -\/\ 1);}
\DoxyCodeLine{02848\ }
\DoxyCodeLine{02849\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ blockStartIndex\ =\ index;}
\DoxyCodeLine{02850\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ endIndex\ =\ (index\ \&\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1))\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(BLOCK\_SIZE);}
\DoxyCodeLine{02851\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ endIndex\ =\ details::circular\_less\_than<index\_t>(firstIndex\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(actualCount),\ endIndex)\ ?\ firstIndex\ +\ \textcolor{keyword}{static\_cast<}index\_t\textcolor{keyword}{>}(actualCount)\ :\ endIndex;}
\DoxyCodeLine{02852\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (index\ !=\ firstIndex\ +\ actualCount);}
\DoxyCodeLine{02853\ }
\DoxyCodeLine{02854\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_RETHROW;}
\DoxyCodeLine{02855\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02856\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02857\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block-\/>ConcurrentQueue::Block::template\ set\_many\_empty<implicit\_context>(blockStartIndex,\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(endIndex\ -\/\ blockStartIndex)))\ \{}
\DoxyCodeLine{02858\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02859\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODBLOCKINDEX}}
\DoxyCodeLine{02860\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(mutex);}
\DoxyCodeLine{02861\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02862\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ the\ set\_many\_empty\ above\ did\ a\ release,\ meaning\ that\ anybody\ who\ acquires\ the\ block}}
\DoxyCodeLine{02863\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ we're\ about\ to\ free\ can\ use\ it\ safely\ since\ our\ writes\ (and\ reads!)\ will\ have\ happened-\/before\ then.}}
\DoxyCodeLine{02864\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry-\/>value.store(\textcolor{keyword}{nullptr},\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02865\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02866\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>parent-\/>add\_block\_to\_free\_list(block);\ \ \ \ \ \ \ \ \textcolor{comment}{//\ releases\ the\ above\ store}}
\DoxyCodeLine{02867\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02868\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ indexIndex\ =\ (indexIndex\ +\ 1)\ \&\ (localBlockIndex-\/>capacity\ -\/\ 1);}
\DoxyCodeLine{02869\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (index\ !=\ firstIndex\ +\ actualCount);}
\DoxyCodeLine{02870\ }
\DoxyCodeLine{02871\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ actualCount;}
\DoxyCodeLine{02872\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02873\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02874\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this-\/>dequeueOvercommit.fetch\_add(desiredCount,\ std::memory\_order\_release);}
\DoxyCodeLine{02875\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02876\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02877\ }
\DoxyCodeLine{02878\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{02879\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02880\ }
\DoxyCodeLine{02881\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02882\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ block\ size\ must\ be\ >\ 1,\ so\ any\ number\ with\ the\ low\ bit\ set\ is\ an\ invalid\ block\ base\ index}}
\DoxyCodeLine{02883\ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ index\_t\ INVALID\_BLOCK\_BASE\ =\ 1;}
\DoxyCodeLine{02884\ }
\DoxyCodeLine{02885\ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }BlockIndexEntry}
\DoxyCodeLine{02886\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02887\ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic<index\_t>\ key;}
\DoxyCodeLine{02888\ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic<Block*>\ value;}
\DoxyCodeLine{02889\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{02890\ }
\DoxyCodeLine{02891\ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }BlockIndexHeader}
\DoxyCodeLine{02892\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02893\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ capacity;}
\DoxyCodeLine{02894\ \ \ \ \ \ \ \ \ \ \ \ \ std::atomic<size\_t>\ tail;}
\DoxyCodeLine{02895\ \ \ \ \ \ \ \ \ \ \ \ \ BlockIndexEntry*\ entries;}
\DoxyCodeLine{02896\ \ \ \ \ \ \ \ \ \ \ \ \ BlockIndexEntry**\ index;}
\DoxyCodeLine{02897\ \ \ \ \ \ \ \ \ \ \ \ \ BlockIndexHeader*\ prev;}
\DoxyCodeLine{02898\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{02899\ }
\DoxyCodeLine{02900\ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}<AllocationMode\ allocMode>}
\DoxyCodeLine{02901\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ insert\_block\_index\_entry(BlockIndexEntry*\&\ idxEntry,\ index\_t\ blockStartIndex)}
\DoxyCodeLine{02902\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02903\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ localBlockIndex\ =\ blockIndex.load(std::memory\_order\_relaxed);\ \ \ \ \ \ \textcolor{comment}{//\ We're\ the\ only\ writer\ thread,\ relaxed\ is\ OK}}
\DoxyCodeLine{02904\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (localBlockIndex\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02905\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};\ \ \textcolor{comment}{//\ this\ can\ happen\ if\ new\_block\_index\ failed\ in\ the\ constructor}}
\DoxyCodeLine{02906\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02907\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ newTail\ =\ (localBlockIndex-\/>tail.load(std::memory\_order\_relaxed)\ +\ 1)\ \&\ (localBlockIndex-\/>capacity\ -\/\ 1);}
\DoxyCodeLine{02908\ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry\ =\ localBlockIndex-\/>index[newTail];}
\DoxyCodeLine{02909\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (idxEntry-\/>key.load(std::memory\_order\_relaxed)\ ==\ INVALID\_BLOCK\_BASE\ ||}
\DoxyCodeLine{02910\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry-\/>value.load(std::memory\_order\_relaxed)\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02911\ }
\DoxyCodeLine{02912\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry-\/>key.store(blockStartIndex,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02913\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ localBlockIndex-\/>tail.store(newTail,\ std::memory\_order\_release);}
\DoxyCodeLine{02914\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02915\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02916\ }
\DoxyCodeLine{02917\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ No\ room\ in\ the\ old\ block\ index,\ try\ to\ allocate\ another\ one!}}
\DoxyCodeLine{02918\ \ \ \ \ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (allocMode\ ==\ CannotAlloc)\ \{}
\DoxyCodeLine{02919\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02920\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02921\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (!new\_block\_index())\ \{}
\DoxyCodeLine{02922\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02923\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02924\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02925\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ localBlockIndex\ =\ blockIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02926\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newTail\ =\ (localBlockIndex-\/>tail.load(std::memory\_order\_relaxed)\ +\ 1)\ \&\ (localBlockIndex-\/>capacity\ -\/\ 1);}
\DoxyCodeLine{02927\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry\ =\ localBlockIndex-\/>index[newTail];}
\DoxyCodeLine{02928\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(idxEntry-\/>key.load(std::memory\_order\_relaxed)\ ==\ INVALID\_BLOCK\_BASE);}
\DoxyCodeLine{02929\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idxEntry-\/>key.store(blockStartIndex,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02930\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ localBlockIndex-\/>tail.store(newTail,\ std::memory\_order\_release);}
\DoxyCodeLine{02931\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02932\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02933\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02934\ }
\DoxyCodeLine{02935\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ rewind\_block\_index\_tail()}
\DoxyCodeLine{02936\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02937\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ localBlockIndex\ =\ blockIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02938\ \ \ \ \ \ \ \ \ \ \ \ \ localBlockIndex-\/>tail.store((localBlockIndex-\/>tail.load(std::memory\_order\_relaxed)\ -\/\ 1)\ \&\ (localBlockIndex-\/>capacity\ -\/\ 1),\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02939\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02940\ }
\DoxyCodeLine{02941\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ BlockIndexEntry*\ get\_block\_index\_entry\_for\_index(index\_t\ index)\textcolor{keyword}{\ const}}
\DoxyCodeLine{02942\ \textcolor{keyword}{\ \ \ \ \ \ \ \ }\{}
\DoxyCodeLine{02943\ \ \ \ \ \ \ \ \ \ \ \ \ BlockIndexHeader*\ localBlockIndex;}
\DoxyCodeLine{02944\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ idx\ =\ get\_block\_index\_index\_for\_index(index,\ localBlockIndex);}
\DoxyCodeLine{02945\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ localBlockIndex-\/>index[idx];}
\DoxyCodeLine{02946\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02947\ }
\DoxyCodeLine{02948\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{size\_t}\ get\_block\_index\_index\_for\_index(index\_t\ index,\ BlockIndexHeader*\&\ localBlockIndex)\textcolor{keyword}{\ const}}
\DoxyCodeLine{02949\ \textcolor{keyword}{\ \ \ \ \ \ \ \ }\{}
\DoxyCodeLine{02950\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODBLOCKINDEX}}
\DoxyCodeLine{02951\ \ \ \ \ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(mutex);}
\DoxyCodeLine{02952\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02953\ \ \ \ \ \ \ \ \ \ \ \ \ index\ \&=\ \string~static\_cast<index\_t>(BLOCK\_SIZE\ -\/\ 1);}
\DoxyCodeLine{02954\ \ \ \ \ \ \ \ \ \ \ \ \ localBlockIndex\ =\ blockIndex.load(std::memory\_order\_acquire);}
\DoxyCodeLine{02955\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tail\ =\ localBlockIndex-\/>tail.load(std::memory\_order\_acquire);}
\DoxyCodeLine{02956\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tailBase\ =\ localBlockIndex-\/>index[tail]-\/>key.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02957\ \ \ \ \ \ \ \ \ \ \ \ \ assert(tailBase\ !=\ INVALID\_BLOCK\_BASE);}
\DoxyCodeLine{02958\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note:\ Must\ use\ division\ instead\ of\ shift\ because\ the\ index\ may\ wrap\ around,\ causing\ a\ negative}}
\DoxyCodeLine{02959\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ offset,\ whose\ negativity\ we\ want\ to\ preserve}}
\DoxyCodeLine{02960\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ offset\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}typename\ std::make\_signed<index\_t>::type\textcolor{keyword}{>}(index\ -\/\ tailBase)\ /\ \textcolor{keyword}{static\_cast<}typename\ std::make\_signed<index\_t>::type\textcolor{keyword}{>}(BLOCK\_SIZE));}
\DoxyCodeLine{02961\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ idx\ =\ (tail\ +\ offset)\ \&\ (localBlockIndex-\/>capacity\ -\/\ 1);}
\DoxyCodeLine{02962\ \ \ \ \ \ \ \ \ \ \ \ \ assert(localBlockIndex-\/>index[idx]-\/>key.load(std::memory\_order\_relaxed)\ ==\ index\ \&\&\ localBlockIndex-\/>index[idx]-\/>value.load(std::memory\_order\_relaxed)\ !=\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{02963\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ idx;}
\DoxyCodeLine{02964\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02965\ }
\DoxyCodeLine{02966\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ new\_block\_index()}
\DoxyCodeLine{02967\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{02968\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prev\ =\ blockIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02969\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ prevCapacity\ =\ prev\ ==\ \textcolor{keyword}{nullptr}\ ?\ 0\ :\ prev-\/>capacity;}
\DoxyCodeLine{02970\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ entryCount\ =\ prev\ ==\ \textcolor{keyword}{nullptr}\ ?\ nextBlockIndexCapacity\ :\ prevCapacity;}
\DoxyCodeLine{02971\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ raw\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}((Traits::malloc)(}
\DoxyCodeLine{02972\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{sizeof}(BlockIndexHeader)\ +}
\DoxyCodeLine{02973\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::alignment\_of<BlockIndexEntry>::value\ -\/\ 1\ +\ \textcolor{keyword}{sizeof}(BlockIndexEntry)\ *\ entryCount\ +}
\DoxyCodeLine{02974\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::alignment\_of<BlockIndexEntry*>::value\ -\/\ 1\ +\ \textcolor{keyword}{sizeof}(BlockIndexEntry*)\ *\ nextBlockIndexCapacity));}
\DoxyCodeLine{02975\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (raw\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02976\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02977\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02978\ }
\DoxyCodeLine{02979\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ header\ =\ \textcolor{keyword}{new}\ (raw)\ BlockIndexHeader;}
\DoxyCodeLine{02980\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ entries\ =\ \textcolor{keyword}{reinterpret\_cast<}BlockIndexEntry*\textcolor{keyword}{>}(details::align\_for<BlockIndexEntry>(raw\ +\ \textcolor{keyword}{sizeof}(BlockIndexHeader)));}
\DoxyCodeLine{02981\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ index\ =\ \textcolor{keyword}{reinterpret\_cast<}BlockIndexEntry**\textcolor{keyword}{>}(details::align\_for<BlockIndexEntry*>(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(entries)\ +\ \textcolor{keyword}{sizeof}(BlockIndexEntry)\ *\ entryCount));}
\DoxyCodeLine{02982\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (prev\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02983\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prevTail\ =\ prev-\/>tail.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{02984\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prevPos\ =\ prevTail;}
\DoxyCodeLine{02985\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ i\ =\ 0;}
\DoxyCodeLine{02986\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{02987\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ prevPos\ =\ (prevPos\ +\ 1)\ \&\ (prev-\/>capacity\ -\/\ 1);}
\DoxyCodeLine{02988\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index[i++]\ =\ prev-\/>index[prevPos];}
\DoxyCodeLine{02989\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (prevPos\ !=\ prevTail);}
\DoxyCodeLine{02990\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(i\ ==\ prevCapacity);}
\DoxyCodeLine{02991\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02992\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ entryCount;\ ++i)\ \{}
\DoxyCodeLine{02993\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ (entries\ +\ i)\ BlockIndexEntry;}
\DoxyCodeLine{02994\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entries[i].key.store(INVALID\_BLOCK\_BASE,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{02995\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index[prevCapacity\ +\ i]\ =\ entries\ +\ i;}
\DoxyCodeLine{02996\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02997\ \ \ \ \ \ \ \ \ \ \ \ \ header-\/>prev\ =\ prev;}
\DoxyCodeLine{02998\ \ \ \ \ \ \ \ \ \ \ \ \ header-\/>entries\ =\ entries;}
\DoxyCodeLine{02999\ \ \ \ \ \ \ \ \ \ \ \ \ header-\/>index\ =\ index;}
\DoxyCodeLine{03000\ \ \ \ \ \ \ \ \ \ \ \ \ header-\/>capacity\ =\ nextBlockIndexCapacity;}
\DoxyCodeLine{03001\ \ \ \ \ \ \ \ \ \ \ \ \ header-\/>tail.store((prevCapacity\ -\/\ 1)\ \&\ (nextBlockIndexCapacity\ -\/\ 1),\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03002\ }
\DoxyCodeLine{03003\ \ \ \ \ \ \ \ \ \ \ \ \ blockIndex.store(header,\ std::memory\_order\_release);}
\DoxyCodeLine{03004\ }
\DoxyCodeLine{03005\ \ \ \ \ \ \ \ \ \ \ \ \ nextBlockIndexCapacity\ <<=\ 1;}
\DoxyCodeLine{03006\ }
\DoxyCodeLine{03007\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{03008\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03009\ }
\DoxyCodeLine{03010\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03011\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ nextBlockIndexCapacity;}
\DoxyCodeLine{03012\ \ \ \ \ \ \ \ \ std::atomic<BlockIndexHeader*>\ blockIndex;}
\DoxyCodeLine{03013\ }
\DoxyCodeLine{03014\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED}}
\DoxyCodeLine{03015\ \ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03016\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structmoodycamel_1_1details_1_1ThreadExitListener}{details::ThreadExitListener}}\ threadExitListener;}
\DoxyCodeLine{03017\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03018\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03019\ }
\DoxyCodeLine{03020\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_QUEUE\_INTERNAL\_DEBUG}}
\DoxyCodeLine{03021\ \ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03022\ \ \ \ \ \ \ \ \ ImplicitProducer*\ nextImplicitProducer;}
\DoxyCodeLine{03023\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03024\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03025\ }
\DoxyCodeLine{03026\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODBLOCKINDEX}}
\DoxyCodeLine{03027\ \ \ \ \ \ \ \ \ \textcolor{keyword}{mutable}\ debug::DebugMutex\ mutex;}
\DoxyCodeLine{03028\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03029\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{03030\ \ \ \ \ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{struct\ }MemStats;}
\DoxyCodeLine{03031\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03032\ \ \ \ \ \};}
\DoxyCodeLine{03033\ }
\DoxyCodeLine{03034\ }
\DoxyCodeLine{03036\ \ \ \ \ \textcolor{comment}{//\ Block\ pool\ manipulation}}
\DoxyCodeLine{03038\ }
\DoxyCodeLine{03039\ \ \ \ \ \textcolor{keywordtype}{void}\ populate\_initial\_block\_list(\textcolor{keywordtype}{size\_t}\ blockCount)}
\DoxyCodeLine{03040\ \ \ \ \ \{}
\DoxyCodeLine{03041\ \ \ \ \ \ \ \ \ initialBlockPoolSize\ =\ blockCount;}
\DoxyCodeLine{03042\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (initialBlockPoolSize\ ==\ 0)\ \{}
\DoxyCodeLine{03043\ \ \ \ \ \ \ \ \ \ \ \ \ initialBlockPool\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03044\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{03045\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03046\ }
\DoxyCodeLine{03047\ \ \ \ \ \ \ \ \ initialBlockPool\ =\ create\_array<Block>(blockCount);}
\DoxyCodeLine{03048\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (initialBlockPool\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03049\ \ \ \ \ \ \ \ \ \ \ \ \ initialBlockPoolSize\ =\ 0;}
\DoxyCodeLine{03050\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03051\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ initialBlockPoolSize;\ ++i)\ \{}
\DoxyCodeLine{03052\ \ \ \ \ \ \ \ \ \ \ \ \ initialBlockPool[i].dynamicallyAllocated\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{03053\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03054\ \ \ \ \ \}}
\DoxyCodeLine{03055\ }
\DoxyCodeLine{03056\ \ \ \ \ \textcolor{keyword}{inline}\ Block*\ try\_get\_block\_from\_initial\_pool()}
\DoxyCodeLine{03057\ \ \ \ \ \{}
\DoxyCodeLine{03058\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (initialBlockPoolIndex.load(std::memory\_order\_relaxed)\ >=\ initialBlockPoolSize)\ \{}
\DoxyCodeLine{03059\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03060\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03061\ }
\DoxyCodeLine{03062\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ index\ =\ initialBlockPoolIndex.fetch\_add(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03063\ }
\DoxyCodeLine{03064\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ index\ <\ initialBlockPoolSize\ ?\ (initialBlockPool\ +\ index)\ :\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03065\ \ \ \ \ \}}
\DoxyCodeLine{03066\ }
\DoxyCodeLine{03067\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ add\_block\_to\_free\_list(Block*\ block)}
\DoxyCodeLine{03068\ \ \ \ \ \{}
\DoxyCodeLine{03069\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{03070\ \ \ \ \ \ \ \ \ block-\/>owner\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03071\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03072\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!Traits::RECYCLE\_ALLOCATED\_BLOCKS\ \&\&\ block-\/>dynamicallyAllocated)\ \{}
\DoxyCodeLine{03073\ \ \ \ \ \ \ \ \ \ \ \ \ destroy(block);}
\DoxyCodeLine{03074\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03075\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03076\ \ \ \ \ \ \ \ \ \ \ \ \ freeList.add(block);}
\DoxyCodeLine{03077\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03078\ \ \ \ \ \}}
\DoxyCodeLine{03079\ }
\DoxyCodeLine{03080\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ add\_blocks\_to\_free\_list(Block*\ block)}
\DoxyCodeLine{03081\ \ \ \ \ \{}
\DoxyCodeLine{03082\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (block\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03083\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ next\ =\ block-\/>next;}
\DoxyCodeLine{03084\ \ \ \ \ \ \ \ \ \ \ \ \ add\_block\_to\_free\_list(block);}
\DoxyCodeLine{03085\ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ next;}
\DoxyCodeLine{03086\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03087\ \ \ \ \ \}}
\DoxyCodeLine{03088\ }
\DoxyCodeLine{03089\ \ \ \ \ \textcolor{keyword}{inline}\ Block*\ try\_get\_block\_from\_free\_list()}
\DoxyCodeLine{03090\ \ \ \ \ \{}
\DoxyCodeLine{03091\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ freeList.try\_get();}
\DoxyCodeLine{03092\ \ \ \ \ \}}
\DoxyCodeLine{03093\ }
\DoxyCodeLine{03094\ \ \ \ \ \textcolor{comment}{//\ Gets\ a\ free\ block\ from\ one\ of\ the\ memory\ pools,\ or\ allocates\ a\ new\ one\ (if\ applicable)}}
\DoxyCodeLine{03095\ \ \ \ \ \textcolor{keyword}{template}<AllocationMode\ canAlloc>}
\DoxyCodeLine{03096\ \ \ \ \ Block*\ requisition\_block()}
\DoxyCodeLine{03097\ \ \ \ \ \{}
\DoxyCodeLine{03098\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ try\_get\_block\_from\_initial\_pool();}
\DoxyCodeLine{03099\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03100\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ block;}
\DoxyCodeLine{03101\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03102\ }
\DoxyCodeLine{03103\ \ \ \ \ \ \ \ \ block\ =\ try\_get\_block\_from\_free\_list();}
\DoxyCodeLine{03104\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (block\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03105\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ block;}
\DoxyCodeLine{03106\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03107\ }
\DoxyCodeLine{03108\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (canAlloc\ ==\ CanAlloc)\ \{}
\DoxyCodeLine{03109\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ create<Block>();}
\DoxyCodeLine{03110\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03111\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03112\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03113\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03114\ \ \ \ \ \}}
\DoxyCodeLine{03115\ }
\DoxyCodeLine{03116\ }
\DoxyCodeLine{03117\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_TRACKMEM}}
\DoxyCodeLine{03118\ \ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03119\ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }MemStats\ \{}
\DoxyCodeLine{03120\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ allocatedBlocks;}
\DoxyCodeLine{03121\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ usedBlocks;}
\DoxyCodeLine{03122\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ freeBlocks;}
\DoxyCodeLine{03123\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ ownedBlocksExplicit;}
\DoxyCodeLine{03124\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ ownedBlocksImplicit;}
\DoxyCodeLine{03125\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ implicitProducers;}
\DoxyCodeLine{03126\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ explicitProducers;}
\DoxyCodeLine{03127\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ elementsEnqueued;}
\DoxyCodeLine{03128\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ blockClassBytes;}
\DoxyCodeLine{03129\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ queueClassBytes;}
\DoxyCodeLine{03130\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ implicitBlockIndexBytes;}
\DoxyCodeLine{03131\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ explicitBlockIndexBytes;}
\DoxyCodeLine{03132\ }
\DoxyCodeLine{03133\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}};}
\DoxyCodeLine{03134\ }
\DoxyCodeLine{03135\ \ \ \ \ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03136\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static}\ MemStats\ getFor(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}*\ q)}
\DoxyCodeLine{03137\ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{03138\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MemStats\ stats\ =\ \{\ 0\ \};}
\DoxyCodeLine{03139\ }
\DoxyCodeLine{03140\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.elementsEnqueued\ =\ q-\/>size\_approx();}
\DoxyCodeLine{03141\ }
\DoxyCodeLine{03142\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ q-\/>freeList.head\_unsafe();}
\DoxyCodeLine{03143\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (block\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03144\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++stats.allocatedBlocks;}
\DoxyCodeLine{03145\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++stats.freeBlocks;}
\DoxyCodeLine{03146\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ block-\/>freeListNext.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{03147\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03148\ }
\DoxyCodeLine{03149\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ ptr\ =\ q-\/>producerListTail.load(std::memory\_order\_acquire);\ ptr\ !=\ \textcolor{keyword}{nullptr};\ ptr\ =\ ptr-\/>next\_prod())\ \{}
\DoxyCodeLine{03150\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ implicit\ =\ \textcolor{keyword}{dynamic\_cast<}ImplicitProducer*\textcolor{keyword}{>}(ptr)\ !=\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03151\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.implicitProducers\ +=\ implicit\ ?\ 1\ :\ 0;}
\DoxyCodeLine{03152\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.explicitProducers\ +=\ implicit\ ?\ 0\ :\ 1;}
\DoxyCodeLine{03153\ }
\DoxyCodeLine{03154\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (implicit)\ \{}
\DoxyCodeLine{03155\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prod\ =\ \textcolor{keyword}{static\_cast<}ImplicitProducer*\textcolor{keyword}{>}(ptr);}
\DoxyCodeLine{03156\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.queueClassBytes\ +=\ \textcolor{keyword}{sizeof}(ImplicitProducer);}
\DoxyCodeLine{03157\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ head\ =\ prod-\/>headIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{03158\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tail\ =\ prod-\/>tailIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{03159\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ hash\ =\ prod-\/>blockIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{03160\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (hash\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03161\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ hash-\/>capacity;\ ++i)\ \{}
\DoxyCodeLine{03162\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (hash-\/>index[i]-\/>key.load(std::memory\_order\_relaxed)\ !=\ ImplicitProducer::INVALID\_BLOCK\_BASE\ \&\&\ hash-\/>index[i]-\/>value.load(std::memory\_order\_relaxed)\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03163\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++stats.allocatedBlocks;}
\DoxyCodeLine{03164\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++stats.ownedBlocksImplicit;}
\DoxyCodeLine{03165\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03166\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03167\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.implicitBlockIndexBytes\ +=\ hash-\/>capacity\ *\ \textcolor{keyword}{sizeof}(\textcolor{keyword}{typename}\ ImplicitProducer::BlockIndexEntry);}
\DoxyCodeLine{03168\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ hash\ !=\ \textcolor{keyword}{nullptr};\ hash\ =\ hash-\/>prev)\ \{}
\DoxyCodeLine{03169\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.implicitBlockIndexBytes\ +=\ \textcolor{keyword}{sizeof}(\textcolor{keyword}{typename}\ ImplicitProducer::BlockIndexHeader)\ +\ hash-\/>capacity\ *\ \textcolor{keyword}{sizeof}(\textcolor{keyword}{typename}\ ImplicitProducer::BlockIndexEntry*);}
\DoxyCodeLine{03170\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03171\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03172\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ details::circular\_less\_than<index\_t>(head,\ tail);\ head\ +=\ BLOCK\_SIZE)\ \{}
\DoxyCodeLine{03173\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//auto\ block\ =\ prod-\/>get\_block\_index\_entry\_for\_index(head);}}
\DoxyCodeLine{03174\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++stats.usedBlocks;}
\DoxyCodeLine{03175\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03176\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03177\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03178\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prod\ =\ \textcolor{keyword}{static\_cast<}ExplicitProducer*\textcolor{keyword}{>}(ptr);}
\DoxyCodeLine{03179\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.queueClassBytes\ +=\ \textcolor{keyword}{sizeof}(ExplicitProducer);}
\DoxyCodeLine{03180\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tailBlock\ =\ prod-\/>tailBlock;}
\DoxyCodeLine{03181\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ wasNonEmpty\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{03182\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (tailBlock\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03183\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ block\ =\ tailBlock;}
\DoxyCodeLine{03184\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{03185\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++stats.allocatedBlocks;}
\DoxyCodeLine{03186\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!block-\/>ConcurrentQueue::Block::template\ is\_empty<explicit\_context>()\ ||\ wasNonEmpty)\ \{}
\DoxyCodeLine{03187\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++stats.usedBlocks;}
\DoxyCodeLine{03188\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ wasNonEmpty\ =\ wasNonEmpty\ ||\ block\ !=\ tailBlock;}
\DoxyCodeLine{03189\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03190\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++stats.ownedBlocksExplicit;}
\DoxyCodeLine{03191\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\ =\ block-\/>next;}
\DoxyCodeLine{03192\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (block\ !=\ tailBlock);}
\DoxyCodeLine{03193\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03194\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ index\ =\ prod-\/>blockIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{03195\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (index\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03196\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.explicitBlockIndexBytes\ +=\ \textcolor{keyword}{sizeof}(\textcolor{keyword}{typename}\ ExplicitProducer::BlockIndexHeader)\ +\ index-\/>size\ *\ \textcolor{keyword}{sizeof}(\textcolor{keyword}{typename}\ ExplicitProducer::BlockIndexEntry);}
\DoxyCodeLine{03197\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\ =\ \textcolor{keyword}{static\_cast<}typename\ ExplicitProducer::BlockIndexHeader*\textcolor{keyword}{>}(index-\/>prev);}
\DoxyCodeLine{03198\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03199\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03200\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03201\ }
\DoxyCodeLine{03202\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ freeOnInitialPool\ =\ q-\/>initialBlockPoolIndex.load(std::memory\_order\_relaxed)\ >=\ q-\/>initialBlockPoolSize\ ?\ 0\ :\ q-\/>initialBlockPoolSize\ -\/\ q-\/>initialBlockPoolIndex.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{03203\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.allocatedBlocks\ +=\ freeOnInitialPool;}
\DoxyCodeLine{03204\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.freeBlocks\ +=\ freeOnInitialPool;}
\DoxyCodeLine{03205\ }
\DoxyCodeLine{03206\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.blockClassBytes\ =\ \textcolor{keyword}{sizeof}(Block)\ *\ stats.allocatedBlocks;}
\DoxyCodeLine{03207\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stats.queueClassBytes\ +=\ \textcolor{keyword}{sizeof}(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}});}
\DoxyCodeLine{03208\ }
\DoxyCodeLine{03209\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ stats;}
\DoxyCodeLine{03210\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03211\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{03212\ }
\DoxyCodeLine{03213\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ For\ debugging\ only.\ Not\ thread-\/safe.}}
\DoxyCodeLine{03214\ \ \ \ \ \ \ \ \ MemStats\ getMemStats()}
\DoxyCodeLine{03215\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{03216\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ MemStats::getFor(\textcolor{keyword}{this});}
\DoxyCodeLine{03217\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03218\ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03219\ \ \ \ \ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{struct\ }MemStats;}
\DoxyCodeLine{03220\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03221\ }
\DoxyCodeLine{03222\ }
\DoxyCodeLine{03224\ \ \ \ \ \textcolor{comment}{//\ Producer\ list\ manipulation}}
\DoxyCodeLine{03226\ }
\DoxyCodeLine{03227\ \ \ \ \ ProducerBase*\ recycle\_or\_create\_producer(\textcolor{keywordtype}{bool}\ isExplicit)}
\DoxyCodeLine{03228\ \ \ \ \ \{}
\DoxyCodeLine{03229\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODHASH}}
\DoxyCodeLine{03230\ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(implicitProdMutex);}
\DoxyCodeLine{03231\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03232\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Try\ to\ re-\/use\ one\ first}}
\DoxyCodeLine{03233\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ ptr\ =\ producerListTail.load(std::memory\_order\_acquire);\ ptr\ !=\ \textcolor{keyword}{nullptr};\ ptr\ =\ ptr-\/>next\_prod())\ \{}
\DoxyCodeLine{03234\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr-\/>inactive.load(std::memory\_order\_relaxed)\ \&\&\ ptr-\/>isExplicit\ ==\ isExplicit)\ \{}
\DoxyCodeLine{03235\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ expected\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{03236\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr-\/>inactive.compare\_exchange\_strong(expected,\ \textcolor{comment}{/*\ desired\ */}\ \textcolor{keyword}{false},\ std::memory\_order\_acquire,\ std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{03237\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ caught\ one!\ It's\ been\ marked\ as\ activated,\ the\ caller\ can\ have\ it}}
\DoxyCodeLine{03238\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ptr;}
\DoxyCodeLine{03239\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03240\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03241\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03242\ }
\DoxyCodeLine{03243\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ add\_producer(isExplicit\ ?\ \textcolor{keyword}{static\_cast<}ProducerBase*\textcolor{keyword}{>}(create<ExplicitProducer>(\textcolor{keyword}{this}))\ :\ create<ImplicitProducer>(\textcolor{keyword}{this}));}
\DoxyCodeLine{03244\ \ \ \ \ \}}
\DoxyCodeLine{03245\ }
\DoxyCodeLine{03246\ \ \ \ \ ProducerBase*\ add\_producer(ProducerBase*\ producer)}
\DoxyCodeLine{03247\ \ \ \ \ \{}
\DoxyCodeLine{03248\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Handle\ failed\ memory\ allocation}}
\DoxyCodeLine{03249\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (producer\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03250\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03251\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03252\ }
\DoxyCodeLine{03253\ \ \ \ \ \ \ \ \ producerCount.fetch\_add(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03254\ }
\DoxyCodeLine{03255\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Add\ it\ to\ the\ lock-\/free\ list}}
\DoxyCodeLine{03256\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prevTail\ =\ producerListTail.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{03257\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{03258\ \ \ \ \ \ \ \ \ \ \ \ \ producer-\/>next\ =\ prevTail;}
\DoxyCodeLine{03259\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (!producerListTail.compare\_exchange\_weak(prevTail,\ producer,\ std::memory\_order\_release,\ std::memory\_order\_relaxed));}
\DoxyCodeLine{03260\ }
\DoxyCodeLine{03261\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_QUEUE\_INTERNAL\_DEBUG}}
\DoxyCodeLine{03262\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (producer-\/>isExplicit)\ \{}
\DoxyCodeLine{03263\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prevTailExplicit\ =\ explicitProducers.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{03264\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{03265\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_cast<}ExplicitProducer*\textcolor{keyword}{>}(producer)-\/>nextExplicitProducer\ =\ prevTailExplicit;}
\DoxyCodeLine{03266\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (!explicitProducers.compare\_exchange\_weak(prevTailExplicit,\ \textcolor{keyword}{static\_cast<}ExplicitProducer*\textcolor{keyword}{>}(producer),\ std::memory\_order\_release,\ std::memory\_order\_relaxed));}
\DoxyCodeLine{03267\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03268\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03269\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ prevTailImplicit\ =\ implicitProducers.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{03270\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{03271\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_cast<}ImplicitProducer*\textcolor{keyword}{>}(producer)-\/>nextImplicitProducer\ =\ prevTailImplicit;}
\DoxyCodeLine{03272\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (!implicitProducers.compare\_exchange\_weak(prevTailImplicit,\ \textcolor{keyword}{static\_cast<}ImplicitProducer*\textcolor{keyword}{>}(producer),\ std::memory\_order\_release,\ std::memory\_order\_relaxed));}
\DoxyCodeLine{03273\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03274\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03275\ }
\DoxyCodeLine{03276\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ producer;}
\DoxyCodeLine{03277\ \ \ \ \ \}}
\DoxyCodeLine{03278\ }
\DoxyCodeLine{03279\ \ \ \ \ \textcolor{keywordtype}{void}\ reown\_producers()}
\DoxyCodeLine{03280\ \ \ \ \ \{}
\DoxyCodeLine{03281\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ After\ another\ instance\ is\ moved-\/into/swapped-\/with\ this\ one,\ all\ the}}
\DoxyCodeLine{03282\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ producers\ we\ stole\ still\ think\ their\ parents\ are\ the\ other\ queue.}}
\DoxyCodeLine{03283\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ So\ fix\ them\ up!}}
\DoxyCodeLine{03284\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ ptr\ =\ producerListTail.load(std::memory\_order\_relaxed);\ ptr\ !=\ \textcolor{keyword}{nullptr};\ ptr\ =\ ptr-\/>next\_prod())\ \{}
\DoxyCodeLine{03285\ \ \ \ \ \ \ \ \ \ \ \ \ ptr-\/>parent\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{03286\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03287\ \ \ \ \ \}}
\DoxyCodeLine{03288\ }
\DoxyCodeLine{03289\ }
\DoxyCodeLine{03291\ \ \ \ \ \textcolor{comment}{//\ Implicit\ producer\ hash}}
\DoxyCodeLine{03293\ }
\DoxyCodeLine{03294\ \ \ \ \ \textcolor{keyword}{struct\ }ImplicitProducerKVP}
\DoxyCodeLine{03295\ \ \ \ \ \{}
\DoxyCodeLine{03296\ \ \ \ \ \ \ \ \ std::atomic<details::thread\_id\_t>\ key;}
\DoxyCodeLine{03297\ \ \ \ \ \ \ \ \ ImplicitProducer*\ value;\ \ \ \ \ \ \ \ \textcolor{comment}{//\ No\ need\ for\ atomicity\ since\ it's\ only\ read\ by\ the\ thread\ that\ sets\ it\ in\ the\ first\ place}}
\DoxyCodeLine{03298\ }
\DoxyCodeLine{03299\ \ \ \ \ \ \ \ \ ImplicitProducerKVP()\ :\ value(\textcolor{keyword}{nullptr})\ \{\ \}}
\DoxyCodeLine{03300\ }
\DoxyCodeLine{03301\ \ \ \ \ \ \ \ \ ImplicitProducerKVP(ImplicitProducerKVP\&\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{03302\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{03303\ \ \ \ \ \ \ \ \ \ \ \ \ key.store(other.key.load(std::memory\_order\_relaxed),\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03304\ \ \ \ \ \ \ \ \ \ \ \ \ value\ =\ other.value;}
\DoxyCodeLine{03305\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03306\ }
\DoxyCodeLine{03307\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ ImplicitProducerKVP\&\ operator=(ImplicitProducerKVP\&\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{03308\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{03309\ \ \ \ \ \ \ \ \ \ \ \ \ swap(other);}
\DoxyCodeLine{03310\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{03311\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03312\ }
\DoxyCodeLine{03313\ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ swap(ImplicitProducerKVP\&\ other)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{03314\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{03315\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{this}\ !=\ \&other)\ \{}
\DoxyCodeLine{03316\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ details::swap\_relaxed(key,\ other.key);}
\DoxyCodeLine{03317\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::swap(value,\ other.value);}
\DoxyCodeLine{03318\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03319\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03320\ \ \ \ \ \};}
\DoxyCodeLine{03321\ }
\DoxyCodeLine{03322\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ XT,\ \textcolor{keyword}{typename}\ XTraits>}
\DoxyCodeLine{03323\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keywordtype}{void}\ moodycamel::swap(\textcolor{keyword}{typename}\ ConcurrentQueue<XT,\ XTraits>::ImplicitProducerKVP\&,\ \textcolor{keyword}{typename}\ ConcurrentQueue<XT,\ XTraits>::ImplicitProducerKVP\&)\ MOODYCAMEL\_NOEXCEPT;}
\DoxyCodeLine{03324\ }
\DoxyCodeLine{03325\ \ \ \ \ \textcolor{keyword}{struct\ }ImplicitProducerHash}
\DoxyCodeLine{03326\ \ \ \ \ \{}
\DoxyCodeLine{03327\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ capacity;}
\DoxyCodeLine{03328\ \ \ \ \ \ \ \ \ ImplicitProducerKVP*\ entries;}
\DoxyCodeLine{03329\ \ \ \ \ \ \ \ \ ImplicitProducerHash*\ prev;}
\DoxyCodeLine{03330\ \ \ \ \ \};}
\DoxyCodeLine{03331\ }
\DoxyCodeLine{03332\ \ \ \ \ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ populate\_initial\_implicit\_producer\_hash()}
\DoxyCodeLine{03333\ \ \ \ \ \{}
\DoxyCodeLine{03334\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ ==\ 0)\ \{}
\DoxyCodeLine{03335\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{03336\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03337\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03338\ \ \ \ \ \ \ \ \ \ \ \ \ implicitProducerHashCount.store(0,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03339\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ hash\ =\ \&initialImplicitProducerHash;}
\DoxyCodeLine{03340\ \ \ \ \ \ \ \ \ \ \ \ \ hash-\/>capacity\ =\ INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE;}
\DoxyCodeLine{03341\ \ \ \ \ \ \ \ \ \ \ \ \ hash-\/>entries\ =\ \&initialImplicitProducerHashEntries[0];}
\DoxyCodeLine{03342\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE;\ ++i)\ \{}
\DoxyCodeLine{03343\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ initialImplicitProducerHashEntries[i].key.store(details::invalid\_thread\_id,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03344\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03345\ \ \ \ \ \ \ \ \ \ \ \ \ hash-\/>prev\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03346\ \ \ \ \ \ \ \ \ \ \ \ \ implicitProducerHash.store(hash,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03347\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03348\ \ \ \ \ \}}
\DoxyCodeLine{03349\ }
\DoxyCodeLine{03350\ \ \ \ \ \textcolor{keywordtype}{void}\ swap\_implicit\_producer\_hashes(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue}}\&\ other)}
\DoxyCodeLine{03351\ \ \ \ \ \{}
\DoxyCodeLine{03352\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE\ ==\ 0)\ \{}
\DoxyCodeLine{03353\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{03354\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03355\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03356\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Swap\ (assumes\ our\ implicit\ producer\ hash\ is\ initialized)}}
\DoxyCodeLine{03357\ \ \ \ \ \ \ \ \ \ \ \ \ initialImplicitProducerHashEntries.swap(other.initialImplicitProducerHashEntries);}
\DoxyCodeLine{03358\ \ \ \ \ \ \ \ \ \ \ \ \ initialImplicitProducerHash.entries\ =\ \&initialImplicitProducerHashEntries[0];}
\DoxyCodeLine{03359\ \ \ \ \ \ \ \ \ \ \ \ \ other.initialImplicitProducerHash.entries\ =\ \&other.initialImplicitProducerHashEntries[0];}
\DoxyCodeLine{03360\ }
\DoxyCodeLine{03361\ \ \ \ \ \ \ \ \ \ \ \ \ details::swap\_relaxed(implicitProducerHashCount,\ other.implicitProducerHashCount);}
\DoxyCodeLine{03362\ }
\DoxyCodeLine{03363\ \ \ \ \ \ \ \ \ \ \ \ \ details::swap\_relaxed(implicitProducerHash,\ other.implicitProducerHash);}
\DoxyCodeLine{03364\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (implicitProducerHash.load(std::memory\_order\_relaxed)\ ==\ \&other.initialImplicitProducerHash)\ \{}
\DoxyCodeLine{03365\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ implicitProducerHash.store(\&initialImplicitProducerHash,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03366\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03367\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03368\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ImplicitProducerHash*\ hash;}
\DoxyCodeLine{03369\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (hash\ =\ implicitProducerHash.load(std::memory\_order\_relaxed);\ hash-\/>prev\ !=\ \&other.initialImplicitProducerHash;\ hash\ =\ hash-\/>prev)\ \{}
\DoxyCodeLine{03370\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{03371\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03372\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ hash-\/>prev\ =\ \&initialImplicitProducerHash;}
\DoxyCodeLine{03373\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03374\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (other.implicitProducerHash.load(std::memory\_order\_relaxed)\ ==\ \&initialImplicitProducerHash)\ \{}
\DoxyCodeLine{03375\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ other.implicitProducerHash.store(\&other.initialImplicitProducerHash,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03376\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03377\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03378\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ImplicitProducerHash*\ hash;}
\DoxyCodeLine{03379\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (hash\ =\ other.implicitProducerHash.load(std::memory\_order\_relaxed);\ hash-\/>prev\ !=\ \&initialImplicitProducerHash;\ hash\ =\ hash-\/>prev)\ \{}
\DoxyCodeLine{03380\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{03381\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03382\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ hash-\/>prev\ =\ \&other.initialImplicitProducerHash;}
\DoxyCodeLine{03383\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03384\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03385\ \ \ \ \ \}}
\DoxyCodeLine{03386\ }
\DoxyCodeLine{03387\ \ \ \ \ \textcolor{comment}{//\ Only\ fails\ (returns\ nullptr)\ if\ memory\ allocation\ fails}}
\DoxyCodeLine{03388\ \ \ \ \ ImplicitProducer*\ get\_or\_add\_implicit\_producer()}
\DoxyCodeLine{03389\ \ \ \ \ \{}
\DoxyCodeLine{03390\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ since\ the\ data\ is\ essentially\ thread-\/local\ (key\ is\ thread\ ID),}}
\DoxyCodeLine{03391\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ there's\ a\ reduced\ need\ for\ fences\ (memory\ ordering\ is\ already\ consistent}}
\DoxyCodeLine{03392\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ for\ any\ individual\ thread),\ except\ for\ the\ current\ table\ itself.}}
\DoxyCodeLine{03393\ }
\DoxyCodeLine{03394\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Start\ by\ looking\ for\ the\ thread\ ID\ in\ the\ current\ and\ all\ previous\ hash\ tables.}}
\DoxyCodeLine{03395\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ it's\ not\ found,\ it\ must\ not\ be\ in\ there\ yet,\ since\ this\ same\ thread\ would}}
\DoxyCodeLine{03396\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ have\ added\ it\ previously\ to\ one\ of\ the\ tables\ that\ we\ traversed.}}
\DoxyCodeLine{03397\ }
\DoxyCodeLine{03398\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Code\ and\ algorithm\ adapted\ from\ http://preshing.com/20130605/the-\/worlds-\/simplest-\/lock-\/free-\/hash-\/table}}
\DoxyCodeLine{03399\ }
\DoxyCodeLine{03400\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODHASH}}
\DoxyCodeLine{03401\ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(implicitProdMutex);}
\DoxyCodeLine{03402\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03403\ }
\DoxyCodeLine{03404\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ \textcolor{keywordtype}{id}\ =\ details::thread\_id();}
\DoxyCodeLine{03405\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ hashedId\ =\ details::hash\_thread\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{03406\ }
\DoxyCodeLine{03407\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ mainHash\ =\ implicitProducerHash.load(std::memory\_order\_acquire);}
\DoxyCodeLine{03408\ \ \ \ \ \ \ \ \ assert(mainHash\ !=\ \textcolor{keyword}{nullptr});\ \ \textcolor{comment}{//\ silence\ clang-\/tidy\ and\ MSVC\ warnings\ (hash\ cannot\ be\ null)}}
\DoxyCodeLine{03409\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ hash\ =\ mainHash;\ hash\ !=\ \textcolor{keyword}{nullptr};\ hash\ =\ hash-\/>prev)\ \{}
\DoxyCodeLine{03410\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Look\ for\ the\ id\ in\ this\ hash}}
\DoxyCodeLine{03411\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ index\ =\ hashedId;}
\DoxyCodeLine{03412\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{\ \ \ \ \ \ \textcolor{comment}{//\ Not\ an\ infinite\ loop\ because\ at\ least\ one\ slot\ is\ free\ in\ the\ hash\ table}}
\DoxyCodeLine{03413\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\ \&=\ hash-\/>capacity\ -\/\ 1u;}
\DoxyCodeLine{03414\ }
\DoxyCodeLine{03415\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ probedKey\ =\ hash-\/>entries[index].key.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{03416\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (probedKey\ ==\ \textcolor{keywordtype}{id})\ \{}
\DoxyCodeLine{03417\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Found\ it!\ If\ we\ had\ to\ search\ several\ hashes\ deep,\ though,\ we\ should\ lazily\ add\ it}}
\DoxyCodeLine{03418\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ to\ the\ current\ main\ hash\ table\ to\ avoid\ the\ extended\ search\ next\ time.}}
\DoxyCodeLine{03419\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ there's\ guaranteed\ to\ be\ room\ in\ the\ current\ hash\ table\ since\ every\ subsequent}}
\DoxyCodeLine{03420\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ table\ implicitly\ reserves\ space\ for\ all\ previous\ tables\ (there's\ only\ one}}
\DoxyCodeLine{03421\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ implicitProducerHashCount).}}
\DoxyCodeLine{03422\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ value\ =\ hash-\/>entries[index].value;}
\DoxyCodeLine{03423\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (hash\ !=\ mainHash)\ \{}
\DoxyCodeLine{03424\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\ =\ hashedId;}
\DoxyCodeLine{03425\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{03426\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\ \&=\ mainHash-\/>capacity\ -\/\ 1u;}
\DoxyCodeLine{03427\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ empty\ =\ details::invalid\_thread\_id;}
\DoxyCodeLine{03428\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED}}
\DoxyCodeLine{03429\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ reusable\ =\ details::invalid\_thread\_id2;}
\DoxyCodeLine{03430\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (mainHash-\/>entries[index].key.compare\_exchange\_strong(empty,\ \ \ \ \textcolor{keywordtype}{id},\ std::memory\_order\_seq\_cst,\ std::memory\_order\_relaxed)\ ||}
\DoxyCodeLine{03431\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ mainHash-\/>entries[index].key.compare\_exchange\_strong(reusable,\ \textcolor{keywordtype}{id},\ std::memory\_order\_seq\_cst,\ std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{03432\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{03433\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (mainHash-\/>entries[index].key.compare\_exchange\_strong(empty,\ \ \ \ \textcolor{keywordtype}{id},\ std::memory\_order\_seq\_cst,\ std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{03434\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03435\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ mainHash-\/>entries[index].value\ =\ value;}
\DoxyCodeLine{03436\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{03437\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03438\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++index;}
\DoxyCodeLine{03439\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03440\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03441\ }
\DoxyCodeLine{03442\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ value;}
\DoxyCodeLine{03443\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03444\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (probedKey\ ==\ details::invalid\_thread\_id)\ \{}
\DoxyCodeLine{03445\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};\ \ \ \ \ \ \textcolor{comment}{//\ Not\ in\ this\ hash\ table}}
\DoxyCodeLine{03446\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03447\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++index;}
\DoxyCodeLine{03448\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03449\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03450\ }
\DoxyCodeLine{03451\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Insert!}}
\DoxyCodeLine{03452\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ newCount\ =\ 1\ +\ implicitProducerHashCount.fetch\_add(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03453\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{03454\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ NOLINTNEXTLINE(clang-\/analyzer-\/core.NullDereference)}}
\DoxyCodeLine{03455\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (newCount\ >=\ (mainHash-\/>capacity\ >>\ 1)\ \&\&\ !implicitProducerHashResizeInProgress.test\_and\_set(std::memory\_order\_acquire))\ \{}
\DoxyCodeLine{03456\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We've\ acquired\ the\ resize\ lock,\ try\ to\ allocate\ a\ bigger\ hash\ table.}}
\DoxyCodeLine{03457\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ the\ acquire\ fence\ synchronizes\ with\ the\ release\ fence\ at\ the\ end\ of\ this\ block,\ and\ hence\ when}}
\DoxyCodeLine{03458\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ we\ reload\ implicitProducerHash\ it\ must\ be\ the\ most\ recent\ version\ (it\ only\ gets\ changed\ within\ this}}
\DoxyCodeLine{03459\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ locked\ block).}}
\DoxyCodeLine{03460\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ mainHash\ =\ implicitProducerHash.load(std::memory\_order\_acquire);}
\DoxyCodeLine{03461\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (newCount\ >=\ (mainHash-\/>capacity\ >>\ 1))\ \{}
\DoxyCodeLine{03462\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ newCapacity\ =\ mainHash-\/>capacity\ <<\ 1;}
\DoxyCodeLine{03463\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (newCount\ >=\ (newCapacity\ >>\ 1))\ \{}
\DoxyCodeLine{03464\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newCapacity\ <<=\ 1;}
\DoxyCodeLine{03465\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03466\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ raw\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}((Traits::malloc)(\textcolor{keyword}{sizeof}(ImplicitProducerHash)\ +\ std::alignment\_of<ImplicitProducerKVP>::value\ -\/\ 1\ +\ \textcolor{keyword}{sizeof}(ImplicitProducerKVP)\ *\ newCapacity));}
\DoxyCodeLine{03467\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (raw\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03468\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Allocation\ failed}}
\DoxyCodeLine{03469\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ implicitProducerHashCount.fetch\_sub(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03470\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ implicitProducerHashResizeInProgress.clear(std::memory\_order\_relaxed);}
\DoxyCodeLine{03471\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03472\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03473\ }
\DoxyCodeLine{03474\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ newHash\ =\ \textcolor{keyword}{new}\ (raw)\ ImplicitProducerHash;}
\DoxyCodeLine{03475\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newHash-\/>capacity\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(newCapacity);}
\DoxyCodeLine{03476\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newHash-\/>entries\ =\ \textcolor{keyword}{reinterpret\_cast<}ImplicitProducerKVP*\textcolor{keyword}{>}(details::align\_for<ImplicitProducerKVP>(raw\ +\ \textcolor{keyword}{sizeof}(ImplicitProducerHash)));}
\DoxyCodeLine{03477\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ newCapacity;\ ++i)\ \{}
\DoxyCodeLine{03478\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ (newHash-\/>entries\ +\ i)\ ImplicitProducerKVP;}
\DoxyCodeLine{03479\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newHash-\/>entries[i].key.store(details::invalid\_thread\_id,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03480\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03481\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newHash-\/>prev\ =\ mainHash;}
\DoxyCodeLine{03482\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ implicitProducerHash.store(newHash,\ std::memory\_order\_release);}
\DoxyCodeLine{03483\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ implicitProducerHashResizeInProgress.clear(std::memory\_order\_release);}
\DoxyCodeLine{03484\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ mainHash\ =\ newHash;}
\DoxyCodeLine{03485\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03486\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03487\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ implicitProducerHashResizeInProgress.clear(std::memory\_order\_release);}
\DoxyCodeLine{03488\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03489\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03490\ }
\DoxyCodeLine{03491\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ it's\ <\ three-\/quarters\ full,\ add\ to\ the\ old\ one\ anyway\ so\ that\ we\ don't\ have\ to\ wait\ for\ the\ next\ table}}
\DoxyCodeLine{03492\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ to\ finish\ being\ allocated\ by\ another\ thread\ (and\ if\ we\ just\ finished\ allocating\ above,\ the\ condition\ will}}
\DoxyCodeLine{03493\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ always\ be\ true)}}
\DoxyCodeLine{03494\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (newCount\ <\ (mainHash-\/>capacity\ >>\ 1)\ +\ (mainHash-\/>capacity\ >>\ 2))\ \{}
\DoxyCodeLine{03495\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ producer\ =\ \textcolor{keyword}{static\_cast<}ImplicitProducer*\textcolor{keyword}{>}(recycle\_or\_create\_producer(\textcolor{keyword}{false}));}
\DoxyCodeLine{03496\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (producer\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03497\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ implicitProducerHashCount.fetch\_sub(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{03498\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03499\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03500\ }
\DoxyCodeLine{03501\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED}}
\DoxyCodeLine{03502\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ producer-\/>threadExitListener.callback\ =\ \&ConcurrentQueue::implicit\_producer\_thread\_exited\_callback;}
\DoxyCodeLine{03503\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ producer-\/>threadExitListener.userData\ =\ producer;}
\DoxyCodeLine{03504\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ details::ThreadExitNotifier::subscribe(\&producer-\/>threadExitListener);}
\DoxyCodeLine{03505\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03506\ }
\DoxyCodeLine{03507\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ index\ =\ hashedId;}
\DoxyCodeLine{03508\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{03509\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\ \&=\ mainHash-\/>capacity\ -\/\ 1u;}
\DoxyCodeLine{03510\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ empty\ =\ details::invalid\_thread\_id;}
\DoxyCodeLine{03511\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED}}
\DoxyCodeLine{03512\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ reusable\ =\ details::invalid\_thread\_id2;}
\DoxyCodeLine{03513\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (mainHash-\/>entries[index].key.compare\_exchange\_strong(reusable,\ \textcolor{keywordtype}{id},\ std::memory\_order\_seq\_cst,\ std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{03514\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ implicitProducerHashCount.fetch\_sub(1,\ std::memory\_order\_relaxed);\ \ \textcolor{comment}{//\ already\ counted\ as\ a\ used\ slot}}
\DoxyCodeLine{03515\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ mainHash-\/>entries[index].value\ =\ producer;}
\DoxyCodeLine{03516\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{03517\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03518\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03519\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (mainHash-\/>entries[index].key.compare\_exchange\_strong(empty,\ \ \ \ \textcolor{keywordtype}{id},\ std::memory\_order\_seq\_cst,\ std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{03520\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ mainHash-\/>entries[index].value\ =\ producer;}
\DoxyCodeLine{03521\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{03522\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03523\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++index;}
\DoxyCodeLine{03524\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03525\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ producer;}
\DoxyCodeLine{03526\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03527\ }
\DoxyCodeLine{03528\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Hmm,\ the\ old\ hash\ is\ quite\ full\ and\ somebody\ else\ is\ busy\ allocating\ a\ new\ one.}}
\DoxyCodeLine{03529\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ need\ to\ wait\ for\ the\ allocating\ thread\ to\ finish\ (if\ it\ succeeds,\ we\ add,\ if\ not,}}
\DoxyCodeLine{03530\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ we\ try\ to\ allocate\ ourselves).}}
\DoxyCodeLine{03531\ \ \ \ \ \ \ \ \ \ \ \ \ mainHash\ =\ implicitProducerHash.load(std::memory\_order\_acquire);}
\DoxyCodeLine{03532\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03533\ \ \ \ \ \}}
\DoxyCodeLine{03534\ }
\DoxyCodeLine{03535\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_CPP11\_THREAD\_LOCAL\_SUPPORTED}}
\DoxyCodeLine{03536\ \ \ \ \ \textcolor{keywordtype}{void}\ implicit\_producer\_thread\_exited(ImplicitProducer*\ producer)}
\DoxyCodeLine{03537\ \ \ \ \ \{}
\DoxyCodeLine{03538\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Remove\ from\ hash}}
\DoxyCodeLine{03539\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODHASH}}
\DoxyCodeLine{03540\ \ \ \ \ \ \ \ \ debug::DebugLock\ lock(implicitProdMutex);}
\DoxyCodeLine{03541\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03542\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ hash\ =\ implicitProducerHash.load(std::memory\_order\_acquire);}
\DoxyCodeLine{03543\ \ \ \ \ \ \ \ \ assert(hash\ !=\ \textcolor{keyword}{nullptr});\ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ thread\ exit\ listener\ is\ only\ registered\ if\ we\ were\ added\ to\ a\ hash\ in\ the\ first\ place}}
\DoxyCodeLine{03544\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ \textcolor{keywordtype}{id}\ =\ details::thread\_id();}
\DoxyCodeLine{03545\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ hashedId\ =\ details::hash\_thread\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{03546\ \ \ \ \ \ \ \ \ details::thread\_id\_t\ probedKey;}
\DoxyCodeLine{03547\ }
\DoxyCodeLine{03548\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ need\ to\ traverse\ all\ the\ hashes\ just\ in\ case\ other\ threads\ aren't\ on\ the\ current\ one\ yet\ and\ are}}
\DoxyCodeLine{03549\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ trying\ to\ add\ an\ entry\ thinking\ there's\ a\ free\ slot\ (because\ they\ reused\ a\ producer)}}
\DoxyCodeLine{03550\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ hash\ !=\ \textcolor{keyword}{nullptr};\ hash\ =\ hash-\/>prev)\ \{}
\DoxyCodeLine{03551\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ index\ =\ hashedId;}
\DoxyCodeLine{03552\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{03553\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\ \&=\ hash-\/>capacity\ -\/\ 1u;}
\DoxyCodeLine{03554\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ probedKey\ =\ id;}
\DoxyCodeLine{03555\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (hash-\/>entries[index].key.compare\_exchange\_strong(probedKey,\ details::invalid\_thread\_id2,\ std::memory\_order\_seq\_cst,\ std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{03556\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{03557\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03558\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++index;}
\DoxyCodeLine{03559\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (probedKey\ !=\ details::invalid\_thread\_id);\ \ \ \ \ \ \textcolor{comment}{//\ Can\ happen\ if\ the\ hash\ has\ changed\ but\ we\ weren't\ put\ back\ in\ it\ yet,\ or\ if\ we\ weren't\ added\ to\ this\ hash\ in\ the\ first\ place}}
\DoxyCodeLine{03560\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03561\ }
\DoxyCodeLine{03562\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Mark\ the\ queue\ as\ being\ recyclable}}
\DoxyCodeLine{03563\ \ \ \ \ \ \ \ \ producer-\/>inactive.store(\textcolor{keyword}{true},\ std::memory\_order\_release);}
\DoxyCodeLine{03564\ \ \ \ \ \}}
\DoxyCodeLine{03565\ }
\DoxyCodeLine{03566\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ implicit\_producer\_thread\_exited\_callback(\textcolor{keywordtype}{void}*\ userData)}
\DoxyCodeLine{03567\ \ \ \ \ \{}
\DoxyCodeLine{03568\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ producer\ =\ \textcolor{keyword}{static\_cast<}ImplicitProducer*\textcolor{keyword}{>}(userData);}
\DoxyCodeLine{03569\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ queue\ =\ producer-\/>parent;}
\DoxyCodeLine{03570\ \ \ \ \ \ \ \ \ queue-\/>implicit\_producer\_thread\_exited(producer);}
\DoxyCodeLine{03571\ \ \ \ \ \}}
\DoxyCodeLine{03572\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03573\ }
\DoxyCodeLine{03575\ \ \ \ \ \textcolor{comment}{//\ Utility\ functions}}
\DoxyCodeLine{03577\ }
\DoxyCodeLine{03578\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ TAlign>}
\DoxyCodeLine{03579\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ aligned\_malloc(\textcolor{keywordtype}{size\_t}\ size)}
\DoxyCodeLine{03580\ \ \ \ \ \{}
\DoxyCodeLine{03581\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (std::alignment\_of<TAlign>::value\ <=\ std::alignment\_of<details::max\_align\_t>::value)}
\DoxyCodeLine{03582\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ (Traits::malloc)(size);}
\DoxyCodeLine{03583\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03584\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ alignment\ =\ std::alignment\_of<TAlign>::value;}
\DoxyCodeLine{03585\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}*\ raw\ =\ (Traits::malloc)(size\ +\ alignment\ -\/\ 1\ +\ \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*));}
\DoxyCodeLine{03586\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!raw)}
\DoxyCodeLine{03587\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03588\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{char}*\ ptr\ =\ details::align\_for<TAlign>(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(raw)\ +\ \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*));}
\DoxyCodeLine{03589\ \ \ \ \ \ \ \ \ \ \ \ \ *(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(ptr)\ -\/\ 1)\ =\ raw;}
\DoxyCodeLine{03590\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ptr;}
\DoxyCodeLine{03591\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03592\ \ \ \ \ \}}
\DoxyCodeLine{03593\ }
\DoxyCodeLine{03594\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ TAlign>}
\DoxyCodeLine{03595\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ aligned\_free(\textcolor{keywordtype}{void}*\ ptr)}
\DoxyCodeLine{03596\ \ \ \ \ \{}
\DoxyCodeLine{03597\ \ \ \ \ \ \ \ \ MOODYCAMEL\_CONSTEXPR\_IF\ (std::alignment\_of<TAlign>::value\ <=\ std::alignment\_of<details::max\_align\_t>::value)}
\DoxyCodeLine{03598\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ (Traits::free)(ptr);}
\DoxyCodeLine{03599\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{03600\ \ \ \ \ \ \ \ \ \ \ \ \ (Traits::free)(ptr\ ?\ *(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(ptr)\ -\/\ 1)\ :\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{03601\ \ \ \ \ \}}
\DoxyCodeLine{03602\ }
\DoxyCodeLine{03603\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{03604\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ U*\ create\_array(\textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{03605\ \ \ \ \ \{}
\DoxyCodeLine{03606\ \ \ \ \ \ \ \ \ assert(count\ >\ 0);}
\DoxyCodeLine{03607\ \ \ \ \ \ \ \ \ U*\ p\ =\ \textcolor{keyword}{static\_cast<}U*\textcolor{keyword}{>}(aligned\_malloc<U>(\textcolor{keyword}{sizeof}(U)\ *\ count));}
\DoxyCodeLine{03608\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (p\ ==\ \textcolor{keyword}{nullptr})}
\DoxyCodeLine{03609\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03610\ }
\DoxyCodeLine{03611\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ count;\ ++i)}
\DoxyCodeLine{03612\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ (p\ +\ i)\ U();}
\DoxyCodeLine{03613\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ p;}
\DoxyCodeLine{03614\ \ \ \ \ \}}
\DoxyCodeLine{03615\ }
\DoxyCodeLine{03616\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{03617\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ destroy\_array(U*\ p,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{03618\ \ \ \ \ \{}
\DoxyCodeLine{03619\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (p\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03620\ \ \ \ \ \ \ \ \ \ \ \ \ assert(count\ >\ 0);}
\DoxyCodeLine{03621\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ count;\ i\ !=\ 0;\ )}
\DoxyCodeLine{03622\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p\ +\ -\/-\/i)-\/>\string~U();}
\DoxyCodeLine{03623\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03624\ \ \ \ \ \ \ \ \ aligned\_free<U>(p);}
\DoxyCodeLine{03625\ \ \ \ \ \}}
\DoxyCodeLine{03626\ }
\DoxyCodeLine{03627\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{03628\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ U*\ create()}
\DoxyCodeLine{03629\ \ \ \ \ \{}
\DoxyCodeLine{03630\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}*\ p\ =\ aligned\_malloc<U>(\textcolor{keyword}{sizeof}(U));}
\DoxyCodeLine{03631\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ p\ !=\ \textcolor{keyword}{nullptr}\ ?\ \textcolor{keyword}{new}\ (p)\ U\ :\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03632\ \ \ \ \ \}}
\DoxyCodeLine{03633\ }
\DoxyCodeLine{03634\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U,\ \textcolor{keyword}{typename}\ A1>}
\DoxyCodeLine{03635\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ U*\ create(A1\&\&\ a1)}
\DoxyCodeLine{03636\ \ \ \ \ \{}
\DoxyCodeLine{03637\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}*\ p\ =\ aligned\_malloc<U>(\textcolor{keyword}{sizeof}(U));}
\DoxyCodeLine{03638\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ p\ !=\ \textcolor{keyword}{nullptr}\ ?\ \textcolor{keyword}{new}\ (p)\ U(std::forward<A1>(a1))\ :\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03639\ \ \ \ \ \}}
\DoxyCodeLine{03640\ }
\DoxyCodeLine{03641\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{03642\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ destroy(U*\ p)}
\DoxyCodeLine{03643\ \ \ \ \ \{}
\DoxyCodeLine{03644\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (p\ !=\ \textcolor{keyword}{nullptr})}
\DoxyCodeLine{03645\ \ \ \ \ \ \ \ \ \ \ \ \ p-\/>\string~U();}
\DoxyCodeLine{03646\ \ \ \ \ \ \ \ \ aligned\_free<U>(p);}
\DoxyCodeLine{03647\ \ \ \ \ \}}
\DoxyCodeLine{03648\ }
\DoxyCodeLine{03649\ \textcolor{keyword}{private}:}
\DoxyCodeLine{03650\ \ \ \ \ std::atomic<ProducerBase*>\ producerListTail;}
\DoxyCodeLine{03651\ \ \ \ \ std::atomic<std::uint32\_t>\ producerCount;}
\DoxyCodeLine{03652\ }
\DoxyCodeLine{03653\ \ \ \ \ std::atomic<size\_t>\ initialBlockPoolIndex;}
\DoxyCodeLine{03654\ \ \ \ \ Block*\ initialBlockPool;}
\DoxyCodeLine{03655\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ initialBlockPoolSize;}
\DoxyCodeLine{03656\ }
\DoxyCodeLine{03657\ \textcolor{preprocessor}{\#ifndef\ MCDBGQ\_USEDEBUGFREELIST}}
\DoxyCodeLine{03658\ \ \ \ \ FreeList<Block>\ freeList;}
\DoxyCodeLine{03659\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{03660\ \ \ \ \ debug::DebugFreeList<Block>\ freeList;}
\DoxyCodeLine{03661\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03662\ }
\DoxyCodeLine{03663\ \ \ \ \ std::atomic<ImplicitProducerHash*>\ implicitProducerHash;}
\DoxyCodeLine{03664\ \ \ \ \ std::atomic<size\_t>\ implicitProducerHashCount;\ \ \ \ \ \ \textcolor{comment}{//\ Number\ of\ slots\ logically\ used}}
\DoxyCodeLine{03665\ \ \ \ \ ImplicitProducerHash\ initialImplicitProducerHash;}
\DoxyCodeLine{03666\ \ \ \ \ std::array<ImplicitProducerKVP,\ INITIAL\_IMPLICIT\_PRODUCER\_HASH\_SIZE>\ initialImplicitProducerHashEntries;}
\DoxyCodeLine{03667\ \ \ \ \ std::atomic\_flag\ implicitProducerHashResizeInProgress;}
\DoxyCodeLine{03668\ }
\DoxyCodeLine{03669\ \ \ \ \ std::atomic<std::uint32\_t>\ nextExplicitConsumerId;}
\DoxyCodeLine{03670\ \ \ \ \ std::atomic<std::uint32\_t>\ globalExplicitConsumerOffset;}
\DoxyCodeLine{03671\ }
\DoxyCodeLine{03672\ \textcolor{preprocessor}{\#ifdef\ MCDBGQ\_NOLOCKFREE\_IMPLICITPRODHASH}}
\DoxyCodeLine{03673\ \ \ \ \ debug::DebugMutex\ implicitProdMutex;}
\DoxyCodeLine{03674\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03675\ }
\DoxyCodeLine{03676\ \textcolor{preprocessor}{\#ifdef\ MOODYCAMEL\_QUEUE\_INTERNAL\_DEBUG}}
\DoxyCodeLine{03677\ \ \ \ \ std::atomic<ExplicitProducer*>\ explicitProducers;}
\DoxyCodeLine{03678\ \ \ \ \ std::atomic<ImplicitProducer*>\ implicitProducers;}
\DoxyCodeLine{03679\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03680\ \};}
\DoxyCodeLine{03681\ }
\DoxyCodeLine{03682\ }
\DoxyCodeLine{03683\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{03684\ ProducerToken::ProducerToken(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue<T,\ Traits>}}\&\ queue)}
\DoxyCodeLine{03685\ \ \ \ \ :\ producer(queue.recycle\_or\_create\_producer(\textcolor{keyword}{true}))}
\DoxyCodeLine{03686\ \{}
\DoxyCodeLine{03687\ \ \ \ \ \textcolor{keywordflow}{if}\ (producer\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03688\ \ \ \ \ \ \ \ \ producer-\/>token\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{03689\ \ \ \ \ \}}
\DoxyCodeLine{03690\ \}}
\DoxyCodeLine{03691\ }
\DoxyCodeLine{03692\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{03693\ ProducerToken::ProducerToken(\mbox{\hyperlink{classmoodycamel_1_1BlockingConcurrentQueue}{BlockingConcurrentQueue<T,\ Traits>}}\&\ queue)}
\DoxyCodeLine{03694\ \ \ \ \ :\ producer(\textcolor{keyword}{reinterpret\_cast<}\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue<T,\ Traits>}}*\textcolor{keyword}{>}(\&queue)-\/>recycle\_or\_create\_producer(\textcolor{keyword}{true}))}
\DoxyCodeLine{03695\ \{}
\DoxyCodeLine{03696\ \ \ \ \ \textcolor{keywordflow}{if}\ (producer\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{03697\ \ \ \ \ \ \ \ \ producer-\/>token\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{03698\ \ \ \ \ \}}
\DoxyCodeLine{03699\ \}}
\DoxyCodeLine{03700\ }
\DoxyCodeLine{03701\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{03702\ ConsumerToken::ConsumerToken(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue<T,\ Traits>}}\&\ queue)}
\DoxyCodeLine{03703\ \ \ \ \ :\ itemsConsumedFromCurrent(0),\ currentProducer(\textcolor{keyword}{nullptr}),\ desiredProducer(\textcolor{keyword}{nullptr})}
\DoxyCodeLine{03704\ \{}
\DoxyCodeLine{03705\ \ \ \ \ initialOffset\ =\ queue.nextExplicitConsumerId.fetch\_add(1,\ std::memory\_order\_release);}
\DoxyCodeLine{03706\ \ \ \ \ lastKnownGlobalOffset\ =\ \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{03707\ \}}
\DoxyCodeLine{03708\ }
\DoxyCodeLine{03709\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{03710\ ConsumerToken::ConsumerToken(\mbox{\hyperlink{classmoodycamel_1_1BlockingConcurrentQueue}{BlockingConcurrentQueue<T,\ Traits>}}\&\ queue)}
\DoxyCodeLine{03711\ \ \ \ \ :\ itemsConsumedFromCurrent(0),\ currentProducer(\textcolor{keyword}{nullptr}),\ desiredProducer(\textcolor{keyword}{nullptr})}
\DoxyCodeLine{03712\ \{}
\DoxyCodeLine{03713\ \ \ \ \ initialOffset\ =\ \textcolor{keyword}{reinterpret\_cast<}\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue<T,\ Traits>}}*\textcolor{keyword}{>}(\&queue)-\/>nextExplicitConsumerId.fetch\_add(1,\ std::memory\_order\_release);}
\DoxyCodeLine{03714\ \ \ \ \ lastKnownGlobalOffset\ =\ \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{03715\ \}}
\DoxyCodeLine{03716\ }
\DoxyCodeLine{03717\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{03718\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ swap(\mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue<T,\ Traits>}}\&\ a,\ \mbox{\hyperlink{classmoodycamel_1_1ConcurrentQueue}{ConcurrentQueue<T,\ Traits>}}\&\ b)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{03719\ \{}
\DoxyCodeLine{03720\ \ \ \ \ a.swap(b);}
\DoxyCodeLine{03721\ \}}
\DoxyCodeLine{03722\ }
\DoxyCodeLine{03723\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ swap(\mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}\&\ a,\ \mbox{\hyperlink{structmoodycamel_1_1ProducerToken}{ProducerToken}}\&\ b)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{03724\ \{}
\DoxyCodeLine{03725\ \ \ \ \ a.swap(b);}
\DoxyCodeLine{03726\ \}}
\DoxyCodeLine{03727\ }
\DoxyCodeLine{03728\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ swap(\mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}\&\ a,\ \mbox{\hyperlink{structmoodycamel_1_1ConsumerToken}{ConsumerToken}}\&\ b)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{03729\ \{}
\DoxyCodeLine{03730\ \ \ \ \ a.swap(b);}
\DoxyCodeLine{03731\ \}}
\DoxyCodeLine{03732\ }
\DoxyCodeLine{03733\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Traits>}
\DoxyCodeLine{03734\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ swap(\textcolor{keyword}{typename}\ ConcurrentQueue<T,\ Traits>::ImplicitProducerKVP\&\ a,\ \textcolor{keyword}{typename}\ ConcurrentQueue<T,\ Traits>::ImplicitProducerKVP\&\ b)\ MOODYCAMEL\_NOEXCEPT}
\DoxyCodeLine{03735\ \{}
\DoxyCodeLine{03736\ \ \ \ \ a.swap(b);}
\DoxyCodeLine{03737\ \}}
\DoxyCodeLine{03738\ }
\DoxyCodeLine{03739\ \}}
\DoxyCodeLine{03740\ }
\DoxyCodeLine{03741\ \textcolor{preprocessor}{\#if\ defined(\_MSC\_VER)\ \&\&\ (!defined(\_HAS\_CXX17)\ ||\ !\_HAS\_CXX17)}}
\DoxyCodeLine{03742\ \textcolor{preprocessor}{\#pragma\ warning(pop)}}
\DoxyCodeLine{03743\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03744\ }
\DoxyCodeLine{03745\ \textcolor{preprocessor}{\#if\ defined(\_\_GNUC\_\_)\ \&\&\ !defined(\_\_INTEL\_COMPILER)}}
\DoxyCodeLine{03746\ \textcolor{preprocessor}{\#pragma\ GCC\ diagnostic\ pop}}
\DoxyCodeLine{03747\ \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
