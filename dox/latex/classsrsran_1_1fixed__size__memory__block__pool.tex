\doxysection{srsran\+::fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool\texorpdfstring{$<$}{<} Id\+Tag, Debug\+Sanitize\+Address \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classsrsran_1_1fixed__size__memory__block__pool}{}\label{classsrsran_1_1fixed__size__memory__block__pool}\index{srsran::fixed\_size\_memory\_block\_pool$<$ IdTag, DebugSanitizeAddress $>$@{srsran::fixed\_size\_memory\_block\_pool$<$ IdTag, DebugSanitizeAddress $>$}}


{\ttfamily \#include $<$fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_af5652333ed2390b8e064a8a47e9c52b2}\label{classsrsran_1_1fixed__size__memory__block__pool_af5652333ed2390b8e064a8a47e9c52b2} 
{\bfseries fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool} (const \mbox{\hyperlink{classsrsran_1_1fixed__size__memory__block__pool}{fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool}} \&)=delete
\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_a0cbe77bbeee13dd8208b089787ae9188}\label{classsrsran_1_1fixed__size__memory__block__pool_a0cbe77bbeee13dd8208b089787ae9188} 
{\bfseries fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool} (\mbox{\hyperlink{classsrsran_1_1fixed__size__memory__block__pool}{fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool}} \&\&)=delete
\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_ae7b1f2487bcf190b3d469ab11d28dca6}\label{classsrsran_1_1fixed__size__memory__block__pool_ae7b1f2487bcf190b3d469ab11d28dca6} 
\mbox{\hyperlink{classsrsran_1_1fixed__size__memory__block__pool}{fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool}} \& {\bfseries operator=} (const \mbox{\hyperlink{classsrsran_1_1fixed__size__memory__block__pool}{fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool}} \&)=delete
\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_aa5108497caaa2047dea3d09d242c802a}\label{classsrsran_1_1fixed__size__memory__block__pool_aa5108497caaa2047dea3d09d242c802a} 
\mbox{\hyperlink{classsrsran_1_1fixed__size__memory__block__pool}{fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool}} \& {\bfseries operator=} (\mbox{\hyperlink{classsrsran_1_1fixed__size__memory__block__pool}{fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool}} \&\&)=delete
\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_adade3bf7e9aff4541725d76e420d6aa1}\label{classsrsran_1_1fixed__size__memory__block__pool_adade3bf7e9aff4541725d76e420d6aa1} 
size\+\_\+t {\bfseries memory\+\_\+block\+\_\+size} () const
\begin{DoxyCompactList}\small\item\em Memory block size in bytes. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_aa740c16913d89c23f766a051d9dbe69a}\label{classsrsran_1_1fixed__size__memory__block__pool_aa740c16913d89c23f766a051d9dbe69a} 
size\+\_\+t {\bfseries nof\+\_\+memory\+\_\+blocks} () const
\begin{DoxyCompactList}\small\item\em Number of memory blocks contained in this memory pool. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_ac42ad85fb1309826074e303e2512889e}\label{classsrsran_1_1fixed__size__memory__block__pool_ac42ad85fb1309826074e303e2512889e} 
size\+\_\+t {\bfseries max\+\_\+local\+\_\+cache\+\_\+size} () const
\begin{DoxyCompactList}\small\item\em Maximum number of blocks that can be stored in the thread-\/local memory block cache. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_a36dcaf676f890701fdb05d5019f888c3}\label{classsrsran_1_1fixed__size__memory__block__pool_a36dcaf676f890701fdb05d5019f888c3} 
void \texorpdfstring{$\ast$}{*} {\bfseries allocate\+\_\+node} () noexcept
\begin{DoxyCompactList}\small\item\em Allocate a node from the memory pool with the maximum size. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_aee26f022975269f264f883a2047c695c}\label{classsrsran_1_1fixed__size__memory__block__pool_aee26f022975269f264f883a2047c695c} 
void \texorpdfstring{$\ast$}{*} {\bfseries allocate\+\_\+node} (size\+\_\+t sz) noexcept
\begin{DoxyCompactList}\small\item\em Allocate a node from the memory pool with the provided size. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_ae503bb341886bef39bac36225531d1ff}\label{classsrsran_1_1fixed__size__memory__block__pool_ae503bb341886bef39bac36225531d1ff} 
void {\bfseries deallocate\+\_\+node} (void \texorpdfstring{$\ast$}{*}p)
\begin{DoxyCompactList}\small\item\em Deallocate node by returning it back to the memory pool. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_ae5ecdfcda02a2d4fb2abe361de1673f6}\label{classsrsran_1_1fixed__size__memory__block__pool_ae5ecdfcda02a2d4fb2abe361de1673f6} 
void {\bfseries print\+\_\+all\+\_\+buffers} ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1fixed__size__memory__block__pool_a0ca5df2697c29c7b931cdfd9834e77a5}\label{classsrsran_1_1fixed__size__memory__block__pool_a0ca5df2697c29c7b931cdfd9834e77a5} 
static \mbox{\hyperlink{classsrsran_1_1fixed__size__memory__block__pool}{fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool}}$<$ Id\+Tag, Debug\+Sanitize\+Address $>$ \& {\bfseries get\+\_\+instance} (size\+\_\+t nof\+\_\+blocks=0, size\+\_\+t mem\+\_\+block\+\_\+size=0)
\begin{DoxyCompactList}\small\item\em Get instance of a memory pool singleton. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Id\+Tag, bool Debug\+Sanitize\+Address = false$>$\newline
class srsran\+::fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool$<$ Id\+Tag, Debug\+Sanitize\+Address $>$}
Concurrent memory pool of memory blocks of equal size. This pool is thread-\/safe. Each worker keeps a separate thread-\/local memory block cache that it uses for fast, non-\/contended allocation and deallocation. When accessing a thread-\/local cache, no locks are required.

When the local cache gets depleted, the worker tries to obtain a batch of segments from a central memory block cache. If the central cache is also depleted, the allocation fails.

Since there is no stealing of segments between workers\textquotesingle{} local caches, it is possible that a worker cannot allocate while another worker still has blocks in its own cache. To minimize the impact of this event, an upper bound is placed on a worker local cache size. Once a worker reaches that upper bound, it sends half of its stored blocks to the central cache.

Note1\+: Notice that the same memory block might be allocated and deallocated in different workers. So, it can happen that a worker is allocating many blocks and another worker just deallocating. The latter worker has to keep returning blocks back to the central cache every time its local cache grows beyond a given upper bound.

Note2\+: Taking into account the usage of thread\+\_\+local, this class is made a singleton. To be able to instantiate different pools, the user should use different Id\+Tag types.

Note3\+: No considerations were made regarding false sharing between workers. It is assumed that the blocks are big enough to fill a cache line.


\begin{DoxyTemplParams}{Template Parameters}
{\em Id\+Tag} & We use a ID type tag to be able to intantiate different pool objects. \\
\hline
{\em Debug\+Sanitize\+Address} & when set to true, the pool verifies that the addresses allocated and deallocated are valid. \\
\hline
\end{DoxyTemplParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/srsran/support/memory\+\_\+pool/fixed\+\_\+size\+\_\+memory\+\_\+block\+\_\+pool.\+h\end{DoxyCompactItemize}
