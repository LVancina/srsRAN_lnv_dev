\doxysection{unique\+\_\+timer\+\_\+cancel\+\_\+already\+\_\+launched\+\_\+expiry\+\_\+callback\+\_\+tester Class Reference}
\hypertarget{classunique__timer__cancel__already__launched__expiry__callback__tester}{}\label{classunique__timer__cancel__already__launched__expiry__callback__tester}\index{unique\_timer\_cancel\_already\_launched\_expiry\_callback\_tester@{unique\_timer\_cancel\_already\_launched\_expiry\_callback\_tester}}


This tester verifies that if the status of the timer is updated after the timer has expired in the backend, but before the expiry callback gets processed in the frontend (e.\+g. due to queue latency), the expiry callback is ignored.  


Inheritance diagram for unique\+\_\+timer\+\_\+cancel\+\_\+already\+\_\+launched\+\_\+expiry\+\_\+callback\+\_\+tester\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classunique__timer__cancel__already__launched__expiry__callback__tester}
\end{center}
\end{figure}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classunique__timer__cancel__already__launched__expiry__callback__tester_ab226c87a1c355b75bd3b148167a8974a}\label{classunique__timer__cancel__already__launched__expiry__callback__tester_ab226c87a1c355b75bd3b148167a8974a} 
void {\bfseries process\+\_\+pending\+\_\+expiry\+\_\+callbacks} ()
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{classunique__timer__manual__tester}{unique\+\_\+timer\+\_\+manual\+\_\+tester}}}
\begin{DoxyCompactItemize}
\item 
{\bfseries unique\+\_\+timer\+\_\+manual\+\_\+tester} (bool blocking\+\_\+worker=true)
\item 
\mbox{\hyperlink{classsrsran_1_1unique__timer}{unique\+\_\+timer}} {\bfseries create\+\_\+timer} ()
\item 
void {\bfseries tick} ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classunique__timer__cancel__already__launched__expiry__callback__tester_a5e99e2bf5b6268ae30ecf2e30ab453e0}\label{classunique__timer__cancel__already__launched__expiry__callback__tester_a5e99e2bf5b6268ae30ecf2e30ab453e0} 
\mbox{\hyperlink{classsrsran_1_1unique__timer}{unique\+\_\+timer}} {\bfseries t}
\item 
\Hypertarget{classunique__timer__cancel__already__launched__expiry__callback__tester_a1e8e83d5e098bcab1a8bae0d3ac34082}\label{classunique__timer__cancel__already__launched__expiry__callback__tester_a1e8e83d5e098bcab1a8bae0d3ac34082} 
\mbox{\hyperlink{namespacesrsran_ae78e137cc0f1b8e1ad1384453e5e38a3}{timer\+\_\+duration}} {\bfseries dur}
\item 
\Hypertarget{classunique__timer__cancel__already__launched__expiry__callback__tester_aac3c78693ea880765944d78fcf627786}\label{classunique__timer__cancel__already__launched__expiry__callback__tester_aac3c78693ea880765944d78fcf627786} 
bool {\bfseries expiry\+\_\+callback\+\_\+triggered} = false
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \mbox{\hyperlink{classunique__timer__manual__tester}{unique\+\_\+timer\+\_\+manual\+\_\+tester}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classsrslog_1_1detail_1_1logger__impl}{srslog\+::basic\+\_\+logger}} \& {\bfseries logger} = srslog\+::fetch\+\_\+basic\+\_\+logger("{}ALL"{})
\item 
\mbox{\hyperlink{classsrsran_1_1timer__manager}{timer\+\_\+manager}} {\bfseries timer\+\_\+mng}
\item 
\mbox{\hyperlink{classsrsran_1_1manual__task__worker}{manual\+\_\+task\+\_\+worker}} {\bfseries worker}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This tester verifies that if the status of the timer is updated after the timer has expired in the backend, but before the expiry callback gets processed in the frontend (e.\+g. due to queue latency), the expiry callback is ignored. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
tests/unittests/support/timer\+\_\+test.\+cpp\end{DoxyCompactItemize}
