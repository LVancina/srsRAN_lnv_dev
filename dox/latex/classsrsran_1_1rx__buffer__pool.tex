\doxysection{srsran\+::rx\+\_\+buffer\+\_\+pool Class Reference}
\hypertarget{classsrsran_1_1rx__buffer__pool}{}\label{classsrsran_1_1rx__buffer__pool}\index{srsran::rx\_buffer\_pool@{srsran::rx\_buffer\_pool}}


Describes a receive buffer pool.  




{\ttfamily \#include $<$rx\+\_\+buffer\+\_\+pool.\+h$>$}

Inheritance diagram for srsran\+::rx\+\_\+buffer\+\_\+pool\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classsrsran_1_1rx__buffer__pool}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1rx__buffer__pool_a564a44ffbf72b9324a9237538e1722b6}\label{classsrsran_1_1rx__buffer__pool_a564a44ffbf72b9324a9237538e1722b6} 
virtual {\bfseries \texorpdfstring{$\sim$}{\string~}rx\+\_\+buffer\+\_\+pool} ()=default
\begin{DoxyCompactList}\small\item\em Default destructor. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{classsrsran_1_1unique__rx__buffer}{unique\+\_\+rx\+\_\+buffer}} \mbox{\hyperlink{classsrsran_1_1rx__buffer__pool_a7b084964b445dbb89fdc96458bb4d9cc}{reserve}} (const \mbox{\hyperlink{classsrsran_1_1slot__point}{slot\+\_\+point}} \&\mbox{\hyperlink{namespacesrsran_a457973e91fb03d0c262578c3bdf460f0a5e97994ed38a2b2f984f3b2b75012bf8}{slot}}, \mbox{\hyperlink{classsrsran_1_1trx__buffer__identifier}{trx\+\_\+buffer\+\_\+identifier}} id, unsigned nof\+\_\+codeblocks, bool new\+\_\+data)=0
\begin{DoxyCompactList}\small\item\em Reserves and gets a buffer for a given identifier and number of codeblocks. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classsrsran_1_1rx__buffer__pool_a64f95bbb458bf577d1d98ce847199262}{run\+\_\+slot}} (const \mbox{\hyperlink{classsrsran_1_1slot__point}{slot\+\_\+point}} \&\mbox{\hyperlink{namespacesrsran_a457973e91fb03d0c262578c3bdf460f0a5e97994ed38a2b2f984f3b2b75012bf8}{slot}})=0
\begin{DoxyCompactList}\small\item\em Runs pool housekeeping tasks. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Describes a receive buffer pool. 

The aim of this interface is to provide the physical layer shared channel decoder with receiver buffers.

The receiver buffers are selected from a pool of resources for a given \doxylink{classsrsran_1_1trx__buffer__identifier}{trx\+\_\+buffer\+\_\+identifier} and kept persistent until the buffer is released or expires.

The pool is designed for being unique in a sector. In other words, every sector must create its own pool.

The implementation might not be thread safe\+: \doxylink{classsrsran_1_1rx__buffer__pool_a7b084964b445dbb89fdc96458bb4d9cc}{reserve()}, and \doxylink{classsrsran_1_1rx__buffer__pool_a64f95bbb458bf577d1d98ce847199262}{run\+\_\+slot()} can not be called simultaneously.

\begin{DoxyRemark}{Remarks}
An assertion is triggered if the slot numerology used for \doxylink{classsrsran_1_1rx__buffer__pool_a7b084964b445dbb89fdc96458bb4d9cc}{reserve()} and \doxylink{classsrsran_1_1rx__buffer__pool_a64f95bbb458bf577d1d98ce847199262}{run\+\_\+slot()} are different. 
\end{DoxyRemark}


\doxysubsection{Member Function Documentation}
\Hypertarget{classsrsran_1_1rx__buffer__pool_a7b084964b445dbb89fdc96458bb4d9cc}\label{classsrsran_1_1rx__buffer__pool_a7b084964b445dbb89fdc96458bb4d9cc} 
\index{srsran::rx\_buffer\_pool@{srsran::rx\_buffer\_pool}!reserve@{reserve}}
\index{reserve@{reserve}!srsran::rx\_buffer\_pool@{srsran::rx\_buffer\_pool}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classsrsran_1_1unique__rx__buffer}{unique\+\_\+rx\+\_\+buffer}} srsran\+::rx\+\_\+buffer\+\_\+pool\+::reserve (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classsrsran_1_1slot__point}{slot\+\_\+point}} \&}]{slot,  }\item[{\mbox{\hyperlink{classsrsran_1_1trx__buffer__identifier}{trx\+\_\+buffer\+\_\+identifier}}}]{id,  }\item[{unsigned}]{nof\+\_\+codeblocks,  }\item[{bool}]{new\+\_\+data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Reserves and gets a buffer for a given identifier and number of codeblocks. 

It reserves a buffer for the given identifier. It guarantees that reserved buffers keep the CRC and data values.

The buffers are reserved until\+:
\begin{DoxyItemize}
\item the buffer is freed using \doxylink{classsrsran_1_1unique__rx__buffer_a48da18b4ebaf863beadf6cf8a6ca09b0}{unique\+\_\+rx\+\_\+buffer\+::release()},
\item a buffer reservation is performed with the same identifier but different number of codeblocks, or
\item buffer reservation expires (by means \doxylink{classsrsran_1_1rx__buffer__pool_a64f95bbb458bf577d1d98ce847199262}{run\+\_\+slot()}).
\end{DoxyItemize}

The pool does not initialize or modify the codeblock contents of the buffers. The modules that use the buffers are responsible for initializing and modifying their contents upon new transmissions.

It is expected that the pool logs in {\ttfamily PHY} channel the context and the reason of a failed reservation. Possible reservation failures are\+:
\begin{DoxyItemize}
\item Insufficient number of buffers, \doxylink{structsrsran_1_1rx__buffer__pool__config_ab3b65ab37eb08e0048e80d8411b28185}{rx\+\_\+buffer\+\_\+pool\+\_\+config\+::nof\+\_\+buffers} buffers are reserved with different identifiers;
\item Insufficient number of codeblocks, rx\+\_\+buffer\+\_\+pool\+\_\+config\+::max\+\_\+nof\+\_\+codeblocks codeblocks are currently assigned to buffers;
\item A buffer with the same identifier is locked;
\item No buffer is found with the same identifier while the reservation is not marked as new data;
\item The number of codeblocks for a retransmission is different than the previous reservation; or
\item The pool operation has stopped.
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em slot} & Slot context in which the reservation occurs. \\
\hline
\mbox{\texttt{ in}}  & {\em id} & Buffer identifier. \\
\hline
\mbox{\texttt{ in}}  & {\em nof\+\_\+codeblocks} & Indicates the number of codeblocks to reserve. \\
\hline
\mbox{\texttt{ in}}  & {\em new\+\_\+data} & Set to true if the transmission is for new data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A valid unique buffer if the reservation was successful. Otherwise, an invalid unique buffer. 
\end{DoxyReturn}
\Hypertarget{classsrsran_1_1rx__buffer__pool_a64f95bbb458bf577d1d98ce847199262}\label{classsrsran_1_1rx__buffer__pool_a64f95bbb458bf577d1d98ce847199262} 
\index{srsran::rx\_buffer\_pool@{srsran::rx\_buffer\_pool}!run\_slot@{run\_slot}}
\index{run\_slot@{run\_slot}!srsran::rx\_buffer\_pool@{srsran::rx\_buffer\_pool}}
\doxysubsubsection{\texorpdfstring{run\_slot()}{run\_slot()}}
{\footnotesize\ttfamily virtual void srsran\+::rx\+\_\+buffer\+\_\+pool\+::run\+\_\+slot (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classsrsran_1_1slot__point}{slot\+\_\+point}} \&}]{slot }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Runs pool housekeeping tasks. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em slot} & Indicates the current slot. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/srsran/phy/upper/rx\+\_\+buffer\+\_\+pool.\+h\end{DoxyCompactItemize}
