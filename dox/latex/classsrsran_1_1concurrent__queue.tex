\doxysection{srsran\+::concurrent\+\_\+queue\texorpdfstring{$<$}{<} T, Policy, Blocking\+Policy \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classsrsran_1_1concurrent__queue}{}\label{classsrsran_1_1concurrent__queue}\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}


A concurrent queue that can be used to pass objects between threads. Different policies are supported\+:  




{\ttfamily \#include $<$concurrent\+\_\+queue.\+h$>$}

\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1concurrent__queue_a721c1dfd4a66c8ba57233f44b2df67f6}\label{classsrsran_1_1concurrent__queue_a721c1dfd4a66c8ba57233f44b2df67f6} 
using {\bfseries value\+\_\+type} = T
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1concurrent__queue_a3e7457bd8aadcab730a61df43a4ecd49}\label{classsrsran_1_1concurrent__queue_a3e7457bd8aadcab730a61df43a4ecd49} 
{\footnotesize template$<$typename... Args$>$ }\\{\bfseries concurrent\+\_\+queue} (size\+\_\+t minimum\+\_\+q\+\_\+size, Args \&\&... args)
\item 
{\footnotesize template$<$typename U $>$ }\\bool \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a83c3ee3074579631ed08e3414377a541}{try\+\_\+push}} (U \&\&elem) noexcept
\item 
{\footnotesize template$<$typename U , \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Q = Blocking\+Policy, std\+::enable\+\_\+if\+\_\+t$<$ Q !=concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::non\+\_\+blocking, int $>$  = 0$>$ }\\bool \mbox{\hyperlink{classsrsran_1_1concurrent__queue_acc0043f182b8d55c7cd432047fe15179}{push\+\_\+blocking}} (U \&\&elem) noexcept
\item 
bool \mbox{\hyperlink{classsrsran_1_1concurrent__queue_af92570524955aa703c2946900d7741b2}{try\+\_\+pop}} (T \&elem)
\begin{DoxyCompactList}\small\item\em Pops an element from the queue in a non-\/blocking fashion. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classsrsran_1_1optional}{optional}}$<$ T $>$ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a6d5638ee10deab90bd30105c580748b5}{try\+\_\+pop}} ()
\begin{DoxyCompactList}\small\item\em Pops an element from the queue in a non-\/blocking fashion. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Call\+On\+Pop $>$ }\\bool \mbox{\hyperlink{classsrsran_1_1concurrent__queue_ae9d56f2adcb20bf091a80a29386cce47}{try\+\_\+call\+\_\+on\+\_\+pop}} (const Call\+On\+Pop \&func)
\begin{DoxyCompactList}\small\item\em Pops an element from the queue and calls the provided function with the popped element. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1concurrent__queue_a9fc2964f0e85797249b5531434c70935}\label{classsrsran_1_1concurrent__queue_a9fc2964f0e85797249b5531434c70935} 
bool {\bfseries pop\+\_\+blocking} (T \&elem)
\begin{DoxyCompactList}\small\item\em Pops an element from the queue. If the queue is empty, the call blocks, waiting for a new element to be pushed. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1concurrent__queue_a017b9f37c5a0969958ccc13f7b91912a}\label{classsrsran_1_1concurrent__queue_a017b9f37c5a0969958ccc13f7b91912a} 
\mbox{\hyperlink{classsrsran_1_1optional}{optional}}$<$ T $>$ {\bfseries pop\+\_\+blocking} () noexcept
\begin{DoxyCompactList}\small\item\em Pops an element from the queue. If the queue is empty, the call blocks, waiting for a new element to be pushed. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1concurrent__queue_a2be0a7a406714c6df59e5f1eb9cdd0fd}\label{classsrsran_1_1concurrent__queue_a2be0a7a406714c6df59e5f1eb9cdd0fd} 
{\footnotesize template$<$typename Call\+On\+Pop $>$ }\\bool {\bfseries call\+\_\+on\+\_\+pop\+\_\+blocking} (const Call\+On\+Pop \&func)
\begin{DoxyCompactList}\small\item\em Pops an element from the queue and calls the provided function with the popped element. If the queue is empty, the function blocks, waiting for a new element to be pushed. It returns false if the queue is closed. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1concurrent__queue_a566b5bcfd15d0a7918eb01571046d952}\label{classsrsran_1_1concurrent__queue_a566b5bcfd15d0a7918eb01571046d952} 
size\+\_\+t {\bfseries capacity} () const
\begin{DoxyCompactList}\small\item\em Maximum capacity of the queue. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1concurrent__queue_a0775474918ef7b6fe6720f89156afd65}\label{classsrsran_1_1concurrent__queue_a0775474918ef7b6fe6720f89156afd65} 
size\+\_\+t {\bfseries size} () const
\begin{DoxyCompactList}\small\item\em Current size of the queue. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1concurrent__queue_ac045142931e78330202b2e62ca79fc19}\label{classsrsran_1_1concurrent__queue_ac045142931e78330202b2e62ca79fc19} 
bool {\bfseries empty} () const
\begin{DoxyCompactList}\small\item\em Determines whether the queue is empty. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1concurrent__queue_ae6809193cc3aa228a27b887494b5bae0}\label{classsrsran_1_1concurrent__queue_ae6809193cc3aa228a27b887494b5bae0} 
void {\bfseries request\+\_\+stop} ()
\begin{DoxyCompactList}\small\item\em Request any blocking function to be interrupted. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1concurrent__queue_a94c115e9e0551bd43ce0056905010345}\label{classsrsran_1_1concurrent__queue_a94c115e9e0551bd43ce0056905010345} 
static const \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} {\bfseries queue\+\_\+policy} = Policy
\item 
\Hypertarget{classsrsran_1_1concurrent__queue_ac0111e20dc65b9b5ee571b19daedd56f}\label{classsrsran_1_1concurrent__queue_ac0111e20dc65b9b5ee571b19daedd56f} 
static const \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} {\bfseries wait\+\_\+policy} = Blocking\+Policy
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T, \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$\newline
class srsran\+::concurrent\+\_\+queue$<$ T, Policy, Blocking\+Policy $>$}
A concurrent queue that can be used to pass objects between threads. Different policies are supported\+: 


\begin{DoxyItemize}
\item lockfree\+\_\+spsc\+: a lock-\/free single-\/producer single-\/consumer queue. This is the fastest option.
\item locking\+\_\+mpmc\+: a multi-\/producer multi-\/consumer queue that uses a mutex to protect the queue. This is the most most general queue, but has the highest overhead. The producers and consumers will contend on the access to the mutex.
\item locking\+\_\+mpsc\+: a multi-\/producer single-\/consumer queue that uses a mutex to protect the queue. This queue pops all elements in a batch to minimize the contention on the mutex from the consumer side. 
\end{DoxyItemize}

\doxysubsection{Member Function Documentation}
\Hypertarget{classsrsran_1_1concurrent__queue_acc0043f182b8d55c7cd432047fe15179}\label{classsrsran_1_1concurrent__queue_acc0043f182b8d55c7cd432047fe15179} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!push\_blocking@{push\_blocking}}
\index{push\_blocking@{push\_blocking}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{push\_blocking()}{push\_blocking()}}
{\footnotesize\ttfamily template$<$typename T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
template$<$typename U , \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Q = Blocking\+Policy, std\+::enable\+\_\+if\+\_\+t$<$ Q !=concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::non\+\_\+blocking, int $>$  = 0$>$ \\
bool \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, Policy, Blocking\+Policy $>$\+::push\+\_\+blocking (\begin{DoxyParamCaption}\item[{U \&\&}]{elem }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Pushes a new element into the queue. If the queue is full, the call blocks, waiting for a new slot to become emptied. \begin{DoxyReturn}{Returns}
true if the element was pushed, false if the queue was closed. 
\end{DoxyReturn}
\Hypertarget{classsrsran_1_1concurrent__queue_ae9d56f2adcb20bf091a80a29386cce47}\label{classsrsran_1_1concurrent__queue_ae9d56f2adcb20bf091a80a29386cce47} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!try\_call\_on\_pop@{try\_call\_on\_pop}}
\index{try\_call\_on\_pop@{try\_call\_on\_pop}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{try\_call\_on\_pop()}{try\_call\_on\_pop()}}
{\footnotesize\ttfamily template$<$typename T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
template$<$typename Call\+On\+Pop $>$ \\
bool \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, Policy, Blocking\+Policy $>$\+::try\+\_\+call\+\_\+on\+\_\+pop (\begin{DoxyParamCaption}\item[{const Call\+On\+Pop \&}]{func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pops an element from the queue and calls the provided function with the popped element. 

If the queue is empty, the call returns false, and the Call\+On\+Pop function is not called. Otherwise, it returns true. \Hypertarget{classsrsran_1_1concurrent__queue_a6d5638ee10deab90bd30105c580748b5}\label{classsrsran_1_1concurrent__queue_a6d5638ee10deab90bd30105c580748b5} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!try\_pop@{try\_pop}}
\index{try\_pop@{try\_pop}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{try\_pop()}{try\_pop()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
\mbox{\hyperlink{classsrsran_1_1optional}{optional}}$<$ T $>$ \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, Policy, Blocking\+Policy $>$\+::try\+\_\+pop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pops an element from the queue in a non-\/blocking fashion. 

If the queue is empty, the call returns an empty optional. \Hypertarget{classsrsran_1_1concurrent__queue_af92570524955aa703c2946900d7741b2}\label{classsrsran_1_1concurrent__queue_af92570524955aa703c2946900d7741b2} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!try\_pop@{try\_pop}}
\index{try\_pop@{try\_pop}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{try\_pop()}{try\_pop()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
bool \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, Policy, Blocking\+Policy $>$\+::try\+\_\+pop (\begin{DoxyParamCaption}\item[{T \&}]{elem }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pops an element from the queue in a non-\/blocking fashion. 

If the queue is empty, the call returns false. \Hypertarget{classsrsran_1_1concurrent__queue_a83c3ee3074579631ed08e3414377a541}\label{classsrsran_1_1concurrent__queue_a83c3ee3074579631ed08e3414377a541} 
\index{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}!try\_push@{try\_push}}
\index{try\_push@{try\_push}!srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$@{srsran::concurrent\_queue$<$ T, Policy, BlockingPolicy $>$}}
\doxysubsubsection{\texorpdfstring{try\_push()}{try\_push()}}
{\footnotesize\ttfamily template$<$typename T , \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Policy, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Blocking\+Policy$>$ \\
template$<$typename U $>$ \\
bool \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{srsran\+::concurrent\+\_\+queue}}$<$ T, Policy, Blocking\+Policy $>$\+::try\+\_\+push (\begin{DoxyParamCaption}\item[{U \&\&}]{elem }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Pushes a new element into the queue in a non-\/blocking fashion. If the queue is full, the element is not pushed. \begin{DoxyReturn}{Returns}
true if the element was pushed, false otherwise. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/srsran/adt/concurrent\+\_\+queue.\+h\end{DoxyCompactItemize}
