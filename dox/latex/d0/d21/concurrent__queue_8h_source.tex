\doxysection{concurrent\+\_\+queue.\+h}
\hypertarget{concurrent__queue_8h_source}{}\label{concurrent__queue_8h_source}\index{include/srsran/adt/concurrent\_queue.h@{include/srsran/adt/concurrent\_queue.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{/*}}
\DoxyCodeLine{00002\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00003\ \textcolor{comment}{\ *\ Copyright\ 2021-\/2024\ Software\ Radio\ Systems\ Limited}}
\DoxyCodeLine{00004\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00005\ \textcolor{comment}{\ *\ This\ file\ is\ part\ of\ srsRAN.}}
\DoxyCodeLine{00006\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00007\ \textcolor{comment}{\ *\ srsRAN\ is\ free\ software:\ you\ can\ redistribute\ it\ and/or\ modify}}
\DoxyCodeLine{00008\ \textcolor{comment}{\ *\ it\ under\ the\ terms\ of\ the\ GNU\ Affero\ General\ Public\ License\ as}}
\DoxyCodeLine{00009\ \textcolor{comment}{\ *\ published\ by\ the\ Free\ Software\ Foundation,\ either\ version\ 3\ of}}
\DoxyCodeLine{00010\ \textcolor{comment}{\ *\ the\ License,\ or\ (at\ your\ option)\ any\ later\ version.}}
\DoxyCodeLine{00011\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00012\ \textcolor{comment}{\ *\ srsRAN\ is\ distributed\ in\ the\ hope\ that\ it\ will\ be\ useful,}}
\DoxyCodeLine{00013\ \textcolor{comment}{\ *\ but\ WITHOUT\ ANY\ WARRANTY;\ without\ even\ the\ implied\ warranty\ of}}
\DoxyCodeLine{00014\ \textcolor{comment}{\ *\ MERCHANTABILITY\ or\ FITNESS\ FOR\ A\ PARTICULAR\ PURPOSE.\ \ See\ the}}
\DoxyCodeLine{00015\ \textcolor{comment}{\ *\ GNU\ Affero\ General\ Public\ License\ for\ more\ details.}}
\DoxyCodeLine{00016\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00017\ \textcolor{comment}{\ *\ A\ copy\ of\ the\ GNU\ Affero\ General\ Public\ License\ can\ be\ found\ in}}
\DoxyCodeLine{00018\ \textcolor{comment}{\ *\ the\ LICENSE\ file\ in\ the\ top-\/level\ directory\ of\ this\ distribution}}
\DoxyCodeLine{00019\ \textcolor{comment}{\ *\ and\ at\ http://www.gnu.org/licenses/.}}
\DoxyCodeLine{00020\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00021\ \textcolor{comment}{\ */}}
\DoxyCodeLine{00022\ }
\DoxyCodeLine{00023\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{pragma}\ \textcolor{preprocessor}{once}}
\DoxyCodeLine{00024\ }
\DoxyCodeLine{00025\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}rigtorp/MPMCQueue.h"{}}}
\DoxyCodeLine{00026\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}rigtorp/SPSCQueue.h"{}}}
\DoxyCodeLine{00027\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/adt/blocking\_queue.h"{}}}
\DoxyCodeLine{00028\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/adt/detail/tuple\_utils.h"{}}}
\DoxyCodeLine{00029\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/adt/optional.h"{}}}
\DoxyCodeLine{00030\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/support/compiler.h"{}}}
\DoxyCodeLine{00031\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/support/error\_handling.h"{}}}
\DoxyCodeLine{00032\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{<}\textcolor{preprocessor}{cstdlib}\textcolor{preprocessor}{>}}
\DoxyCodeLine{00033\ }
\DoxyCodeLine{00034\ \textcolor{keyword}{namespace}\ \mbox{\hyperlink{namespacesrsran}{srsran}}\ \{}
\DoxyCodeLine{00035\ }
\DoxyCodeLine{00036\ \textcolor{comment}{///\ \(\backslash\)brief\ Types\ of\ concurrent\ queues.\ They\ differ\ in\ type\ of\ synchronization\ mechanism\ and\ number\ of}}
\DoxyCodeLine{00037\ \textcolor{comment}{///\ producers/consumers\ supported.\ Supported\ types\ are:}}
\DoxyCodeLine{00038\ \textcolor{comment}{///\ -\/\ lockfree\_spsc:\ lockfree\ single\ producer\ single\ consumer\ queue\ (SPSC).}}
\DoxyCodeLine{00039\ \textcolor{comment}{///\ -\/\ lockfree\_mpmc:\ lockfree\ multiple\ producer\ multiple\ consumer\ queue\ (MPMC).}}
\DoxyCodeLine{00040\ \textcolor{comment}{///\ -\/\ locking\_mpmc:\ multiple\ producer\ multiple\ consumer\ (MPMC)\ queue\ that\ uses\ a\ mutex\ for\ synchronization.\ It\ is\ the}}
\DoxyCodeLine{00041\ \textcolor{comment}{///\ most\ generic\ type\ of\ queue,\ but\ it\ is\ also\ the\ slowest.\ It\ relies\ on\ a\ condition\ variable\ to\ wake\ up\ producers\ and}}
\DoxyCodeLine{00042\ \textcolor{comment}{///\ consumers.}}
\DoxyCodeLine{00043\ \textcolor{comment}{///\ -\/\ locking\_mpsc:\ similar\ to\ the\ locking\_mpmc,\ but\ it\ leverages\ batch\ popping\ on\ the\ consumer\ side,\ to\ reduce}}
\DoxyCodeLine{00044\ \textcolor{comment}{///\ mutex\ contention.}}
\DoxyCodeLine{00045\ \textcolor{keyword}{enum}\ \textcolor{keyword}{class}\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}\ \{\ lockfree\_spsc,\ lockfree\_mpmc,\ locking\_mpmc,\ locking\_mpsc\ \};}
\DoxyCodeLine{00046\ }
\DoxyCodeLine{00047\ \textcolor{comment}{///\ \(\backslash\)brief\ Types\ of\ barriers\ used\ for\ blocking\ pushes/pops\ of\ elements.\ Three\ types:}}
\DoxyCodeLine{00048\ \textcolor{comment}{///\ -\/\ condition\_variable:\ uses\ a\ condition\ variable\ to\ wake\ up\ producers\ and\ consumers.}}
\DoxyCodeLine{00049\ \textcolor{comment}{///\ -\/\ sleep:\ spins\ on\ a\ sleep\ if\ the\ queue\ is\ full,\ in\ case\ of\ blocking\ push,\ and\ if\ the\ queue\ is\ empty\ in\ case\ of}}
\DoxyCodeLine{00050\ \textcolor{comment}{///\ blocking\ pop.}}
\DoxyCodeLine{00051\ \textcolor{comment}{///\ -\/\ non\_blocking:\ no\ blocking\ mechanism\ is\ exposed.}}
\DoxyCodeLine{00052\ \textcolor{keyword}{enum}\ \textcolor{keyword}{class}\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}\ \{\ condition\_variable,\ sleep,\ non\_blocking\ \};}
\DoxyCodeLine{00053\ }
\DoxyCodeLine{00054\ \textcolor{comment}{///\ \(\backslash\)brief\ Parameters\ used\ to\ construct\ a\ concurrent\ queue.}}
\DoxyCodeLine{00055\ \textcolor{keyword}{struct}\ \mbox{\hyperlink{structsrsran_1_1concurrent__queue__params}{concurrent\_queue\_params}}\ \{}
\DoxyCodeLine{00056\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Queue\ policy\ to\ use\ for\ the\ task\ queue.\ E.g.\ SPSC,\ MPSC,\ MPMC,\ etc.}}
\DoxyCodeLine{00057\ \ \ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}\ \mbox{\hyperlink{structsrsran_1_1concurrent__queue__params_ab245964a339a3c1a634e9da298cbf2f5}{policy}};}
\DoxyCodeLine{00058\ \ \ \textcolor{comment}{///\ Task\ queue\ size.}}
\DoxyCodeLine{00059\ \ \ \textcolor{keywordtype}{unsigned}\ \mbox{\hyperlink{structsrsran_1_1concurrent__queue__params_ad3c91b18676301f004b23e7f1f6e05da}{size}};}
\DoxyCodeLine{00060\ \};}
\DoxyCodeLine{00061\ }
\DoxyCodeLine{00062\ \textcolor{keyword}{namespace}\ detail\ \{}
\DoxyCodeLine{00063\ }
\DoxyCodeLine{00064\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}\ Policy,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}\ BlockingPolicy>}
\DoxyCodeLine{00065\ \textcolor{keyword}{class}\ queue\_impl;}
\DoxyCodeLine{00066\ }
\DoxyCodeLine{00067\ \textcolor{comment}{//\ Specialization\ for\ lockfree\ SPSC\ without\ blocking\ mechanism.}}
\DoxyCodeLine{00068\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00069\ \textcolor{keyword}{class}\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::lockfree\_spsc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>}
\DoxyCodeLine{00070\ \{}
\DoxyCodeLine{00071\ \ \ \textcolor{keyword}{struct}\ custom\_deleter\ \{}
\DoxyCodeLine{00072\ \ \ \ \ \textcolor{keywordtype}{void}\ operator()(::rigtorp::SPSCQueue<T>*\ ptr)\ \textcolor{keyword}{const}}
\DoxyCodeLine{00073\ \ \ \ \ \{}
\DoxyCodeLine{00074\ \ \ \ \ \ \ \textcolor{keyword}{using}\ \textcolor{keyword}{namespace}\ ::rigtorp;}
\DoxyCodeLine{00075\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00076\ \ \ \ \ \ \ \ \ ptr-\/>\string~SPSCQueue<T>();}
\DoxyCodeLine{00077\ \ \ \ \ \ \ \ \ free(ptr);}
\DoxyCodeLine{00078\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00079\ \ \ \ \ \}}
\DoxyCodeLine{00080\ \ \ \};}
\DoxyCodeLine{00081\ }
\DoxyCodeLine{00082\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00083\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{00084\ \ \ \textcolor{keyword}{explicit}\ queue\_impl(size\_t\ qsize)}
\DoxyCodeLine{00085\ \ \ \{}
\DoxyCodeLine{00086\ \ \ \ \ \textcolor{comment}{//\ Note:\ Pre-\/c++17\ does\ not\ support\ new\ with\ alignof\ >\ alignof(max\_align\_t).}}
\DoxyCodeLine{00087\ \ \ \ \ \textcolor{keywordtype}{void}*\ ptr\ =\ \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{00088\ \ \ \ \ \textcolor{keywordtype}{int}\ \ \ ret\ =\ posix\_memalign(\&ptr,\ \textcolor{keyword}{alignof}(::rigtorp::SPSCQueue<T>),\ \textcolor{keyword}{sizeof}(::rigtorp::SPSCQueue<T>));}
\DoxyCodeLine{00089\ \ \ \ \ \mbox{\hyperlink{error__handling_8h_af2a19668fa4937d5d6aa2c93f42b7f8a}{report\_error\_if\_not}}(ret\ ==\ 0,\ \textcolor{stringliteral}{"{}Unable\ to\ allocate\ memory\ for\ SPSCQueue"{}});}
\DoxyCodeLine{00090\ \ \ \ \ queue.reset(\textcolor{keyword}{new}\ (ptr)::rigtorp::SPSCQueue<T>(qsize));}
\DoxyCodeLine{00091\ \ \ \}}
\DoxyCodeLine{00092\ }
\DoxyCodeLine{00093\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00094\ \ \ \textcolor{keywordtype}{bool}\ try\_push(U\&\&\ elem)}
\DoxyCodeLine{00095\ \ \ \{}
\DoxyCodeLine{00096\ \ \ \ \ \textcolor{keywordflow}{return}\ queue-\/>try\_push(std::forward<U>(elem));}
\DoxyCodeLine{00097\ \ \ \}}
\DoxyCodeLine{00098\ }
\DoxyCodeLine{00099\ \ \ \textcolor{keywordtype}{bool}\ try\_pop(T\&\ elem)}
\DoxyCodeLine{00100\ \ \ \{}
\DoxyCodeLine{00101\ \ \ \ \ T*\ front\ =\ queue-\/>front();}
\DoxyCodeLine{00102\ \ \ \ \ \textcolor{keywordflow}{if}\ (front\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00103\ \ \ \ \ \ \ elem\ =\ std::move(*front);}
\DoxyCodeLine{00104\ \ \ \ \ \ \ queue-\/>pop();}
\DoxyCodeLine{00105\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00106\ \ \ \ \ \}}
\DoxyCodeLine{00107\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00108\ \ \ \}}
\DoxyCodeLine{00109\ }
\DoxyCodeLine{00110\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PoppingFunc>}
\DoxyCodeLine{00111\ \ \ \textcolor{keywordtype}{bool}\ try\_call\_on\_pop(PoppingFunc\&\&\ func)}
\DoxyCodeLine{00112\ \ \ \{}
\DoxyCodeLine{00113\ \ \ \ \ T*\ front\ =\ queue-\/>front();}
\DoxyCodeLine{00114\ \ \ \ \ \textcolor{keywordflow}{if}\ (front\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00115\ \ \ \ \ \ \ func(*front);}
\DoxyCodeLine{00116\ \ \ \ \ \ \ queue-\/>pop();}
\DoxyCodeLine{00117\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00118\ \ \ \ \ \}}
\DoxyCodeLine{00119\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00120\ \ \ \}}
\DoxyCodeLine{00121\ }
\DoxyCodeLine{00122\ \ \ size\_t\ size()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue-\/>size();\ \}}
\DoxyCodeLine{00123\ }
\DoxyCodeLine{00124\ \ \ \textcolor{keywordtype}{bool}\ empty()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue-\/>empty();\ \}}
\DoxyCodeLine{00125\ }
\DoxyCodeLine{00126\ \ \ size\_t\ capacity()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue-\/>capacity();\ \}}
\DoxyCodeLine{00127\ }
\DoxyCodeLine{00128\ \textcolor{keyword}{protected}:}
\DoxyCodeLine{00129\ \ \ std::unique\_ptr<::rigtorp::SPSCQueue<T>,\ custom\_deleter>\ queue;}
\DoxyCodeLine{00130\ \};}
\DoxyCodeLine{00131\ }
\DoxyCodeLine{00132\ \textcolor{comment}{//\ Specialization\ for\ lockfree\ SPSC\ using\ a\ spin\ sleep\ loop\ as\ blocking\ mechanism.}}
\DoxyCodeLine{00133\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00134\ \textcolor{keyword}{class}\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::lockfree\_spsc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::sleep>}
\DoxyCodeLine{00135\ \ \ :\ \textcolor{keyword}{public}\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::lockfree\_spsc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>}
\DoxyCodeLine{00136\ \{}
\DoxyCodeLine{00137\ \ \ \textcolor{keyword}{using}\ base\_type\ =\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::lockfree\_spsc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>;}
\DoxyCodeLine{00138\ }
\DoxyCodeLine{00139\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00140\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{00141\ \ \ \textcolor{keyword}{explicit}\ queue\_impl(size\_t\ qsize,\ std::chrono::microseconds\ sleep\_time\_)\ :}
\DoxyCodeLine{00142\ \ \ \ \ queue\_impl<T,\ concurrent\_queue\_policy::lockfree\_spsc,\ concurrent\_queue\_wait\_policy::non\_blocking>(qsize),}
\DoxyCodeLine{00143\ \ \ \ \ sleep\_time(sleep\_time\_)}
\DoxyCodeLine{00144\ \ \ \{}
\DoxyCodeLine{00145\ \ \ \}}
\DoxyCodeLine{00146\ }
\DoxyCodeLine{00147\ \ \ \textcolor{keywordtype}{void}\ request\_stop()\ \{\ running\ =\ \textcolor{keyword}{false};\ \}}
\DoxyCodeLine{00148\ }
\DoxyCodeLine{00149\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00150\ \ \ \textcolor{keywordtype}{bool}\ push\_blocking(U\&\&\ elem)}
\DoxyCodeLine{00151\ \ \ \{}
\DoxyCodeLine{00152\ \ \ \ \ \textcolor{keywordflow}{while}\ (running.load(std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{00153\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{this}-\/>try\_push(std::forward<U>(elem)))\ \{}
\DoxyCodeLine{00154\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00155\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00156\ \ \ \ \ \ \ std::this\_thread::sleep\_for(sleep\_time);}
\DoxyCodeLine{00157\ \ \ \ \ \}}
\DoxyCodeLine{00158\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00159\ \ \ \}}
\DoxyCodeLine{00160\ }
\DoxyCodeLine{00161\ \ \ \textcolor{keywordtype}{bool}\ pop\_blocking(T\&\ elem)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00162\ \ \ \{}
\DoxyCodeLine{00163\ \ \ \ \ T*\ f\ =\ front\_blocking();}
\DoxyCodeLine{00164\ \ \ \ \ \textcolor{keywordflow}{if}\ (f\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00165\ \ \ \ \ \ \ elem\ =\ std::move(*f);}
\DoxyCodeLine{00166\ \ \ \ \ \ \ \textcolor{keyword}{this}-\/>queue-\/>pop();}
\DoxyCodeLine{00167\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00168\ \ \ \ \ \}}
\DoxyCodeLine{00169\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00170\ \ \ \}}
\DoxyCodeLine{00171\ }
\DoxyCodeLine{00172\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PoppingFunc>}
\DoxyCodeLine{00173\ \ \ \textcolor{keywordtype}{bool}\ call\_on\_pop\_blocking(PoppingFunc\&\&\ func)}
\DoxyCodeLine{00174\ \ \ \{}
\DoxyCodeLine{00175\ \ \ \ \ T*\ f\ =\ front\_blocking();}
\DoxyCodeLine{00176\ \ \ \ \ \textcolor{keywordflow}{if}\ (f\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00177\ \ \ \ \ \ \ func(*f);}
\DoxyCodeLine{00178\ \ \ \ \ \ \ \textcolor{keyword}{this}-\/>queue-\/>pop();}
\DoxyCodeLine{00179\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00180\ \ \ \ \ \}}
\DoxyCodeLine{00181\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00182\ \ \ \}}
\DoxyCodeLine{00183\ }
\DoxyCodeLine{00184\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00185\ \ \ T*\ front\_blocking()}
\DoxyCodeLine{00186\ \ \ \{}
\DoxyCodeLine{00187\ \ \ \ \ \textcolor{keywordflow}{while}\ (running.load(std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{00188\ \ \ \ \ \ \ T*\ front\ =\ \textcolor{keyword}{this}-\/>queue-\/>front();}
\DoxyCodeLine{00189\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (front\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00190\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ front;}
\DoxyCodeLine{00191\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00192\ \ \ \ \ \ \ std::this\_thread::sleep\_for(sleep\_time);}
\DoxyCodeLine{00193\ \ \ \ \ \}}
\DoxyCodeLine{00194\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{00195\ \ \ \}}
\DoxyCodeLine{00196\ }
\DoxyCodeLine{00197\ \ \ std::chrono::microseconds\ sleep\_time;}
\DoxyCodeLine{00198\ \ \ std::atomic<\textcolor{keywordtype}{bool}>\ \ \ \ \ \ \ \ \ running\{\textcolor{keyword}{true}\};}
\DoxyCodeLine{00199\ \};}
\DoxyCodeLine{00200\ }
\DoxyCodeLine{00201\ \textcolor{comment}{//\ Specialization\ for\ lockfree\ MPMC\ using\ no\ blocking\ mechanism.}}
\DoxyCodeLine{00202\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00203\ \textcolor{keyword}{class}\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::lockfree\_mpmc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>}
\DoxyCodeLine{00204\ \{}
\DoxyCodeLine{00205\ \ \ \textcolor{keyword}{struct}\ custom\_deleter\ \{}
\DoxyCodeLine{00206\ \ \ \ \ \textcolor{keywordtype}{void}\ operator()(::rigtorp::MPMCQueue<T>*\ ptr)\ \textcolor{keyword}{const}}
\DoxyCodeLine{00207\ \ \ \ \ \{}
\DoxyCodeLine{00208\ \ \ \ \ \ \ \textcolor{keyword}{using}\ mpmc\_queue\ =\ ::rigtorp::MPMCQueue<T>;}
\DoxyCodeLine{00209\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ptr\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00210\ \ \ \ \ \ \ \ \ ptr-\/>\string~mpmc\_queue();}
\DoxyCodeLine{00211\ \ \ \ \ \ \ \ \ free(ptr);}
\DoxyCodeLine{00212\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00213\ \ \ \ \ \}}
\DoxyCodeLine{00214\ \ \ \};}
\DoxyCodeLine{00215\ }
\DoxyCodeLine{00216\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00217\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{00218\ \ \ \textcolor{keyword}{explicit}\ queue\_impl(size\_t\ qsize)}
\DoxyCodeLine{00219\ \ \ \{}
\DoxyCodeLine{00220\ \ \ \ \ \textcolor{comment}{//\ Note:\ Pre-\/c++17\ does\ not\ support\ new\ with\ alignof\ >\ alignof(max\_align\_t).}}
\DoxyCodeLine{00221\ \ \ \ \ \textcolor{keywordtype}{void}*\ ptr\ =\ \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{00222\ \ \ \ \ \textcolor{keywordtype}{int}\ \ \ ret\ =\ posix\_memalign(\&ptr,\ \textcolor{keyword}{alignof}(::rigtorp::MPMCQueue<T>),\ \textcolor{keyword}{sizeof}(::rigtorp::MPMCQueue<T>));}
\DoxyCodeLine{00223\ \ \ \ \ \mbox{\hyperlink{error__handling_8h_af2a19668fa4937d5d6aa2c93f42b7f8a}{report\_error\_if\_not}}(ret\ ==\ 0,\ \textcolor{stringliteral}{"{}Unable\ to\ allocate\ memory\ for\ MPMCQueue"{}});}
\DoxyCodeLine{00224\ \ \ \ \ queue.reset(\textcolor{keyword}{new}\ (ptr)::rigtorp::MPMCQueue<T>(qsize));}
\DoxyCodeLine{00225\ \ \ \}}
\DoxyCodeLine{00226\ }
\DoxyCodeLine{00227\ \ \ \textcolor{keywordtype}{bool}\ try\_push(\textcolor{keyword}{const}\ T\&\ elem)\ \{\ \textcolor{keywordflow}{return}\ queue-\/>try\_push(elem);\ \}}
\DoxyCodeLine{00228\ \ \ \textcolor{keywordtype}{bool}\ try\_push(T\&\&\ elem)\ \{\ \textcolor{keywordflow}{return}\ queue-\/>try\_push(std::move(elem));\ \}}
\DoxyCodeLine{00229\ }
\DoxyCodeLine{00230\ \ \ \textcolor{keywordtype}{bool}\ try\_pop(T\&\ elem)\ \{\ \textcolor{keywordflow}{return}\ queue-\/>try\_pop(elem);\ \}}
\DoxyCodeLine{00231\ }
\DoxyCodeLine{00232\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PoppingFunc>}
\DoxyCodeLine{00233\ \ \ \textcolor{keywordtype}{bool}\ try\_call\_on\_pop(PoppingFunc\&\&\ func)}
\DoxyCodeLine{00234\ \ \ \{}
\DoxyCodeLine{00235\ \ \ \ \ T\ t;}
\DoxyCodeLine{00236\ \ \ \ \ \textcolor{keywordflow}{if}\ (queue-\/>try\_pop(t))\ \{}
\DoxyCodeLine{00237\ \ \ \ \ \ \ func(t);}
\DoxyCodeLine{00238\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00239\ \ \ \ \ \}}
\DoxyCodeLine{00240\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00241\ \ \ \}}
\DoxyCodeLine{00242\ }
\DoxyCodeLine{00243\ \ \ size\_t\ size()\ \textcolor{keyword}{const}}
\DoxyCodeLine{00244\ \ \ \{}
\DoxyCodeLine{00245\ \ \ \ \ \textcolor{comment}{//\ Note:\ MPMCqueue\ size\ can\ be\ negative.}}
\DoxyCodeLine{00246\ \ \ \ \ ptrdiff\_t\ ret\ =\ queue-\/>size();}
\DoxyCodeLine{00247\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast}<size\_t>(std::max(ret,\ \textcolor{keyword}{static\_cast}<ptrdiff\_t>(0)));}
\DoxyCodeLine{00248\ \ \ \}}
\DoxyCodeLine{00249\ }
\DoxyCodeLine{00250\ \ \ \textcolor{keywordtype}{bool}\ empty()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue-\/>empty();\ \}}
\DoxyCodeLine{00251\ }
\DoxyCodeLine{00252\ \ \ size\_t\ capacity()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue-\/>capacity();\ \}}
\DoxyCodeLine{00253\ }
\DoxyCodeLine{00254\ \textcolor{keyword}{protected}:}
\DoxyCodeLine{00255\ \ \ std::unique\_ptr<::rigtorp::MPMCQueue<T>,\ custom\_deleter>\ queue;}
\DoxyCodeLine{00256\ \};}
\DoxyCodeLine{00257\ }
\DoxyCodeLine{00258\ \textcolor{comment}{//\ Specialization\ for\ lockfree\ MPMC\ using\ a\ sleep\ as\ blocking\ mechanism.}}
\DoxyCodeLine{00259\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00260\ \textcolor{keyword}{class}\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::lockfree\_mpmc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::sleep>}
\DoxyCodeLine{00261\ \ \ :\ \textcolor{keyword}{public}\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::lockfree\_mpmc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>}
\DoxyCodeLine{00262\ \{}
\DoxyCodeLine{00263\ \ \ \textcolor{keyword}{using}\ base\_type\ =\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::lockfree\_mpmc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>;}
\DoxyCodeLine{00264\ }
\DoxyCodeLine{00265\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00266\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{00267\ \ \ \textcolor{keyword}{explicit}\ queue\_impl(size\_t\ qsize,\ std::chrono::microseconds\ sleep\_time\_\ =\ std::chrono::microseconds\{0\})\ :}
\DoxyCodeLine{00268\ \ \ \ \ base\_type(qsize),\ sleep\_time(sleep\_time\_)}
\DoxyCodeLine{00269\ \ \ \{}
\DoxyCodeLine{00270\ \ \ \}}
\DoxyCodeLine{00271\ }
\DoxyCodeLine{00272\ \ \ \textcolor{keywordtype}{void}\ request\_stop()\ \{\ running\ =\ \textcolor{keyword}{false};\ \}}
\DoxyCodeLine{00273\ }
\DoxyCodeLine{00274\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00275\ \ \ \textcolor{keywordtype}{bool}\ push\_blocking(U\&\&\ elem)}
\DoxyCodeLine{00276\ \ \ \{}
\DoxyCodeLine{00277\ \ \ \ \ \textcolor{keywordflow}{while}\ (running.load(std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{00278\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{this}-\/>try\_push(std::forward<U>(elem)))\ \{}
\DoxyCodeLine{00279\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00280\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00281\ \ \ \ \ \ \ std::this\_thread::sleep\_for(sleep\_time);}
\DoxyCodeLine{00282\ \ \ \ \ \}}
\DoxyCodeLine{00283\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00284\ \ \ \}}
\DoxyCodeLine{00285\ }
\DoxyCodeLine{00286\ \ \ \textcolor{keywordtype}{bool}\ pop\_blocking(T\&\ elem)}
\DoxyCodeLine{00287\ \ \ \{}
\DoxyCodeLine{00288\ \ \ \ \ \textcolor{keywordflow}{while}\ (running.load(std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{00289\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{this}-\/>try\_pop(elem))\ \{}
\DoxyCodeLine{00290\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00291\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00292\ \ \ \ \ \ \ std::this\_thread::sleep\_for(sleep\_time);}
\DoxyCodeLine{00293\ \ \ \ \ \}}
\DoxyCodeLine{00294\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00295\ \ \ \}}
\DoxyCodeLine{00296\ }
\DoxyCodeLine{00297\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PoppingFunc>}
\DoxyCodeLine{00298\ \ \ \textcolor{keywordtype}{bool}\ call\_on\_pop\_blocking(PoppingFunc\&\&\ func)}
\DoxyCodeLine{00299\ \ \ \{}
\DoxyCodeLine{00300\ \ \ \ \ T\ elem;}
\DoxyCodeLine{00301\ \ \ \ \ \textcolor{keywordflow}{if}\ (pop\_blocking(elem))\ \{}
\DoxyCodeLine{00302\ \ \ \ \ \ \ func(elem);}
\DoxyCodeLine{00303\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00304\ \ \ \ \ \}}
\DoxyCodeLine{00305\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00306\ \ \ \}}
\DoxyCodeLine{00307\ }
\DoxyCodeLine{00308\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00309\ \ \ std::chrono::microseconds\ sleep\_time;}
\DoxyCodeLine{00310\ \ \ std::atomic<\textcolor{keywordtype}{bool}>\ \ \ \ \ \ \ \ \ running\{\textcolor{keyword}{true}\};}
\DoxyCodeLine{00311\ \};}
\DoxyCodeLine{00312\ }
\DoxyCodeLine{00313\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00314\ \textcolor{keyword}{class}\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::locking\_mpmc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>}
\DoxyCodeLine{00315\ \{}
\DoxyCodeLine{00316\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00317\ \ \ \textcolor{keyword}{explicit}\ queue\_impl(size\_t\ qsize)\ :\ queue(qsize)\ \{\}}
\DoxyCodeLine{00318\ }
\DoxyCodeLine{00319\ \ \ \textcolor{keywordtype}{void}\ request\_stop()\ \{\ queue.stop();\ \}}
\DoxyCodeLine{00320\ }
\DoxyCodeLine{00321\ \ \ \textcolor{keywordtype}{bool}\ try\_push(\textcolor{keyword}{const}\ T\&\ elem)\ \{\ \textcolor{keywordflow}{return}\ queue.try\_push(elem);\ \}}
\DoxyCodeLine{00322\ \ \ \textcolor{keywordtype}{bool}\ try\_push(T\&\&\ elem)\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{not}\ queue.try\_push(std::move(elem)).is\_error();\ \}}
\DoxyCodeLine{00323\ }
\DoxyCodeLine{00324\ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<T>\ try\_pop()}
\DoxyCodeLine{00325\ \ \ \{}
\DoxyCodeLine{00326\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<T>\ t;}
\DoxyCodeLine{00327\ \ \ \ \ t.emplace();}
\DoxyCodeLine{00328\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ queue.try\_pop(t.value()))\ \{}
\DoxyCodeLine{00329\ \ \ \ \ \ \ t.reset();}
\DoxyCodeLine{00330\ \ \ \ \ \}}
\DoxyCodeLine{00331\ \ \ \ \ \textcolor{keywordflow}{return}\ t;}
\DoxyCodeLine{00332\ \ \ \}}
\DoxyCodeLine{00333\ }
\DoxyCodeLine{00334\ \ \ \textcolor{keywordtype}{bool}\ try\_pop(T\&\ elem)\ \{\ \textcolor{keywordflow}{return}\ queue.try\_pop(elem);\ \}}
\DoxyCodeLine{00335\ }
\DoxyCodeLine{00336\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PoppingFunc>}
\DoxyCodeLine{00337\ \ \ \textcolor{keywordtype}{bool}\ try\_call\_on\_pop(PoppingFunc\&\&\ func)}
\DoxyCodeLine{00338\ \ \ \{}
\DoxyCodeLine{00339\ \ \ \ \ T\ t;}
\DoxyCodeLine{00340\ \ \ \ \ \textcolor{keywordflow}{if}\ (queue.try\_pop(t))\ \{}
\DoxyCodeLine{00341\ \ \ \ \ \ \ func(t);}
\DoxyCodeLine{00342\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00343\ \ \ \ \ \}}
\DoxyCodeLine{00344\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00345\ \ \ \}}
\DoxyCodeLine{00346\ }
\DoxyCodeLine{00347\ \ \ \textcolor{keywordtype}{void}\ clear()\ \{\ queue.clear();\ \}}
\DoxyCodeLine{00348\ }
\DoxyCodeLine{00349\ \ \ size\_t\ size()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue.size();\ \}}
\DoxyCodeLine{00350\ }
\DoxyCodeLine{00351\ \ \ \textcolor{keywordtype}{bool}\ empty()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue.empty();\ \}}
\DoxyCodeLine{00352\ }
\DoxyCodeLine{00353\ \ \ size\_t\ capacity()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue.max\_size();\ \}}
\DoxyCodeLine{00354\ }
\DoxyCodeLine{00355\ \textcolor{keyword}{protected}:}
\DoxyCodeLine{00356\ \ \ blocking\_queue<T>\ queue;}
\DoxyCodeLine{00357\ \};}
\DoxyCodeLine{00358\ }
\DoxyCodeLine{00359\ \textcolor{comment}{//\ Specialization\ for\ lock-\/based\ MPMC,\ using\ a\ condition\ variable\ as\ blocking\ mechanism.}}
\DoxyCodeLine{00360\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00361\ \textcolor{keyword}{class}\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::locking\_mpmc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::condition\_variable>}
\DoxyCodeLine{00362\ \ \ :\ \textcolor{keyword}{public}\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::locking\_mpmc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>}
\DoxyCodeLine{00363\ \{}
\DoxyCodeLine{00364\ \ \ \textcolor{keyword}{using}\ base\_type\ =\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::locking\_mpmc,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>;}
\DoxyCodeLine{00365\ }
\DoxyCodeLine{00366\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00367\ \ \ \textcolor{keyword}{explicit}\ queue\_impl(size\_t\ qsize)\ :\ base\_type(qsize)\ \{\}}
\DoxyCodeLine{00368\ }
\DoxyCodeLine{00369\ \ \ \textcolor{keywordtype}{bool}\ push\_blocking(\textcolor{keyword}{const}\ T\&\ elem)\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{this}-\/>queue.push\_blocking(elem);\ \}}
\DoxyCodeLine{00370\ \ \ \textcolor{keywordtype}{bool}\ push\_blocking(T\&\&\ elem)\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{not}\ \textcolor{keyword}{this}-\/>queue.push\_blocking(std::move(elem)).is\_error();\ \}}
\DoxyCodeLine{00371\ }
\DoxyCodeLine{00372\ \ \ \textcolor{keywordtype}{bool}\ pop\_blocking(T\&\ elem)}
\DoxyCodeLine{00373\ \ \ \{}
\DoxyCodeLine{00374\ \ \ \ \ \textcolor{keywordtype}{bool}\ success\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00375\ \ \ \ \ elem\ \ \ \ \ \ \ \ \ =\ \textcolor{keyword}{this}-\/>queue.pop\_blocking(\&success);}
\DoxyCodeLine{00376\ \ \ \ \ \textcolor{keywordflow}{return}\ success;}
\DoxyCodeLine{00377\ \ \ \}}
\DoxyCodeLine{00378\ }
\DoxyCodeLine{00379\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PoppingFunc>}
\DoxyCodeLine{00380\ \ \ \textcolor{keywordtype}{bool}\ call\_on\_pop\_blocking(PoppingFunc\&\&\ func)}
\DoxyCodeLine{00381\ \ \ \{}
\DoxyCodeLine{00382\ \ \ \ \ \textcolor{keywordtype}{bool}\ success\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00383\ \ \ \ \ T\ \ \ \ elem\ \ \ \ =\ \textcolor{keyword}{this}-\/>queue.pop\_blocking(\&success);}
\DoxyCodeLine{00384\ \ \ \ \ \textcolor{keywordflow}{if}\ (success)\ \{}
\DoxyCodeLine{00385\ \ \ \ \ \ \ func(elem);}
\DoxyCodeLine{00386\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00387\ \ \ \ \ \}}
\DoxyCodeLine{00388\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00389\ \ \ \}}
\DoxyCodeLine{00390\ \};}
\DoxyCodeLine{00391\ }
\DoxyCodeLine{00392\ \textcolor{comment}{//\ Barrier\ implementation\ based\ on\ sleep.}}
\DoxyCodeLine{00393\ \textcolor{keyword}{struct}\ \mbox{\hyperlink{structsrsran_1_1detail_1_1queue__sleep__barrier}{queue\_sleep\_barrier}}\ \{}
\DoxyCodeLine{00394\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00395\ \ \ queue\_sleep\_barrier(std::chrono::microseconds\ sleep\_time\_\ =\ std::chrono::microseconds\{0\})\ :\ sleep\_time(sleep\_time\_)\ \{\}}
\DoxyCodeLine{00396\ }
\DoxyCodeLine{00397\ \ \ \textcolor{keywordtype}{void}\ request\_stop()\ \{\ running\ =\ \textcolor{keyword}{false};\ \}}
\DoxyCodeLine{00398\ }
\DoxyCodeLine{00399\ \ \ \textcolor{keywordtype}{void}\ notify\_push()}
\DoxyCodeLine{00400\ \ \ \{}
\DoxyCodeLine{00401\ \ \ \ \ \textcolor{comment}{//\ do\ nothing.}}
\DoxyCodeLine{00402\ \ \ \}}
\DoxyCodeLine{00403\ }
\DoxyCodeLine{00404\ \ \ \textcolor{keywordtype}{void}\ notify\_pop()}
\DoxyCodeLine{00405\ \ \ \{}
\DoxyCodeLine{00406\ \ \ \ \ \textcolor{comment}{//\ do\ nothing.}}
\DoxyCodeLine{00407\ \ \ \}}
\DoxyCodeLine{00408\ }
\DoxyCodeLine{00409\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ HasSpace>}
\DoxyCodeLine{00410\ \ \ \textcolor{keywordtype}{void}\ wait\_push(std::unique\_lock<std::mutex>\&\ lock,\ \textcolor{keyword}{const}\ HasSpace\&\ has\_space)}
\DoxyCodeLine{00411\ \ \ \{}
\DoxyCodeLine{00412\ \ \ \ \ \textcolor{keywordflow}{while}\ (running.load(std::memory\_order\_relaxed)\ \textcolor{keyword}{and}\ \textcolor{keyword}{not}\ has\_space())\ \{}
\DoxyCodeLine{00413\ \ \ \ \ \ \ lock.unlock();}
\DoxyCodeLine{00414\ \ \ \ \ \ \ std::this\_thread::sleep\_for(sleep\_time);}
\DoxyCodeLine{00415\ \ \ \ \ \ \ lock.lock();}
\DoxyCodeLine{00416\ \ \ \ \ \}}
\DoxyCodeLine{00417\ \ \ \}}
\DoxyCodeLine{00418\ }
\DoxyCodeLine{00419\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ HasElem>}
\DoxyCodeLine{00420\ \ \ \textcolor{keywordtype}{void}\ wait\_pop(std::unique\_lock<std::mutex>\&\ lock,\ \textcolor{keyword}{const}\ HasElem\&\ has\_elem)}
\DoxyCodeLine{00421\ \ \ \{}
\DoxyCodeLine{00422\ \ \ \ \ \textcolor{keywordflow}{while}\ (running.load(std::memory\_order\_relaxed)\ \textcolor{keyword}{and}\ \textcolor{keyword}{not}\ has\_elem())\ \{}
\DoxyCodeLine{00423\ \ \ \ \ \ \ lock.unlock();}
\DoxyCodeLine{00424\ \ \ \ \ \ \ std::this\_thread::sleep\_for(sleep\_time);}
\DoxyCodeLine{00425\ \ \ \ \ \ \ lock.lock();}
\DoxyCodeLine{00426\ \ \ \ \ \}}
\DoxyCodeLine{00427\ \ \ \}}
\DoxyCodeLine{00428\ }
\DoxyCodeLine{00429\ \ \ \textcolor{keywordtype}{bool}\ is\_running()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ running.load(std::memory\_order\_relaxed);\ \}}
\DoxyCodeLine{00430\ }
\DoxyCodeLine{00431\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00432\ \ \ std::atomic<\textcolor{keywordtype}{bool}>\ \ \ \ \ \ \ \ \ running\{\textcolor{keyword}{true}\};}
\DoxyCodeLine{00433\ \ \ std::chrono::microseconds\ sleep\_time;}
\DoxyCodeLine{00434\ \};}
\DoxyCodeLine{00435\ }
\DoxyCodeLine{00436\ \textcolor{comment}{//\ Barrier\ implementation\ based\ on\ condition\ variable.}}
\DoxyCodeLine{00437\ \textcolor{keyword}{struct}\ \mbox{\hyperlink{structsrsran_1_1detail_1_1queue__cond__var__barrier}{queue\_cond\_var\_barrier}}\ \{}
\DoxyCodeLine{00438\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00439\ \ \ \textcolor{keywordtype}{void}\ request\_stop()}
\DoxyCodeLine{00440\ \ \ \{}
\DoxyCodeLine{00441\ \ \ \ \ running\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00442\ \ \ \ \ notify\_push();}
\DoxyCodeLine{00443\ \ \ \ \ notify\_pop();}
\DoxyCodeLine{00444\ \ \ \}}
\DoxyCodeLine{00445\ }
\DoxyCodeLine{00446\ \ \ \textcolor{keywordtype}{void}\ notify\_push()\ \{\ cvar\_push.notify\_one();\ \}}
\DoxyCodeLine{00447\ }
\DoxyCodeLine{00448\ \ \ \textcolor{keywordtype}{void}\ notify\_pop()\ \{\ cvar\_pop.notify\_one();\ \}}
\DoxyCodeLine{00449\ }
\DoxyCodeLine{00450\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ HasSpace>}
\DoxyCodeLine{00451\ \ \ \textcolor{keywordtype}{void}\ wait\_push(std::unique\_lock<std::mutex>\&\ lock,\ \textcolor{keyword}{const}\ HasSpace\&\ has\_space)}
\DoxyCodeLine{00452\ \ \ \{}
\DoxyCodeLine{00453\ \ \ \ \ cvar\_pop.wait(lock,\ [\textcolor{keyword}{this},\ \&has\_space]()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{not}\ running.load(std::memory\_order\_relaxed)\ \textcolor{keyword}{or}\ has\_space();\ \});}
\DoxyCodeLine{00454\ \ \ \}}
\DoxyCodeLine{00455\ }
\DoxyCodeLine{00456\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ HasElem>}
\DoxyCodeLine{00457\ \ \ \textcolor{keywordtype}{void}\ wait\_pop(std::unique\_lock<std::mutex>\&\ lock,\ \textcolor{keyword}{const}\ HasElem\&\ has\_elem)}
\DoxyCodeLine{00458\ \ \ \{}
\DoxyCodeLine{00459\ \ \ \ \ cvar\_push.wait(lock,\ [\textcolor{keyword}{this},\ \&has\_elem]()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{not}\ running.load(std::memory\_order\_relaxed)\ \textcolor{keyword}{or}\ has\_elem();\ \});}
\DoxyCodeLine{00460\ \ \ \}}
\DoxyCodeLine{00461\ }
\DoxyCodeLine{00462\ \ \ \textcolor{keywordtype}{bool}\ is\_running()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ running.load(std::memory\_order\_relaxed);\ \}}
\DoxyCodeLine{00463\ }
\DoxyCodeLine{00464\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00465\ \ \ std::atomic<\textcolor{keywordtype}{bool}>\ \ \ \ \ \ \ running\{\textcolor{keyword}{true}\};}
\DoxyCodeLine{00466\ \ \ std::condition\_variable\ cvar\_pop,\ cvar\_push;}
\DoxyCodeLine{00467\ \};}
\DoxyCodeLine{00468\ }
\DoxyCodeLine{00469\ \textcolor{comment}{//\ Specialization\ for\ lock-\/based\ MPSC,\ using\ a\ condition\ variable\ or\ sleep\ as\ blocking\ mechanism.\ The\ dequeues\ are}}
\DoxyCodeLine{00470\ \textcolor{comment}{//\ done\ in\ a\ batch\ to\ minimize\ mutex\ contention.}}
\DoxyCodeLine{00471\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}\ BlockingPolicy>}
\DoxyCodeLine{00472\ \textcolor{keyword}{class}\ queue\_impl<T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}::locking\_mpsc,\ BlockingPolicy>}
\DoxyCodeLine{00473\ \{}
\DoxyCodeLine{00474\ \ \ \textcolor{keyword}{using}\ queue\_barrier\ =\ std::conditional\_t<BlockingPolicy\ ==\ concurrent\_queue\_wait\_policy::condition\_variable,}
\DoxyCodeLine{00475\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ queue\_cond\_var\_barrier,}
\DoxyCodeLine{00476\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ queue\_sleep\_barrier>;}
\DoxyCodeLine{00477\ }
\DoxyCodeLine{00478\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00479\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{00480\ \ \ \textcolor{keyword}{explicit}\ queue\_impl(size\_t\ qsize,\ Args\&\&...\ args)\ :}
\DoxyCodeLine{00481\ \ \ \ \ cap(qsize),}
\DoxyCodeLine{00482\ \ \ \ \ queues(\{ring\_buffer<T,\ \textcolor{keyword}{true}>\{(\textcolor{keywordtype}{unsigned})qsize\},\ ring\_buffer<T,\ \textcolor{keyword}{true}>\{(\textcolor{keywordtype}{unsigned})qsize\}\}),}
\DoxyCodeLine{00483\ \ \ \ \ barrier(std::forward<Args>(args)...)}
\DoxyCodeLine{00484\ \ \ \{}
\DoxyCodeLine{00485\ \ \ \}}
\DoxyCodeLine{00486\ }
\DoxyCodeLine{00487\ \ \ \textcolor{keywordtype}{void}\ request\_stop()}
\DoxyCodeLine{00488\ \ \ \{}
\DoxyCodeLine{00489\ \ \ \ \ std::lock\_guard<std::mutex>\ lock(mutex);}
\DoxyCodeLine{00490\ \ \ \ \ pushing\_queue().clear();}
\DoxyCodeLine{00491\ \ \ \ \ barrier.request\_stop();}
\DoxyCodeLine{00492\ \ \ \}}
\DoxyCodeLine{00493\ }
\DoxyCodeLine{00494\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00495\ \ \ \textcolor{keywordtype}{bool}\ try\_push(U\&\&\ elem)}
\DoxyCodeLine{00496\ \ \ \{}
\DoxyCodeLine{00497\ \ \ \ \ std::unique\_lock<std::mutex>\ lock(mutex);}
\DoxyCodeLine{00498\ \ \ \ \ \textcolor{keywordflow}{if}\ (barrier.is\_running()\ \textcolor{keyword}{and}\ \textcolor{keyword}{not}\ pushing\_queue().full())\ \{}
\DoxyCodeLine{00499\ \ \ \ \ \ \ pushing\_queue().push(std::forward<U>(elem));}
\DoxyCodeLine{00500\ \ \ \ \ \ \ barrier.notify\_push();}
\DoxyCodeLine{00501\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00502\ \ \ \ \ \}}
\DoxyCodeLine{00503\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00504\ \ \ \}}
\DoxyCodeLine{00505\ }
\DoxyCodeLine{00506\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00507\ \ \ \textcolor{keywordtype}{bool}\ push\_blocking(U\&\&\ elem)}
\DoxyCodeLine{00508\ \ \ \{}
\DoxyCodeLine{00509\ \ \ \ \ std::unique\_lock<std::mutex>\ lock(mutex);}
\DoxyCodeLine{00510\ \ \ \ \ barrier.wait\_push(lock,\ [\textcolor{keyword}{this}]()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{not}\ pushing\_queue().full();\ \});}
\DoxyCodeLine{00511\ \ \ \ \ \textcolor{keywordflow}{if}\ (barrier.is\_running())\ \{}
\DoxyCodeLine{00512\ \ \ \ \ \ \ pushing\_queue().push(std::forward<U>(elem));}
\DoxyCodeLine{00513\ \ \ \ \ \ \ barrier.notify\_push();}
\DoxyCodeLine{00514\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00515\ \ \ \ \ \}}
\DoxyCodeLine{00516\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00517\ \ \ \}}
\DoxyCodeLine{00518\ }
\DoxyCodeLine{00519\ \ \ \textcolor{keywordtype}{bool}\ try\_pop(T\&\ elem)}
\DoxyCodeLine{00520\ \ \ \{}
\DoxyCodeLine{00521\ \ \ \ \ T*\ f\ =\ front<\textcolor{keyword}{false}>();}
\DoxyCodeLine{00522\ \ \ \ \ \textcolor{keywordflow}{if}\ (f\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00523\ \ \ \ \ \ \ elem\ =\ std::move(*f);}
\DoxyCodeLine{00524\ \ \ \ \ \ \ pop();}
\DoxyCodeLine{00525\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00526\ \ \ \ \ \}}
\DoxyCodeLine{00527\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00528\ \ \ \}}
\DoxyCodeLine{00529\ }
\DoxyCodeLine{00530\ \ \ \textcolor{keywordtype}{bool}\ pop\_blocking(T\&\ elem)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00531\ \ \ \{}
\DoxyCodeLine{00532\ \ \ \ \ T*\ f\ =\ front<\textcolor{keyword}{true}>();}
\DoxyCodeLine{00533\ \ \ \ \ \textcolor{keywordflow}{if}\ (f\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00534\ \ \ \ \ \ \ elem\ =\ std::move(*f);}
\DoxyCodeLine{00535\ \ \ \ \ \ \ pop();}
\DoxyCodeLine{00536\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00537\ \ \ \ \ \}}
\DoxyCodeLine{00538\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00539\ \ \ \}}
\DoxyCodeLine{00540\ }
\DoxyCodeLine{00541\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PoppingFunc>}
\DoxyCodeLine{00542\ \ \ \textcolor{keywordtype}{bool}\ try\_call\_on\_pop(PoppingFunc\&\&\ func)}
\DoxyCodeLine{00543\ \ \ \{}
\DoxyCodeLine{00544\ \ \ \ \ T*\ f\ =\ front<\textcolor{keyword}{false}>();}
\DoxyCodeLine{00545\ \ \ \ \ \textcolor{keywordflow}{if}\ (f\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00546\ \ \ \ \ \ \ func(*f);}
\DoxyCodeLine{00547\ \ \ \ \ \ \ pop();}
\DoxyCodeLine{00548\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00549\ \ \ \ \ \}}
\DoxyCodeLine{00550\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00551\ \ \ \}}
\DoxyCodeLine{00552\ }
\DoxyCodeLine{00553\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PoppingFunc>}
\DoxyCodeLine{00554\ \ \ \textcolor{keywordtype}{bool}\ call\_on\_pop\_blocking(PoppingFunc\&\&\ func)}
\DoxyCodeLine{00555\ \ \ \{}
\DoxyCodeLine{00556\ \ \ \ \ T*\ f\ =\ front<\textcolor{keyword}{true}>();}
\DoxyCodeLine{00557\ \ \ \ \ \textcolor{keywordflow}{if}\ (f\ !=\ \textcolor{keywordtype}{nullptr})\ \{}
\DoxyCodeLine{00558\ \ \ \ \ \ \ func(*f);}
\DoxyCodeLine{00559\ \ \ \ \ \ \ pop();}
\DoxyCodeLine{00560\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00561\ \ \ \ \ \}}
\DoxyCodeLine{00562\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00563\ \ \ \}}
\DoxyCodeLine{00564\ }
\DoxyCodeLine{00565\ \ \ size\_t\ size()\ \textcolor{keyword}{const}}
\DoxyCodeLine{00566\ \ \ \{}
\DoxyCodeLine{00567\ \ \ \ \ std::lock\_guard<std::mutex>\ lock(mutex);}
\DoxyCodeLine{00568\ \ \ \ \ \textcolor{keywordflow}{return}\ pushing\_queue().size()\ +\ count\_local\_objs.load(std::memory\_order\_relaxed);}
\DoxyCodeLine{00569\ \ \ \}}
\DoxyCodeLine{00570\ }
\DoxyCodeLine{00571\ \ \ \textcolor{keywordtype}{bool}\ empty()\ \textcolor{keyword}{const}}
\DoxyCodeLine{00572\ \ \ \{}
\DoxyCodeLine{00573\ \ \ \ \ \textcolor{keywordflow}{if}\ (count\_local\_objs.load(std::memory\_order\_relaxed)\ >\ 0)\ \{}
\DoxyCodeLine{00574\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00575\ \ \ \ \ \}}
\DoxyCodeLine{00576\ \ \ \ \ std::lock\_guard<std::mutex>\ lock(mutex);}
\DoxyCodeLine{00577\ \ \ \ \ \textcolor{keywordflow}{return}\ pushing\_queue().empty();}
\DoxyCodeLine{00578\ \ \ \}}
\DoxyCodeLine{00579\ }
\DoxyCodeLine{00580\ \ \ size\_t\ capacity()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ cap;\ \}}
\DoxyCodeLine{00581\ }
\DoxyCodeLine{00582\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00583\ \ \ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{bool}\ Blocking>}
\DoxyCodeLine{00584\ \ \ T*\ front()}
\DoxyCodeLine{00585\ \ \ \{}
\DoxyCodeLine{00586\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ barrier.is\_running())\ \{}
\DoxyCodeLine{00587\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{00588\ \ \ \ \ \}}
\DoxyCodeLine{00589\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ popping\_queue().empty())\ \{}
\DoxyCodeLine{00590\ \ \ \ \ \ \ \textcolor{comment}{//\ Successful\ pop.}}
\DoxyCodeLine{00591\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \&popping\_queue().top();}
\DoxyCodeLine{00592\ \ \ \ \ \}}
\DoxyCodeLine{00593\ \ \ \ \ \{}
\DoxyCodeLine{00594\ \ \ \ \ \ \ std::unique\_lock<std::mutex>\ lock(mutex);}
\DoxyCodeLine{00595\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (Blocking)\ \{}
\DoxyCodeLine{00596\ \ \ \ \ \ \ \ \ barrier.wait\_pop(lock,\ [\textcolor{keyword}{this}]()\ \{\ \textcolor{keywordflow}{return}\ !pushing\_queue().empty();\ \});}
\DoxyCodeLine{00597\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ barrier.is\_running())\ \{}
\DoxyCodeLine{00598\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{00599\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00600\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (pushing\_queue().empty())\ \{}
\DoxyCodeLine{00601\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{00602\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00603\ \ \ \ \ \ \ \textcolor{comment}{//\ Swap\ queues.}}
\DoxyCodeLine{00604\ \ \ \ \ \ \ index\_queue\_for\_pop\ =\ 1\ -\/\ index\_queue\_for\_pop;}
\DoxyCodeLine{00605\ \ \ \ \ \}}
\DoxyCodeLine{00606\ \ \ \ \ barrier.notify\_pop();}
\DoxyCodeLine{00607\ \ \ \ \ count\_local\_objs.store(popping\_queue().size(),\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00608\ \ \ \ \ \textcolor{keywordflow}{return}\ \&popping\_queue().top();}
\DoxyCodeLine{00609\ \ \ \}}
\DoxyCodeLine{00610\ }
\DoxyCodeLine{00611\ \ \ \textcolor{keywordtype}{void}\ pop()}
\DoxyCodeLine{00612\ \ \ \{}
\DoxyCodeLine{00613\ \ \ \ \ popping\_queue().pop();}
\DoxyCodeLine{00614\ \ \ \ \ count\_local\_objs.fetch\_sub(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00615\ \ \ \}}
\DoxyCodeLine{00616\ }
\DoxyCodeLine{00617\ \ \ ring\_buffer<T,\ \textcolor{keyword}{true}>\&\ \ \ \ \ \ \ popping\_queue()\ \{\ \textcolor{keywordflow}{return}\ queues[index\_queue\_for\_pop];\ \}}
\DoxyCodeLine{00618\ \ \ ring\_buffer<T,\ \textcolor{keyword}{true}>\&\ \ \ \ \ \ \ pushing\_queue()\ \{\ \textcolor{keywordflow}{return}\ queues[1\ -\/\ index\_queue\_for\_pop];\ \}}
\DoxyCodeLine{00619\ \ \ \textcolor{keyword}{const}\ ring\_buffer<T,\ \textcolor{keyword}{true}>\&\ pushing\_queue()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queues[1\ -\/\ index\_queue\_for\_pop];\ \}}
\DoxyCodeLine{00620\ }
\DoxyCodeLine{00621\ \ \ \textcolor{keyword}{const}\ size\_t\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ cap;}
\DoxyCodeLine{00622\ \ \ std::atomic<\textcolor{keywordtype}{unsigned}>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ count\_local\_objs\{0\};}
\DoxyCodeLine{00623\ \ \ std::array<ring\_buffer<T,\ \textcolor{keyword}{true}>,\ 2>\ queues;}
\DoxyCodeLine{00624\ \ \ \textcolor{keywordtype}{unsigned}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ index\_queue\_for\_pop\ =\ 0;}
\DoxyCodeLine{00625\ \ \ \textcolor{keyword}{mutable}\ std::mutex\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ mutex;}
\DoxyCodeLine{00626\ \ \ queue\_barrier\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ barrier;}
\DoxyCodeLine{00627\ \};}
\DoxyCodeLine{00628\ }
\DoxyCodeLine{00629\ \}\ \textcolor{comment}{//\ namespace\ detail}}
\DoxyCodeLine{00630\ }
\DoxyCodeLine{00631\ \textcolor{comment}{///\ \(\backslash\)brief\ A\ concurrent\ queue\ that\ can\ be\ used\ to\ pass\ objects\ between\ threads.\ Different\ policies\ are\ supported:}}
\DoxyCodeLine{00632\ \textcolor{comment}{///\ -\/\ lockfree\_spsc:\ a\ lock-\/free\ single-\/producer\ single-\/consumer\ queue.\ This\ is\ the\ fastest\ option.}}
\DoxyCodeLine{00633\ \textcolor{comment}{///\ -\/\ locking\_mpmc:\ a\ multi-\/producer\ multi-\/consumer\ queue\ that\ uses\ a\ mutex\ to\ protect\ the\ queue.\ This\ is\ the\ most}}
\DoxyCodeLine{00634\ \textcolor{comment}{///\ most\ general\ queue,\ but\ has\ the\ highest\ overhead.\ The\ producers\ and\ consumers\ will\ contend\ on\ the\ access\ to\ the}}
\DoxyCodeLine{00635\ \textcolor{comment}{///\ mutex.}}
\DoxyCodeLine{00636\ \textcolor{comment}{///\ -\/\ locking\_mpsc:\ a\ multi-\/producer\ single-\/consumer\ queue\ that\ uses\ a\ mutex\ to\ protect\ the\ queue.\ This\ queue\ pops}}
\DoxyCodeLine{00637\ \textcolor{comment}{///\ all\ elements\ in\ a\ batch\ to\ minimize\ the\ contention\ on\ the\ mutex\ from\ the\ consumer\ side.}}
\DoxyCodeLine{00638\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}\ Policy,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}\ BlockingPolicy>}
\DoxyCodeLine{00639\ \textcolor{keyword}{class}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{concurrent\_queue}}}
\DoxyCodeLine{00640\ \{}
\DoxyCodeLine{00641\ \ \ \textcolor{keyword}{using}\ queue\_type\ =\ detail::queue\_impl<T,\ Policy,\ BlockingPolicy>;}
\DoxyCodeLine{00642\ }
\DoxyCodeLine{00643\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00644\ \ \ \textcolor{keyword}{using}\ value\_type\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ T;}
\DoxyCodeLine{00645\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}\ \ \ \ \ \ queue\_policy\ =\ Policy;}
\DoxyCodeLine{00646\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}\ wait\_policy\ \ =\ BlockingPolicy;}
\DoxyCodeLine{00647\ }
\DoxyCodeLine{00648\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{00649\ \ \ \textcolor{keyword}{explicit}\ concurrent\_queue(size\_t\ minimum\_q\_size,\ Args\&\&...\ args)\ :\ queue(minimum\_q\_size,\ std::forward<Args>(args)...)}
\DoxyCodeLine{00650\ \ \ \{}
\DoxyCodeLine{00651\ \ \ \}}
\DoxyCodeLine{00652\ }
\DoxyCodeLine{00653\ \ \ \textcolor{comment}{///\ Pushes\ a\ new\ element\ into\ the\ queue\ in\ a\ non-\/blocking\ fashion.\ If\ the\ queue\ is\ full,\ the\ element\ is\ not\ pushed.}}
\DoxyCodeLine{00654\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ true\ if\ the\ element\ was\ pushed,\ false\ otherwise.}}
\DoxyCodeLine{00655\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00656\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a83c3ee3074579631ed08e3414377a541}{try\_push}}(U\&\&\ elem)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00657\ \ \ \{}
\DoxyCodeLine{00658\ \ \ \ \ \textcolor{keywordflow}{return}\ queue.try\_push(std::forward<U>(elem));}
\DoxyCodeLine{00659\ \ \ \}}
\DoxyCodeLine{00660\ }
\DoxyCodeLine{00661\ \ \ \textcolor{comment}{///\ Pushes\ a\ new\ element\ into\ the\ queue.\ If\ the\ queue\ is\ full,\ the\ call\ blocks,\ waiting\ for\ a\ new\ slot\ to\ become}}
\DoxyCodeLine{00662\ \ \ \textcolor{comment}{///\ emptied.}}
\DoxyCodeLine{00663\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ true\ if\ the\ element\ was\ pushed,\ false\ if\ the\ queue\ was\ closed.}}
\DoxyCodeLine{00664\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ U,}
\DoxyCodeLine{00665\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}\ Q\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ BlockingPolicy,}
\DoxyCodeLine{00666\ \ \ \ \ \ \ \ \ \ \ \ \ std::enable\_if\_t<Q\ !=\ concurrent\_queue\_wait\_policy::non\_blocking,\ \textcolor{keywordtype}{int}>\ =\ 0>}
\DoxyCodeLine{00667\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_acc0043f182b8d55c7cd432047fe15179}{push\_blocking}}(U\&\&\ elem)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00668\ \ \ \{}
\DoxyCodeLine{00669\ \ \ \ \ \textcolor{keywordflow}{return}\ queue.push\_blocking(std::forward<U>(elem));}
\DoxyCodeLine{00670\ \ \ \}}
\DoxyCodeLine{00671\ }
\DoxyCodeLine{00672\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Pops\ an\ element\ from\ the\ queue\ in\ a\ non-\/blocking\ fashion.}}
\DoxyCodeLine{00673\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00674\ \ \ \textcolor{comment}{///\ If\ the\ queue\ is\ empty,\ the\ call\ returns\ false.}}
\DoxyCodeLine{00675\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_af92570524955aa703c2946900d7741b2}{try\_pop}}(T\&\ elem)\ \{\ \textcolor{keywordflow}{return}\ queue.try\_pop(elem);\ \}}
\DoxyCodeLine{00676\ }
\DoxyCodeLine{00677\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Pops\ an\ element\ from\ the\ queue\ in\ a\ non-\/blocking\ fashion.}}
\DoxyCodeLine{00678\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00679\ \ \ \textcolor{comment}{///\ If\ the\ queue\ is\ empty,\ the\ call\ returns\ an\ empty\ optional.}}
\DoxyCodeLine{00680\ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<T>\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a6d5638ee10deab90bd30105c580748b5}{try\_pop}}()}
\DoxyCodeLine{00681\ \ \ \{}
\DoxyCodeLine{00682\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<T>\ ret;}
\DoxyCodeLine{00683\ \ \ \ \ queue.try\_call\_on\_pop([\&ret](T\&\ t)\ \textcolor{keyword}{mutable}\ \{\ ret\ =\ std::move(t);\ \});}
\DoxyCodeLine{00684\ \ \ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{00685\ \ \ \}}
\DoxyCodeLine{00686\ }
\DoxyCodeLine{00687\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Pops\ an\ element\ from\ the\ queue\ and\ calls\ the\ provided\ function\ with\ the\ popped\ element.}}
\DoxyCodeLine{00688\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00689\ \ \ \textcolor{comment}{///\ If\ the\ queue\ is\ empty,\ the\ call\ returns\ false,\ and\ the\ CallOnPop\ function\ is\ not\ called.\ Otherwise,\ it\ returns}}
\DoxyCodeLine{00690\ \ \ \textcolor{comment}{///\ true.}}
\DoxyCodeLine{00691\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CallOnPop>}
\DoxyCodeLine{00692\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_ae9d56f2adcb20bf091a80a29386cce47}{try\_call\_on\_pop}}(\textcolor{keyword}{const}\ CallOnPop\&\ func)}
\DoxyCodeLine{00693\ \ \ \{}
\DoxyCodeLine{00694\ \ \ \ \ \textcolor{keywordflow}{return}\ queue.try\_call\_on\_pop(func);}
\DoxyCodeLine{00695\ \ \ \}}
\DoxyCodeLine{00696\ }
\DoxyCodeLine{00697\ \ \ \textcolor{comment}{///\ Pops\ an\ element\ from\ the\ queue.\ If\ the\ queue\ is\ empty,\ the\ call\ blocks,\ waiting\ for\ a\ new\ element\ to\ be\ pushed.}}
\DoxyCodeLine{00698\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a9fc2964f0e85797249b5531434c70935}{pop\_blocking}}(T\&\ elem)\ \{\ \textcolor{keywordflow}{return}\ queue.pop\_blocking(elem);\ \}}
\DoxyCodeLine{00699\ }
\DoxyCodeLine{00700\ \ \ \textcolor{comment}{///\ Pops\ an\ element\ from\ the\ queue.\ If\ the\ queue\ is\ empty,\ the\ call\ blocks,\ waiting\ for\ a\ new\ element\ to\ be\ pushed.}}
\DoxyCodeLine{00701\ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<T>\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a017b9f37c5a0969958ccc13f7b91912a}{pop\_blocking}}()\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00702\ \ \ \{}
\DoxyCodeLine{00703\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<T>\ ret;}
\DoxyCodeLine{00704\ \ \ \ \ queue.call\_on\_pop\_blocking([\&ret](T\&\ t)\ \textcolor{keyword}{mutable}\ \{\ ret\ =\ std::move(t);\ \});}
\DoxyCodeLine{00705\ \ \ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{00706\ \ \ \}}
\DoxyCodeLine{00707\ }
\DoxyCodeLine{00708\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Pops\ an\ element\ from\ the\ queue\ and\ calls\ the\ provided\ function\ with\ the\ popped\ element.\ If\ the\ queue\ is}}
\DoxyCodeLine{00709\ \ \ \textcolor{comment}{///\ empty,\ the\ function\ blocks,\ waiting\ for\ a\ new\ element\ to\ be\ pushed.\ It\ returns\ false\ if\ the\ queue\ is\ closed.}}
\DoxyCodeLine{00710\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CallOnPop>}
\DoxyCodeLine{00711\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a2be0a7a406714c6df59e5f1eb9cdd0fd}{call\_on\_pop\_blocking}}(\textcolor{keyword}{const}\ CallOnPop\&\ func)}
\DoxyCodeLine{00712\ \ \ \{}
\DoxyCodeLine{00713\ \ \ \ \ \textcolor{keywordflow}{return}\ queue.call\_on\_pop\_blocking(func);}
\DoxyCodeLine{00714\ \ \ \}}
\DoxyCodeLine{00715\ }
\DoxyCodeLine{00716\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Maximum\ capacity\ of\ the\ queue.}}
\DoxyCodeLine{00717\ \ \ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a566b5bcfd15d0a7918eb01571046d952}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a566b5bcfd15d0a7918eb01571046d952}{capacity}}()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue.capacity();\ \}}
\DoxyCodeLine{00718\ }
\DoxyCodeLine{00719\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Current\ size\ of\ the\ queue.}}
\DoxyCodeLine{00720\ \ \ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a0775474918ef7b6fe6720f89156afd65}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_a0775474918ef7b6fe6720f89156afd65}{size}}()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue.size();\ \}}
\DoxyCodeLine{00721\ }
\DoxyCodeLine{00722\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Determines\ whether\ the\ queue\ is\ empty.}}
\DoxyCodeLine{00723\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_ac045142931e78330202b2e62ca79fc19}{empty}}()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue.empty();\ \}}
\DoxyCodeLine{00724\ }
\DoxyCodeLine{00725\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Request\ any\ blocking\ function\ to\ be\ interrupted.}}
\DoxyCodeLine{00726\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classsrsran_1_1concurrent__queue_ae6809193cc3aa228a27b887494b5bae0}{request\_stop}}()\ \{\ queue.request\_stop();\ \}}
\DoxyCodeLine{00727\ }
\DoxyCodeLine{00728\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00729\ \ \ queue\_type\ queue;}
\DoxyCodeLine{00730\ \};}
\DoxyCodeLine{00731\ }
\DoxyCodeLine{00732\ \textcolor{comment}{///\ \(\backslash\)brief\ Queue\ priority\ used\ to\ map\ to\ specific\ queue\ of\ the\ \(\backslash\)c\ priority\_multiqueue\_task\_worker.\ The\ higher\ the}}
\DoxyCodeLine{00733\ \textcolor{comment}{///\ priority,\ the\ lower\ its\ integer\ value\ representation.}}
\DoxyCodeLine{00734\ \textcolor{keyword}{enum}\ \textcolor{keyword}{class}\ \mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ :\ \mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{size\_t}}\ \{\ min\ =\ 0,\ max\ =\ \mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{std}}::\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{numeric\_limits}}<\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{size\_t}}>::\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{max}}()\ \};}
\DoxyCodeLine{00735\ }
\DoxyCodeLine{00736\ \textcolor{comment}{///\ Reduce\ priority\ by\ \(\backslash\)c\ dec\ amount.}}
\DoxyCodeLine{00737\ \textcolor{keyword}{constexpr}\ \mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ \mbox{\hyperlink{namespacesrsran_a5c5da89d37e0fc237d6dd40498cb5c39}{operator}}-\/(\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ lhs,\ size\_t\ dec)}
\DoxyCodeLine{00738\ \{}
\DoxyCodeLine{00739\ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast}<enqueue\_priority>(\textcolor{keyword}{static\_cast}<size\_t>(lhs)\ -\/\ dec);}
\DoxyCodeLine{00740\ \}}
\DoxyCodeLine{00741\ }
\DoxyCodeLine{00742\ \textcolor{keyword}{namespace}\ detail\ \{}
\DoxyCodeLine{00743\ }
\DoxyCodeLine{00744\ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ size\_t\ enqueue\_priority\_to\_queue\_index(enqueue\_priority\ prio,\ size\_t\ nof\_priority\_levels)}
\DoxyCodeLine{00745\ \{}
\DoxyCodeLine{00746\ \ \ \textcolor{keywordflow}{if}\ (nof\_priority\_levels\ ==\ 0)\ \{}
\DoxyCodeLine{00747\ \ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{00748\ \ \ \}}
\DoxyCodeLine{00749\ \ \ size\_t\ queue\_idx\ =\ std::numeric\_limits<size\_t>::max()\ -\/\ \textcolor{keyword}{static\_cast}<size\_t>(prio);}
\DoxyCodeLine{00750\ \ \ \textcolor{keywordflow}{return}\ queue\_idx\ <\ nof\_priority\_levels\ ?\ queue\_idx\ :\ nof\_priority\_levels\ -\/\ 1;}
\DoxyCodeLine{00751\ \}}
\DoxyCodeLine{00752\ }
\DoxyCodeLine{00753\ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ \mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ queue\_index\_to\_enqueue\_priority(size\_t\ queue\_idx,\ size\_t\ nof\_priority\_levels)}
\DoxyCodeLine{00754\ \{}
\DoxyCodeLine{00755\ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast}<enqueue\_priority>(std::numeric\_limits<size\_t>::max()\ -\/\ queue\_idx);}
\DoxyCodeLine{00756\ \}}
\DoxyCodeLine{00757\ }
\DoxyCodeLine{00758\ \textcolor{keyword}{class}\ \mbox{\hyperlink{classsrsran_1_1detail_1_1concurrent__priority__queue__wait__policy}{concurrent\_priority\_queue\_wait\_policy}}}
\DoxyCodeLine{00759\ \{}
\DoxyCodeLine{00760\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00761\ \ \ \textcolor{keyword}{explicit}\ concurrent\_priority\_queue\_wait\_policy(std::chrono::microseconds\ spin\_on\_wait\_interval)\ :}
\DoxyCodeLine{00762\ \ \ \ \ wait\_interval(spin\_on\_wait\_interval)}
\DoxyCodeLine{00763\ \ \ \{}
\DoxyCodeLine{00764\ \ \ \}}
\DoxyCodeLine{00765\ }
\DoxyCodeLine{00766\ \ \ \textcolor{keywordtype}{void}\ request\_stop()\ \{\ running\ =\ \textcolor{keyword}{false};\ \}}
\DoxyCodeLine{00767\ }
\DoxyCodeLine{00768\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Func>}
\DoxyCodeLine{00769\ \ \ \textcolor{keywordtype}{bool}\ run\_until(Func\&\&\ func)}
\DoxyCodeLine{00770\ \ \ \{}
\DoxyCodeLine{00771\ \ \ \ \ \textcolor{keywordflow}{while}\ (running.load(std::memory\_order\_relaxed))\ \{}
\DoxyCodeLine{00772\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (func())\ \{}
\DoxyCodeLine{00773\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00774\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00775\ \ \ \ \ \ \ std::this\_thread::sleep\_for(wait\_interval);}
\DoxyCodeLine{00776\ \ \ \ \ \}}
\DoxyCodeLine{00777\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00778\ \ \ \}}
\DoxyCodeLine{00779\ }
\DoxyCodeLine{00780\ \textcolor{keyword}{protected}:}
\DoxyCodeLine{00781\ \ \ \textcolor{comment}{//\ Time\ that\ thread\ spends\ sleeping\ when\ there\ are\ no\ pending\ tasks.}}
\DoxyCodeLine{00782\ \ \ \textcolor{keyword}{const}\ std::chrono::microseconds\ wait\_interval;}
\DoxyCodeLine{00783\ }
\DoxyCodeLine{00784\ \ \ std::atomic<\textcolor{keywordtype}{bool}>\ running\{\textcolor{keyword}{true}\};}
\DoxyCodeLine{00785\ \};}
\DoxyCodeLine{00786\ }
\DoxyCodeLine{00787\ \}\ \textcolor{comment}{//\ namespace\ detail}}
\DoxyCodeLine{00788\ }
\DoxyCodeLine{00789\ \textcolor{comment}{///\ \(\backslash\)brief\ Static\ interface\ used\ to\ push\ elements\ to\ a\ \(\backslash\)c\ concurrent\_queue.}}
\DoxyCodeLine{00790\ \textcolor{comment}{///\ \(\backslash\)tparam\ T\ type\ of\ element\ pushed.}}
\DoxyCodeLine{00791\ \textcolor{comment}{///\ \(\backslash\)tparam\ QueuePolicy\ Queue\ policy\ used\ to\ push\ the\ element.}}
\DoxyCodeLine{00792\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}\ QueuePolicy>}
\DoxyCodeLine{00793\ \textcolor{keyword}{class}\ \mbox{\hyperlink{classsrsran_1_1non__blocking__enqueuer}{non\_blocking\_enqueuer}}}
\DoxyCodeLine{00794\ \{}
\DoxyCodeLine{00795\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00796\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{static}\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}\ queue\_policy\ =\ QueuePolicy;}
\DoxyCodeLine{00797\ }
\DoxyCodeLine{00798\ \ \ non\_blocking\_enqueuer(\mbox{\hyperlink{classsrsran_1_1concurrent__queue}{concurrent\_queue}}<T,\ QueuePolicy,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>\&\ q\_)\ :\ queue(\&q\_)}
\DoxyCodeLine{00799\ \ \ \{}
\DoxyCodeLine{00800\ \ \ \}}
\DoxyCodeLine{00801\ }
\DoxyCodeLine{00802\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Push\ new\ object\ with\ priority\ level\ \(\backslash\)c\ Priority\ in\ a\ non-\/blocking\ fashion.}}
\DoxyCodeLine{00803\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00804\ \ \ \mbox{\hyperlink{compiler_8h_a84270d7b45f0280051bd27685657e03e}{SRSRAN\_NODISCARD}}\ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1non__blocking__enqueuer_aab86fbe61e16e5447bbdd6580adfbdc8}{try\_push}}(U\&\&\ u)}
\DoxyCodeLine{00805\ \ \ \{}
\DoxyCodeLine{00806\ \ \ \ \ \textcolor{keywordflow}{return}\ queue-\/>try\_push(std::forward<U>(u));}
\DoxyCodeLine{00807\ \ \ \}}
\DoxyCodeLine{00808\ }
\DoxyCodeLine{00809\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Maximum\ capacity\ of\ the\ queue.}}
\DoxyCodeLine{00810\ \ \ \mbox{\hyperlink{classsrsran_1_1non__blocking__enqueuer_ac2015567089356c0a3cd5d2c12bed89b}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1non__blocking__enqueuer_ac2015567089356c0a3cd5d2c12bed89b}{capacity}}()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ queue-\/>capacity();\ \}}
\DoxyCodeLine{00811\ }
\DoxyCodeLine{00812\ \textcolor{keyword}{protected}:}
\DoxyCodeLine{00813\ \ \ \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{concurrent\_queue}}<T,\ QueuePolicy,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>*\ queue;}
\DoxyCodeLine{00814\ \};}
\DoxyCodeLine{00815\ }
\DoxyCodeLine{00816\ \textcolor{comment}{///\ \(\backslash\)brief\ Static\ interface\ used\ to\ push\ elements\ to\ a\ \(\backslash\)c\ concurrent\_queue\ both\ in\ a\ blocking\ or\ non-\/blocking\ fashion.}}
\DoxyCodeLine{00817\ \textcolor{comment}{///\ \(\backslash\)tparam\ T\ type\ of\ element\ pushed.}}
\DoxyCodeLine{00818\ \textcolor{comment}{///\ \(\backslash\)tparam\ QueuePolicy\ Queue\ policy\ used\ to\ push\ the\ element.}}
\DoxyCodeLine{00819\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}\ QueuePolicy>}
\DoxyCodeLine{00820\ \textcolor{keyword}{class}\ \mbox{\hyperlink{classsrsran_1_1priority__enqueuer}{priority\_enqueuer}}\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classsrsran_1_1non__blocking__enqueuer}{non\_blocking\_enqueuer}}<T,\ QueuePolicy>}
\DoxyCodeLine{00821\ \{}
\DoxyCodeLine{00822\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00823\ \ \ priority\_enqueuer(detail::\mbox{\hyperlink{classsrsran_1_1detail_1_1concurrent__priority__queue__wait__policy}{concurrent\_priority\_queue\_wait\_policy}}\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ wait\_policy\_,}
\DoxyCodeLine{00824\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{concurrent\_queue}}<T,\ QueuePolicy,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>\&\ q\_)\ :}
\DoxyCodeLine{00825\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1non__blocking__enqueuer}{non\_blocking\_enqueuer}}<T,\ QueuePolicy>(q\_),\ wait\_policy(\&wait\_policy\_)}
\DoxyCodeLine{00826\ \ \ \{}
\DoxyCodeLine{00827\ \ \ \}}
\DoxyCodeLine{00828\ }
\DoxyCodeLine{00829\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Push\ new\ object\ with\ priority\ level\ \(\backslash\)c\ Priority.}}
\DoxyCodeLine{00830\ \ \ \textcolor{keyword}{template}\ <\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ Priority,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00831\ \ \ \mbox{\hyperlink{compiler_8h_a84270d7b45f0280051bd27685657e03e}{SRSRAN\_NODISCARD}}\ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1priority__enqueuer_ab589e6a89bb0ba9522e663222340f423}{push\_blocking}}(U\&\&\ u)}
\DoxyCodeLine{00832\ \ \ \{}
\DoxyCodeLine{00833\ \ \ \ \ \textcolor{keywordflow}{return}\ wait\_policy-\/>run\_until([\textcolor{keyword}{this},\ \&u]()\ \textcolor{keyword}{mutable}\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{this}-\/>queue-\/>try\_push(std::forward<U>(u));\ \});}
\DoxyCodeLine{00834\ \ \ \}}
\DoxyCodeLine{00835\ }
\DoxyCodeLine{00836\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00837\ \ \ detail::\mbox{\hyperlink{classsrsran_1_1detail_1_1concurrent__priority__queue__wait__policy}{concurrent\_priority\_queue\_wait\_policy}}*\ wait\_policy;}
\DoxyCodeLine{00838\ \};}
\DoxyCodeLine{00839\ }
\DoxyCodeLine{00840\ \textcolor{comment}{///\ \(\backslash\)brief\ Gets\ the\ queue\ policy\ for\ a\ given\ priority.}}
\DoxyCodeLine{00841\ \textcolor{keyword}{template}\ <\mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}...\ QueuePolicies>}
\DoxyCodeLine{00842\ \textcolor{keyword}{constexpr}\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}\ \mbox{\hyperlink{namespacesrsran_a0b00ef08221ac8cbecd213e5864d72e2}{get\_priority\_queue\_policy}}(\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ Priority)}
\DoxyCodeLine{00843\ \{}
\DoxyCodeLine{00844\ \ \ \textcolor{keyword}{constexpr}\ std::array<\mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}},\ \textcolor{keyword}{sizeof}...(QueuePolicies)>\ policies\{QueuePolicies...\};}
\DoxyCodeLine{00845\ \ \ \textcolor{keywordflow}{return}\ policies[detail::enqueue\_priority\_to\_queue\_index(Priority,\ \textcolor{keyword}{sizeof}...(QueuePolicies))];}
\DoxyCodeLine{00846\ \}}
\DoxyCodeLine{00847\ }
\DoxyCodeLine{00848\ \textcolor{comment}{///\ \(\backslash\)brief\ Concurrent\ priority\ queue,\ where\ the\ caller\ specifies\ the\ element\ priority\ statically\ while\ pushing\ it\ to}}
\DoxyCodeLine{00849\ \textcolor{comment}{///\ the\ queue.}}
\DoxyCodeLine{00850\ \textcolor{comment}{///}}
\DoxyCodeLine{00851\ \textcolor{comment}{///\ The\ prioritization\ is\ achieved\ via\ multiple\ queues.\ The\ pop\ functions\ will\ always\ start\ with\ the\ highest\ priority}}
\DoxyCodeLine{00852\ \textcolor{comment}{///\ queue\ until\ it\ is\ depleted,\ and\ then\ move\ to\ the\ second\ highest\ priority\ queue,\ and\ so\ on.}}
\DoxyCodeLine{00853\ \textcolor{comment}{///\ \(\backslash\)tparam\ T\ The\ type\ of\ the\ pushed/popped\ object.}}
\DoxyCodeLine{00854\ \textcolor{comment}{///\ \(\backslash\)tparam\ QueuePolicies\ The\ queueing\ policies\ of\ each\ of\ the\ queues\ of\ different\ priorities.}}
\DoxyCodeLine{00855\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\_queue\_policy}}...\ QueuePolicies>}
\DoxyCodeLine{00856\ \textcolor{keyword}{class}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue}{concurrent\_priority\_queue}}}
\DoxyCodeLine{00857\ \{}
\DoxyCodeLine{00858\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00859\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Construct\ a\ new\ prioritized\ queue.}}
\DoxyCodeLine{00860\ \ \ \textcolor{comment}{///\ \(\backslash\)param\ task\_queue\_sizes\ The\ sizes\ of\ the\ task\ queues\ for\ each\ priority\ level.}}
\DoxyCodeLine{00861\ \ \ \textcolor{comment}{///\ \(\backslash\)param\ wait\_interval\ The\ amount\ of\ time\ to\ suspend\ the\ thread,\ when\ no\ tasks\ are\ pending.}}
\DoxyCodeLine{00862\ \ \ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_a319dc052024f708e0894f9deea628f92}{concurrent\_priority\_queue}}(\textcolor{keyword}{const}\ std::array<\textcolor{keywordtype}{unsigned},\ \textcolor{keyword}{sizeof}...(QueuePolicies)>\&\ priority\_queue\_sizes,}
\DoxyCodeLine{00863\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::chrono::microseconds\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ wait\_interval\_)\ :}
\DoxyCodeLine{00864\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_a319dc052024f708e0894f9deea628f92}{wait\_policy}}(\mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_a319dc052024f708e0894f9deea628f92}{wait\_interval\_}}),\ queues(detail::as\_tuple(priority\_queue\_sizes))}
\DoxyCodeLine{00865\ \ \ \{}
\DoxyCodeLine{00866\ \ \ \}}
\DoxyCodeLine{00867\ }
\DoxyCodeLine{00868\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Push\ new\ object\ with\ priority\ level\ \(\backslash\)c\ Priority.}}
\DoxyCodeLine{00869\ \ \ \textcolor{keyword}{template}\ <\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ Priority,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00870\ \ \ \mbox{\hyperlink{compiler_8h_a84270d7b45f0280051bd27685657e03e}{SRSRAN\_NODISCARD}}\ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_ad81139cc42bc1457fa4eb189506c7b80}{try\_push}}(U\&\&\ u)}
\DoxyCodeLine{00871\ \ \ \{}
\DoxyCodeLine{00872\ \ \ \ \ \textcolor{keyword}{auto}\&\ q\ =\ std::get<detail::enqueue\_priority\_to\_queue\_index(Priority,\ nof\_priority\_levels())>(queues);}
\DoxyCodeLine{00873\ \ \ \ \ \textcolor{keywordflow}{return}\ q.try\_push(std::forward<U>(u));}
\DoxyCodeLine{00874\ \ \ \}}
\DoxyCodeLine{00875\ }
\DoxyCodeLine{00876\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Push\ new\ object\ with\ priority\ level\ \(\backslash\)c\ Priority.}}
\DoxyCodeLine{00877\ \ \ \textcolor{keyword}{template}\ <\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ Priority,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00878\ \ \ \mbox{\hyperlink{compiler_8h_a84270d7b45f0280051bd27685657e03e}{SRSRAN\_NODISCARD}}\ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_aac6011abf9bd0e73258b1ffa7f434c53}{push\_blocking}}(U\&\&\ u)}
\DoxyCodeLine{00879\ \ \ \{}
\DoxyCodeLine{00880\ \ \ \ \ \textcolor{keyword}{auto}\&\ q\ =\ std::get<detail::enqueue\_priority\_to\_queue\_index(Priority,\ nof\_priority\_levels())>(queues);}
\DoxyCodeLine{00881\ \ \ \ \ \textcolor{keywordflow}{return}\ wait\_policy.run\_until([\&q,\ \&u]()\ \textcolor{keyword}{mutable}\ \{\ \textcolor{keywordflow}{return}\ q.try\_push(std::forward<U>(u));\ \});}
\DoxyCodeLine{00882\ \ \ \}}
\DoxyCodeLine{00883\ }
\DoxyCodeLine{00884\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Pop\ object\ from\ queue,\ by\ starting\ first\ with\ the\ objects\ with\ highest\ priority.}}
\DoxyCodeLine{00885\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_a4b0e40347a8f96f4497ba7722ce3a3f3}{try\_pop}}(T\&\ elem)}
\DoxyCodeLine{00886\ \ \ \{}
\DoxyCodeLine{00887\ \ \ \ \ \textcolor{keywordflow}{return}\ detail::any\_of(queues,\ [\&elem](\textcolor{keyword}{auto}\&\ queue)\ \textcolor{keyword}{mutable}\ \{\ \textcolor{keywordflow}{return}\ queue.try\_pop(elem);\ \});}
\DoxyCodeLine{00888\ \ \ \}}
\DoxyCodeLine{00889\ }
\DoxyCodeLine{00890\ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<T>\ try\_pop()}
\DoxyCodeLine{00891\ \ \ \{}
\DoxyCodeLine{00892\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<T>\ elem;}
\DoxyCodeLine{00893\ \ \ \ \ detail::any\_of(queues,\ [\&elem](\textcolor{keyword}{auto}\&\ queue)\ \textcolor{keyword}{mutable}\ \{}
\DoxyCodeLine{00894\ \ \ \ \ \ \ elem\ =\ queue.try\_pop();}
\DoxyCodeLine{00895\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ elem.has\_value();}
\DoxyCodeLine{00896\ \ \ \ \ \});}
\DoxyCodeLine{00897\ \ \ \ \ \textcolor{keywordflow}{return}\ elem;}
\DoxyCodeLine{00898\ \ \ \}}
\DoxyCodeLine{00899\ }
\DoxyCodeLine{00900\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Call\ function\ on\ object\ popped\ from\ the\ queue.}}
\DoxyCodeLine{00901\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CallOnPop>}
\DoxyCodeLine{00902\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_ab6010e2986638d72d779f30db121ffdb}{try\_call\_on\_pop}}(\textcolor{keyword}{const}\ CallOnPop\&\ func)}
\DoxyCodeLine{00903\ \ \ \{}
\DoxyCodeLine{00904\ \ \ \ \ \textcolor{keywordflow}{return}\ detail::any\_of(queues,\ [\&func](\textcolor{keyword}{auto}\&\ queue)\ \textcolor{keyword}{mutable}\ \{\ \textcolor{keywordflow}{return}\ queue.try\_call\_on\_pop(func);\ \});}
\DoxyCodeLine{00905\ \ \ \}}
\DoxyCodeLine{00906\ }
\DoxyCodeLine{00907\ \ \ \textcolor{keywordtype}{bool}\ pop\_blocking(T\&\ elem)}
\DoxyCodeLine{00908\ \ \ \{}
\DoxyCodeLine{00909\ \ \ \ \ \textcolor{keywordflow}{return}\ wait\_policy.run\_until([\textcolor{keyword}{this},\ \&elem]()\ \{\ \textcolor{keywordflow}{return}\ try\_pop(elem);\ \});}
\DoxyCodeLine{00910\ \ \ \}}
\DoxyCodeLine{00911\ }
\DoxyCodeLine{00912\ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<T>\ pop\_blocking()}
\DoxyCodeLine{00913\ \ \ \{}
\DoxyCodeLine{00914\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<T>\ t;}
\DoxyCodeLine{00915\ \ \ \ \ wait\_policy.run\_until([\textcolor{keyword}{this},\ \&t]()\ \{}
\DoxyCodeLine{00916\ \ \ \ \ \ \ t\ =\ try\_pop();}
\DoxyCodeLine{00917\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ t.has\_value();}
\DoxyCodeLine{00918\ \ \ \ \ \});}
\DoxyCodeLine{00919\ \ \ \ \ \textcolor{keywordflow}{return}\ t;}
\DoxyCodeLine{00920\ \ \ \}}
\DoxyCodeLine{00921\ }
\DoxyCodeLine{00922\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CallOnPop>}
\DoxyCodeLine{00923\ \ \ \textcolor{keywordtype}{bool}\ call\_on\_pop\_blocking(\textcolor{keyword}{const}\ CallOnPop\&\ func)}
\DoxyCodeLine{00924\ \ \ \{}
\DoxyCodeLine{00925\ \ \ \ \ \textcolor{keywordflow}{return}\ wait\_policy.run\_until([\textcolor{keyword}{this},\ \&func]()\ \{\ \textcolor{keywordflow}{return}\ try\_call\_on\_pop(func);\ \});}
\DoxyCodeLine{00926\ \ \ \}}
\DoxyCodeLine{00927\ }
\DoxyCodeLine{00928\ \ \ \textcolor{keywordtype}{void}\ request\_stop()\ \{\ wait\_policy.request\_stop();\ \}}
\DoxyCodeLine{00929\ }
\DoxyCodeLine{00930\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Get\ specified\ priority\ queue\ capacity.}}
\DoxyCodeLine{00931\ \ \ \textcolor{keyword}{template}\ <\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ Priority>}
\DoxyCodeLine{00932\ \ \ \mbox{\hyperlink{compiler_8h_a84270d7b45f0280051bd27685657e03e}{SRSRAN\_NODISCARD}}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_a21de760837df848f3dc564394017ef46}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_a21de760837df848f3dc564394017ef46}{capacity}}()\ \textcolor{keyword}{const}}
\DoxyCodeLine{00933\ \ \ \{}
\DoxyCodeLine{00934\ \ \ \ \ \textcolor{keywordflow}{return}\ std::get<detail::enqueue\_priority\_to\_queue\_index(Priority,\ nof\_priority\_levels())>(queues).capacity();}
\DoxyCodeLine{00935\ \ \ \}}
\DoxyCodeLine{00936\ }
\DoxyCodeLine{00937\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Get\ specified\ priority\ queue\ size.}}
\DoxyCodeLine{00938\ \ \ \textcolor{keyword}{template}\ <\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ Priority>}
\DoxyCodeLine{00939\ \ \ \mbox{\hyperlink{compiler_8h_a84270d7b45f0280051bd27685657e03e}{SRSRAN\_NODISCARD}}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_a09451f354de16661999cbe8160da6da4}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_a09451f354de16661999cbe8160da6da4}{size}}()\ \textcolor{keyword}{const}}
\DoxyCodeLine{00940\ \ \ \{}
\DoxyCodeLine{00941\ \ \ \ \ \textcolor{keywordflow}{return}\ std::get<detail::enqueue\_priority\_to\_queue\_index(Priority,\ nof\_priority\_levels())>(queues).size();}
\DoxyCodeLine{00942\ \ \ \}}
\DoxyCodeLine{00943\ }
\DoxyCodeLine{00944\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Get\ sum\ of\ all\ queue\ sizes.}}
\DoxyCodeLine{00945\ \ \ \mbox{\hyperlink{compiler_8h_a84270d7b45f0280051bd27685657e03e}{SRSRAN\_NODISCARD}}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_acf28c6173fe7954ecc9706d3ba0de436}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_acf28c6173fe7954ecc9706d3ba0de436}{size}}()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{this}-\/>size\_sum(std::make\_index\_sequence<\textcolor{keyword}{sizeof}...(QueuePolicies)>\{\});\ \}}
\DoxyCodeLine{00946\ }
\DoxyCodeLine{00947\ \ \ \textcolor{comment}{///\ Number\ of\ priority\ levels\ supported\ by\ this\ queue.}}
\DoxyCodeLine{00948\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_aeb032432063bfcde4cdca9ee4e290b8e}{size\_t}}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_aeb032432063bfcde4cdca9ee4e290b8e}{nof\_priority\_levels}}()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{sizeof}...(QueuePolicies);\ \}}
\DoxyCodeLine{00949\ }
\DoxyCodeLine{00950\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Gets\ the\ enqueue\ point\ for\ a\ given\ priority.}}
\DoxyCodeLine{00951\ \ \ \textcolor{keyword}{template}\ <\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ Priority>}
\DoxyCodeLine{00952\ \ \ \textcolor{keyword}{auto}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_a4a7455cd46919d5e5466bd1e5cd51e43}{get\_enqueuer}}()}
\DoxyCodeLine{00953\ \ \ \{}
\DoxyCodeLine{00954\ \ \ \ \ \textcolor{keyword}{auto}\&\ q\ =\ std::get<detail::enqueue\_priority\_to\_queue\_index(Priority,\ nof\_priority\_levels())>(queues);}
\DoxyCodeLine{00955\ \ \ \ \ \textcolor{keywordflow}{return}\ priority\_enqueuer<T,\ get\_priority\_queue\_policy<QueuePolicies...>(Priority)>\{wait\_policy,\ q\};}
\DoxyCodeLine{00956\ \ \ \}}
\DoxyCodeLine{00957\ }
\DoxyCodeLine{00958\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Gets\ the\ non-\/blocking\ enqueue\ point\ for\ a\ given\ priority.}}
\DoxyCodeLine{00959\ \ \ \textcolor{keyword}{template}\ <\mbox{\hyperlink{namespacesrsran_a8773a5775c48bb0867347e2791c954d5}{enqueue\_priority}}\ Priority>}
\DoxyCodeLine{00960\ \ \ \textcolor{keyword}{auto}\ \mbox{\hyperlink{classsrsran_1_1concurrent__priority__queue_aab29e3c076647e15a68ccb3251fd98bc}{get\_non\_blocking\_enqueuer}}()}
\DoxyCodeLine{00961\ \ \ \{}
\DoxyCodeLine{00962\ \ \ \ \ \textcolor{keyword}{auto}\&\ q\ =\ std::get<detail::enqueue\_priority\_to\_queue\_index(Priority,\ nof\_priority\_levels())>(queues);}
\DoxyCodeLine{00963\ \ \ \ \ \textcolor{keywordflow}{return}\ non\_blocking\_enqueuer<T,\ get\_priority\_queue\_policy<QueuePolicies...>(Priority)>\{q\};}
\DoxyCodeLine{00964\ \ \ \}}
\DoxyCodeLine{00965\ }
\DoxyCodeLine{00966\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00967\ \ \ \textcolor{keyword}{template}\ <size\_t...\ I>}
\DoxyCodeLine{00968\ \ \ size\_t\ size\_sum(std::index\_sequence<I...>\ \textcolor{comment}{/*unused*/})\ \textcolor{keyword}{const}}
\DoxyCodeLine{00969\ \ \ \{}
\DoxyCodeLine{00970\ \ \ \ \ std::array<size\_t,\ \textcolor{keyword}{sizeof}...(I)>\ a\{std::get<I>(queues).size()...\};}
\DoxyCodeLine{00971\ \ \ \ \ size\_t\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sz\ =\ 0;}
\DoxyCodeLine{00972\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{unsigned}\ v\ :\ a)\ \{}
\DoxyCodeLine{00973\ \ \ \ \ \ \ sz\ +=\ v;}
\DoxyCodeLine{00974\ \ \ \ \ \}}
\DoxyCodeLine{00975\ \ \ \ \ \textcolor{keywordflow}{return}\ sz;}
\DoxyCodeLine{00976\ \ \ \}}
\DoxyCodeLine{00977\ }
\DoxyCodeLine{00978\ \ \ \textcolor{comment}{//\ Time\ that\ thread\ spends\ sleeping\ when\ there\ are\ no\ pending\ tasks.}}
\DoxyCodeLine{00979\ \ \ detail::\mbox{\hyperlink{classsrsran_1_1detail_1_1concurrent__priority__queue__wait__policy}{concurrent\_priority\_queue\_wait\_policy}}\ wait\_policy;}
\DoxyCodeLine{00980\ }
\DoxyCodeLine{00981\ \ \ std::tuple<\mbox{\hyperlink{classsrsran_1_1concurrent__queue}{concurrent\_queue}}<T,\ QueuePolicies,\ \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\_queue\_wait\_policy}}::non\_blocking>...>\ queues;}
\DoxyCodeLine{00982\ \};}
\DoxyCodeLine{00983\ }
\DoxyCodeLine{00984\ \}\ \textcolor{comment}{//\ namespace\ srsran}}

\end{DoxyCode}
