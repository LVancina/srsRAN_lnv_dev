\doxysection{lib/ofh/compression/avx2\+\_\+helpers.h File Reference}
\hypertarget{ofh_2compression_2avx2__helpers_8h}{}\label{ofh_2compression_2avx2__helpers_8h}\index{lib/ofh/compression/avx2\_helpers.h@{lib/ofh/compression/avx2\_helpers.h}}


AVX2 support for OFH Compression algorithms.  


{\ttfamily \#include "{}srsran/adt/span.\+h"{}}\newline
{\ttfamily \#include $<$immintrin.\+h$>$}\newline
Include dependency graph for avx2\+\_\+helpers.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dd/d05/ofh_2compression_2avx2__helpers_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=197pt]{d3/d4b/ofh_2compression_2avx2__helpers_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespacesrsran}{srsran}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{ofh_2compression_2avx2__helpers_8h_a5a1f0973b49fa5684529c68848df1b76}\label{ofh_2compression_2avx2__helpers_8h_a5a1f0973b49fa5684529c68848df1b76} 
\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{using}} {\bfseries srsran\+::ofh\+::mm256\+::\+\_\+mm256\+\_\+comparator} = \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}} (\texorpdfstring{$\ast$}{*})(\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}} a, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}} b)
\begin{DoxyCompactList}\small\item\em Type of AVX2 intrinsic calculating min or max values between two vectors. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$\mbox{\hyperlink{ofh_2compression_2avx2__helpers_8h_a5a1f0973b49fa5684529c68848df1b76}{\+\_\+mm256\+\_\+comparator}} COMPARE$>$ }\\\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{void}} \mbox{\hyperlink{ofh_2compression_2avx2__helpers_8h_a3680c47c967c06fbff65a00ac3ac5e0a}{srsran\+::ofh\+::mm256\+::find\+\_\+rbs\+\_\+abs\+\_\+min\+\_\+max\+\_\+values}} (\mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ uint16\+\_\+t $>$ abs, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{v0\+\_\+epi16}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{v1\+\_\+epi16}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{v2\+\_\+epi16}})
\begin{DoxyCompactList}\small\item\em Finds the maximum (or minimum) 16bit sample in each of the two input resource blocks, returns its absolute value. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{void}} \mbox{\hyperlink{ofh_2compression_2avx2__helpers_8h_a1877ae3f8653c849ee2f0ba6708d79be}{srsran\+::ofh\+::mm256\+::calculate\+\_\+max\+\_\+abs}} (\mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ \mbox{\hyperlink{classunsigned}{unsigned}} $>$ \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{max\+\_\+abs}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{rb0\+\_\+epi16}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{rb01\+\_\+epi16}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{rb1\+\_\+epi16}})
\begin{DoxyCompactList}\small\item\em Finds maximum absolute value across 16bit IQ samples in each of the two input resource blocks passed in three AVX2 registers. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
AVX2 support for OFH Compression algorithms. 



\doxysubsection{Function Documentation}
\Hypertarget{ofh_2compression_2avx2__helpers_8h_a1877ae3f8653c849ee2f0ba6708d79be}\label{ofh_2compression_2avx2__helpers_8h_a1877ae3f8653c849ee2f0ba6708d79be} 
\index{avx2\_helpers.h@{avx2\_helpers.h}!calculate\_max\_abs@{calculate\_max\_abs}}
\index{calculate\_max\_abs@{calculate\_max\_abs}!avx2\_helpers.h@{avx2\_helpers.h}}
\doxysubsubsection{\texorpdfstring{calculate\_max\_abs()}{calculate\_max\_abs()}}
{\footnotesize\ttfamily void srsran\+::ofh\+::mm256\+::calculate\+\_\+max\+\_\+abs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ \mbox{\hyperlink{classunsigned}{unsigned}} $>$}]{max\+\_\+abs,  }\item[{\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}}}]{rb0\+\_\+epi16,  }\item[{\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}}}]{rb01\+\_\+epi16,  }\item[{\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}}}]{rb1\+\_\+epi16 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Finds maximum absolute value across 16bit IQ samples in each of the two input resource blocks passed in three AVX2 registers. 

The content of the three input AVX2 registers is represented in the table below. Here RBx means one unique RE (pair of IQ samples, 32 bits long) pertaining to a respective RB\+: \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }\\\cline{1-5}
\endhead
{\ttfamily rb0\+\_\+epi16\+:}   &RB0 RB0   &RB0 RB0   &RB0 RB0   &RB0 RB0    \\\cline{1-5}
{\ttfamily rb01\+\_\+epi16\+:}   &RB0 RB0   &RB0 RB0   &RB1 RB1   &RB1 RB1    \\\cline{1-5}
{\ttfamily rb1\+\_\+epi16\+:}   &RB1 RB1   &RB1 RB1   &RB1 RB1   &RB1 RB1   \\\cline{1-5}
\end{longtabu}



\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em max\+\_\+abs} & A span of two maximum absolute values in the two input RBs. \\
\hline
\mbox{\texttt{ in}}  & {\em rb0\+\_\+epi16} & AVX2 register storing 16bit IQ pairs of the first RB. \\
\hline
\mbox{\texttt{ in}}  & {\em rb01\+\_\+epi16} & AVX2 register storing 16bit IQ pairs of the first and second RBs. \\
\hline
\mbox{\texttt{ in}}  & {\em rb1\+\_\+epi16} & AVX2 register storing 16bit IQ pairs of the second RB. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00104\ \{}
\DoxyCodeLine{00105\ \ \ std::array<uint16\_t,\ 2>\ abs\_min\_values;}
\DoxyCodeLine{00106\ \ \ std::array<uint16\_t,\ 2>\ abs\_max\_values;}
\DoxyCodeLine{00107\ }
\DoxyCodeLine{00108\ \ \ \textcolor{comment}{//\ Reorganize\ vectors\ to\ be\ able\ to\ vertically\ compare\ 16bit\ samples\ pertaining\ to\ the\ same\ resource\ block:}}
\DoxyCodeLine{00109\ \ \ \textcolor{comment}{//\ [\ RB0\ RB0\ |\ RB0\ RB0\ |\ RB1\ RB1\ |\ RB1\ RB1\ ]}}
\DoxyCodeLine{00110\ \ \ \textcolor{comment}{//\ [\ RB0\ RB0\ |\ RB0\ RB0\ |\ RB1\ RB1\ |\ RB1\ RB1\ ]}}
\DoxyCodeLine{00111\ \ \ \textcolor{comment}{//\ [\ RB0\ RB0\ |\ RB0\ RB0\ |\ RB1\ RB1\ |\ RB1\ RB1\ ]}}
\DoxyCodeLine{00112\ \ \ \_\_m256i\ v0\_epi16\ =\ \_mm256\_permute2f128\_si256(rb0\_epi16,\ rb1\_epi16,\ 0x20);}
\DoxyCodeLine{00113\ \ \ \_\_m256i\ v2\_epi16\ =\ \_mm256\_permute2f128\_si256(rb0\_epi16,\ rb1\_epi16,\ 0x31);}
\DoxyCodeLine{00114\ \ \ \_\_m256i\ v1\_epi16\ =\ rb01\_epi16;}
\DoxyCodeLine{00115\ }
\DoxyCodeLine{00116\ \ \ find\_rbs\_abs\_min\_max\_values<\_mm256\_min\_epi16>(abs\_min\_values,\ v0\_epi16,\ v1\_epi16,\ v2\_epi16);}
\DoxyCodeLine{00117\ \ \ find\_rbs\_abs\_min\_max\_values<\_mm256\_max\_epi16>(abs\_max\_values,\ v0\_epi16,\ v1\_epi16,\ v2\_epi16);}
\DoxyCodeLine{00118\ }
\DoxyCodeLine{00119\ \ \ max\_abs[0]\ =\ std::max<unsigned>(abs\_max\_values[0],\ abs\_min\_values[0]\ -\/\ 1U);}
\DoxyCodeLine{00120\ \ \ max\_abs[1]\ =\ std::max<unsigned>(abs\_max\_values[1],\ abs\_min\_values[1]\ -\/\ 1U);}
\DoxyCodeLine{00121\ \}}

\end{DoxyCode}
\Hypertarget{ofh_2compression_2avx2__helpers_8h_a3680c47c967c06fbff65a00ac3ac5e0a}\label{ofh_2compression_2avx2__helpers_8h_a3680c47c967c06fbff65a00ac3ac5e0a} 
\index{avx2\_helpers.h@{avx2\_helpers.h}!find\_rbs\_abs\_min\_max\_values@{find\_rbs\_abs\_min\_max\_values}}
\index{find\_rbs\_abs\_min\_max\_values@{find\_rbs\_abs\_min\_max\_values}!avx2\_helpers.h@{avx2\_helpers.h}}
\doxysubsubsection{\texorpdfstring{find\_rbs\_abs\_min\_max\_values()}{find\_rbs\_abs\_min\_max\_values()}}
{\footnotesize\ttfamily template$<$\+\_\+mm256\+\_\+comparator COMPARE$>$ \\
void srsran\+::ofh\+::mm256\+::find\+\_\+rbs\+\_\+abs\+\_\+min\+\_\+max\+\_\+values (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ uint16\+\_\+t $>$}]{abs,  }\item[{\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}}}]{v0\+\_\+epi16,  }\item[{\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}}}]{v1\+\_\+epi16,  }\item[{\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{\+\_\+\+\_\+m256i}}}]{v2\+\_\+epi16 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Finds the maximum (or minimum) 16bit sample in each of the two input resource blocks, returns its absolute value. 

Finds absolute maximum (or minimum, depending on the comparator passed as the template argument) values for each of the two RBs passed in a three AVX2 registers.

Registers are evenly divided between two RBs so that IQ samples of each RB occupy one 128bit lane. The following diagram shows the input format. Here RBx stands for one unique RE (a pair of IQ samples, 32 bits long) pertaining to a respective RB\+: \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }\\\cline{1-5}
\endhead
{\ttfamily v0\+\_\+epi16\+:}   &RB0 RB0   &RB0 RB0   &RB1 RB1   &RB1 RB1    \\\cline{1-5}
{\ttfamily v1\+\_\+epi16\+:}   &RB0 RB0   &RB0 RB0   &RB1 RB1   &RB1 RB1    \\\cline{1-5}
{\ttfamily v2\+\_\+epi16\+:}   &RB0 RB0   &RB0 RB0   &RB1 RB1   &RB1 RB1   \\\cline{1-5}
\end{longtabu}


The function first performs vertical min/max search across the three registers (comparing 16bit samples), then horizontal min/max across elements in each 128bit lane of the resulting vector. Finally, the function takes the absolute value of the two 16bit samples computed thus far and stores them in the output span.


\begin{DoxyTemplParams}{Template Parameters}
{\em COMPARE} & AVX2 intrinsic used for comparison, either {\ttfamily mm256\+\_\+min\+\_\+epi16} or {\ttfamily \+\_\+mm256\+\_\+max\+\_\+epi16}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em abs} & A span of two absolute values of max (or min) samples in each of the two input RBs. \\
\hline
\mbox{\texttt{ in}}  & {\em v0\+\_\+epi16} & AVX2 register storing first four IQ pairs of each of the two RB. \\
\hline
\mbox{\texttt{ in}}  & {\em v1\+\_\+epi16} & AVX2 register storing second four IQ pairs of each of the two RB. \\
\hline
\mbox{\texttt{ in}}  & {\em v2\+\_\+epi16} & AVX2 register storing last four IQ pairs of each of the two RB. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00064\ \{}
\DoxyCodeLine{00065\ \ \ \textcolor{comment}{//\ Find\ vertical\ min/max\ across\ every\ 3\ 16bit\ values\ in\ each\ resource\ block.}}
\DoxyCodeLine{00066\ \ \ \_\_m256i\ cmp\_8val\_epi16\ =\ COMPARE(COMPARE(v0\_epi16,\ v1\_epi16),\ v2\_epi16);}
\DoxyCodeLine{00067\ \ \ \textcolor{comment}{//\ Now\ 16bit\ vector\ elements\ look\ as\ follows:}}
\DoxyCodeLine{00068\ \ \ \textcolor{comment}{//\ [max(I00,\ I08,\ I04),\ max(Q00,\ Q08,\ Q04),\ max(I01,\ I09,\ I05),\ max(Q01,\ Q09,\ Q05),\ ...].}}
\DoxyCodeLine{00069\ }
\DoxyCodeLine{00070\ \ \ \textcolor{comment}{//\ Swap\ 64bit\ words\ inside\ 128bit\ lanes\ and\ find\ 4\ min/max\ values.}}
\DoxyCodeLine{00071\ \ \ \_\_m256i\ cmp\_8val\_swp\_epi16\ =\ \_mm256\_shuffle\_epi32(cmp\_8val\_epi16,\ 0x4e);}
\DoxyCodeLine{00072\ \ \ \_\_m256i\ cmp\_4val\_epi16\ \ \ \ \ =\ COMPARE(cmp\_8val\_epi16,\ cmp\_8val\_swp\_epi16);}
\DoxyCodeLine{00073\ \ \ \textcolor{comment}{//\ Swap\ 32bit\ words\ and\ find\ 2\ min/max\ values.}}
\DoxyCodeLine{00074\ \ \ \_\_m256i\ cmp\_4val\_swp\_epi16\ =\ \_mm256\_shuffle\_epi32(cmp\_4val\_epi16,\ 0x1b);}
\DoxyCodeLine{00075\ \ \ \_\_m256i\ cmp\_2val\_epi16\ \ \ \ \ =\ COMPARE(cmp\_4val\_epi16,\ cmp\_4val\_swp\_epi16);}
\DoxyCodeLine{00076\ \ \ \textcolor{comment}{//\ Swap\ 16bit\ words\ and\ find\ final\ min/max\ values\ for\ each\ RB.}}
\DoxyCodeLine{00077\ \ \ \textcolor{keyword}{const}\ \_\_m256i\ shuffle\_mask\ =\ \_mm256\_setr\_epi8(}
\DoxyCodeLine{00078\ \ \ \ \ \ \ 2,\ 3,\ 0,\ 1,\ 6,\ 7,\ 4,\ 5,\ 8,\ 9,\ 10,\ 11,\ 14,\ 15,\ 12,\ 13,\ 2,\ 3,\ 0,\ 1,\ 6,\ 7,\ 4,\ 5,\ 8,\ 9,\ 10,\ 11,\ 14,\ 15,\ 12,\ 13);}
\DoxyCodeLine{00079\ \ \ \_\_m256i\ cmp\_2val\_swp\_epi16\ =\ \_mm256\_shuffle\_epi8(cmp\_2val\_epi16,\ shuffle\_mask);}
\DoxyCodeLine{00080\ \ \ \_\_m256i\ cmp\_rb0\_rb1\_epi16\ \ =\ COMPARE(cmp\_2val\_epi16,\ cmp\_2val\_swp\_epi16);}
\DoxyCodeLine{00081\ \ \ \_\_m256i\ cmp\_rb0\_rb1\_epu16\ \ =\ \_mm256\_abs\_epi16(cmp\_rb0\_rb1\_epi16);}
\DoxyCodeLine{00082\ }
\DoxyCodeLine{00083\ \ \ \textcolor{comment}{//\ Extract\ absolute\ minimum/maximum\ values\ for\ each\ RB.}}
\DoxyCodeLine{00084\ \ \ abs[0]\ =\ \_mm256\_extract\_epi16(cmp\_rb0\_rb1\_epu16,\ 0);}
\DoxyCodeLine{00085\ \ \ abs[1]\ =\ \_mm256\_extract\_epi16(cmp\_rb0\_rb1\_epu16,\ 8);}
\DoxyCodeLine{00086\ \}}

\end{DoxyCode}
