\doxysection{rlc\+\_\+sdu\+\_\+queue\+\_\+lockfree.\+h}
\hypertarget{rlc__sdu__queue__lockfree_8h_source}{}\label{rlc__sdu__queue__lockfree_8h_source}\index{lib/rlc/rlc\_sdu\_queue\_lockfree.h@{lib/rlc/rlc\_sdu\_queue\_lockfree.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{/*}}
\DoxyCodeLine{00002\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00003\ \textcolor{comment}{\ *\ Copyright\ 2021-\/2024\ Software\ Radio\ Systems\ Limited}}
\DoxyCodeLine{00004\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00005\ \textcolor{comment}{\ *\ This\ file\ is\ part\ of\ srsRAN.}}
\DoxyCodeLine{00006\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00007\ \textcolor{comment}{\ *\ srsRAN\ is\ free\ software:\ you\ can\ redistribute\ it\ and/or\ modify}}
\DoxyCodeLine{00008\ \textcolor{comment}{\ *\ it\ under\ the\ terms\ of\ the\ GNU\ Affero\ General\ Public\ License\ as}}
\DoxyCodeLine{00009\ \textcolor{comment}{\ *\ published\ by\ the\ Free\ Software\ Foundation,\ either\ version\ 3\ of}}
\DoxyCodeLine{00010\ \textcolor{comment}{\ *\ the\ License,\ or\ (at\ your\ option)\ any\ later\ version.}}
\DoxyCodeLine{00011\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00012\ \textcolor{comment}{\ *\ srsRAN\ is\ distributed\ in\ the\ hope\ that\ it\ will\ be\ useful,}}
\DoxyCodeLine{00013\ \textcolor{comment}{\ *\ but\ WITHOUT\ ANY\ WARRANTY;\ without\ even\ the\ implied\ warranty\ of}}
\DoxyCodeLine{00014\ \textcolor{comment}{\ *\ MERCHANTABILITY\ or\ FITNESS\ FOR\ A\ PARTICULAR\ PURPOSE.\ \ See\ the}}
\DoxyCodeLine{00015\ \textcolor{comment}{\ *\ GNU\ Affero\ General\ Public\ License\ for\ more\ details.}}
\DoxyCodeLine{00016\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00017\ \textcolor{comment}{\ *\ A\ copy\ of\ the\ GNU\ Affero\ General\ Public\ License\ can\ be\ found\ in}}
\DoxyCodeLine{00018\ \textcolor{comment}{\ *\ the\ LICENSE\ file\ in\ the\ top-\/level\ directory\ of\ this\ distribution}}
\DoxyCodeLine{00019\ \textcolor{comment}{\ *\ and\ at\ http://www.gnu.org/licenses/.}}
\DoxyCodeLine{00020\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00021\ \textcolor{comment}{\ */}}
\DoxyCodeLine{00022\ }
\DoxyCodeLine{00023\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{pragma}\ \textcolor{preprocessor}{once}}
\DoxyCodeLine{00024\ }
\DoxyCodeLine{00025\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \mbox{\hyperlink{rlc__bearer__logger_8h}{"{}rlc\_bearer\_logger.h"{}}}}
\DoxyCodeLine{00026\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/adt/concurrent\_queue.h"{}}}
\DoxyCodeLine{00027\ \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include}\ \textcolor{preprocessor}{"{}srsran/rlc/rlc\_tx.h"{}}}
\DoxyCodeLine{00028\ }
\DoxyCodeLine{00029\ \textcolor{keyword}{namespace}\ \mbox{\hyperlink{namespacesrsran}{srsran}}\ \{}
\DoxyCodeLine{00030\ }
\DoxyCodeLine{00031\ \textcolor{comment}{///\ \(\backslash\)brief\ Lockfree\ RLC\ SDU\ queue}}
\DoxyCodeLine{00032\ \textcolor{comment}{///}}
\DoxyCodeLine{00033\ \textcolor{comment}{///\ This\ class\ is\ used\ as\ FIFO\ buffer\ for\ RLC\ SDUs\ from\ upper\ layers\ that\ shall\ be\ transmitted\ by\ the\ RLC\ Tx\ entity.}}
\DoxyCodeLine{00034\ \textcolor{comment}{///\ It\ implements\ SPSC\ (single\ producer\ single\ consumer)\ semantics,\ i.e.\ allows\ concurrent\ access\ by\ one\ upper-\/layer}}
\DoxyCodeLine{00035\ \textcolor{comment}{///\ thread\ and\ one\ lower-\/layer\ thread.\ Internally,\ this\ class\ wraps\ a\ lock-\/free\ SPSC\ queue\ to\ store\ the\ actual\ SDUs\ and}}
\DoxyCodeLine{00036\ \textcolor{comment}{///\ involves\ additional\ bookkeeping\ to\ support\ discard\ of\ SDUs\ and\ to\ track\ the\ amount\ of\ buffered\ SDUs\ and\ bytes.}}
\DoxyCodeLine{00037\ \textcolor{comment}{///}}
\DoxyCodeLine{00038\ \textcolor{comment}{///\ From\ the\ perspective\ of\ the\ upper-\/layer\ thread\ this\ class\ provides\ methods\ to\ write\ RLC\ SDUs\ (with\ or\ without\ PDCP}}
\DoxyCodeLine{00039\ \textcolor{comment}{///\ SN)\ and\ to\ discard\ SDUs\ by\ their\ PDCP\ SN.\ SDUs\ without\ PDCP\ SN\ cannot\ be\ discarded.}}
\DoxyCodeLine{00040\ \textcolor{comment}{///\ SDUs\ that\ are\ marked\ as\ discarded\ remain\ in\ the\ internal\ queue\ until\ they\ are\ popped\ (and\ dropped)\ via\ \(\backslash\)c\ read.}}
\DoxyCodeLine{00041\ \textcolor{comment}{///\ Writing\ to\ the\ queue\ fails\ if\ the\ internal\ queue\ is\ either\ full\ or\ the\ queue\ already\ contains\ an\ SDU\ (whether\ valid}}
\DoxyCodeLine{00042\ \textcolor{comment}{///\ or\ marked\ as\ discarded)\ with\ the\ same\ value\ for\ [PDCP\_SN\ mod\ capacity].}}
\DoxyCodeLine{00043\ \textcolor{comment}{///}}
\DoxyCodeLine{00044\ \textcolor{comment}{///\ From\ the\ perspective\ of\ the\ lower-\/layer\ thread\ it\ provides\ methods\ to\ read\ RLC\ SDUs\ and\ to\ query\ the\ total\ number\ of}}
\DoxyCodeLine{00045\ \textcolor{comment}{///\ buffered\ SDUs\ and\ bytes.}}
\DoxyCodeLine{00046\ \textcolor{comment}{///\ SDUs\ are\ read\ in\ the\ same\ order\ as\ they\ were\ written\ into\ the\ queue.\ There\ is\ no\ reordering\ by\ PDCP\ SN.}}
\DoxyCodeLine{00047\ \textcolor{keyword}{class}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree}{rlc\_sdu\_queue\_lockfree}}}
\DoxyCodeLine{00048\ \{}
\DoxyCodeLine{00049\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00050\ \ \ \textcolor{keyword}{explicit}\ rlc\_sdu\_queue\_lockfree(uint16\_t\ capacity\_,\ rlc\_bearer\_logger\&\ logger\_)\ :\ logger(logger\_),\ capacity(capacity\_)}
\DoxyCodeLine{00051\ \ \ \{}
\DoxyCodeLine{00052\ \ \ \ \ sdu\_states\ =\ std::make\_unique<std::atomic<uint32\_t>[]>(capacity);}
\DoxyCodeLine{00053\ \ \ \ \ sdu\_sizes\ \ =\ std::make\_unique<std::atomic<size\_t>[]>(capacity);}
\DoxyCodeLine{00054\ }
\DoxyCodeLine{00055\ \ \ \ \ \textcolor{keywordflow}{for}\ (uint16\_t\ i\ =\ 0;\ i\ <\ capacity;\ i++)\ \{}
\DoxyCodeLine{00056\ \ \ \ \ \ \ sdu\_states[i].store(STATE\_FREE,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00057\ \ \ \ \ \}}
\DoxyCodeLine{00058\ }
\DoxyCodeLine{00059\ \ \ \ \ queue\ =\ std::make\_unique<}
\DoxyCodeLine{00060\ \ \ \ \ \ \ \ \ concurrent\_queue<rlc\_sdu,\ concurrent\_queue\_policy::lockfree\_spsc,\ concurrent\_queue\_wait\_policy::non\_blocking>>(}
\DoxyCodeLine{00061\ \ \ \ \ \ \ \ \ capacity);}
\DoxyCodeLine{00062\ \ \ \}}
\DoxyCodeLine{00063\ }
\DoxyCodeLine{00064\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Writes\ an\ RLC\ SDU\ (with\ optional\ PDCP\ SN)\ to\ the\ queue,\ if\ possible.}}
\DoxyCodeLine{00065\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00066\ \ \ \textcolor{comment}{///\ This\ function\ may\ be\ called\ by\ the\ upper-\/layer\ thread.}}
\DoxyCodeLine{00067\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00068\ \ \ \textcolor{comment}{///\ The\ write\ fails\ (returns\ false)\ in\ the\ following\ cases:}}
\DoxyCodeLine{00069\ \ \ \textcolor{comment}{///\ -\/\ The\ internal\ queue\ is\ full.}}
\DoxyCodeLine{00070\ \ \ \textcolor{comment}{///\ -\/\ Another\ SDU\ with\ same\ value\ of\ [PDCP\_SN\ mod\ capacity]\ exists\ (either\ valid\ or\ discarded)\ in\ the\ queue.}}
\DoxyCodeLine{00071\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00072\ \ \ \textcolor{comment}{///\ \(\backslash\)param\ sdu\ The\ RLC\ SDU\ that\ shall\ be\ written.}}
\DoxyCodeLine{00073\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ True\ if\ the\ RLC\ SDU\ was\ successfully\ written\ to\ the\ queue,\ otherwise\ false.}}
\DoxyCodeLine{00074\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a1a653b33da96f2caea9471794877464c}{write}}(\mbox{\hyperlink{structsrsran_1_1rlc__sdu}{rlc\_sdu}}\ sdu)}
\DoxyCodeLine{00075\ \ \ \{}
\DoxyCodeLine{00076\ \ \ \ \ \textcolor{comment}{//\ if\ the\ SDU\ has\ a\ PDCP\ SN,\ first\ check\ the\ slot\ is\ available}}
\DoxyCodeLine{00077\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional}}<uint32\_t>\ pdcp\_sn\ \ =\ sdu.pdcp\_sn;}
\DoxyCodeLine{00078\ \ \ \ \ \textcolor{keyword}{const}\ size\_t\ \ \ \ \ \ \ sdu\_size\ =\ sdu.buf.length();}
\DoxyCodeLine{00079\ \ \ \ \ \textcolor{keywordflow}{if}\ (pdcp\_sn.has\_value())\ \{}
\DoxyCodeLine{00080\ \ \ \ \ \ \ \textcolor{keyword}{const}\ uint32\_t\ pdcp\_sn\_value\ =\ sdu.pdcp\_sn.value();}
\DoxyCodeLine{00081\ \ \ \ \ \ \ \textcolor{comment}{//\ load\ slot\ state\ (memory\_order\_acquire\ ensures\ sdu\_size\ is\ written\ after\ this)}}
\DoxyCodeLine{00082\ \ \ \ \ \ \ uint32\_t\ slot\_state\ =\ sdu\_states[pdcp\_sn\_value\ \%\ capacity].load(std::memory\_order\_acquire);}
\DoxyCodeLine{00083\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (slot\_state\ !=\ STATE\_FREE)\ \{}
\DoxyCodeLine{00084\ \ \ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ failed\ to\ enqueue\ pdcp\_sn=\{\}.\ Slot\ holds\ pdcp\_sn=\{\}"{}},\ pdcp\_sn\_value,\ slot\_state);}
\DoxyCodeLine{00085\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00086\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00087\ }
\DoxyCodeLine{00088\ \ \ \ \ \ \ \textcolor{comment}{//\ slot\ is\ free,\ we\ can\ safely\ store\ the\ SDU\ size}}
\DoxyCodeLine{00089\ \ \ \ \ \ \ sdu\_sizes[pdcp\_sn\_value\ \%\ capacity].store(sdu\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00090\ }
\DoxyCodeLine{00091\ \ \ \ \ \ \ \textcolor{comment}{//\ allocate\ slot\ by\ writing\ the\ PDCP\ SN\ into\ it\ (memory\_order\_relaxed,\ don't\ care\ about\ order\ because\ of\ "{}release"{}}}
\DoxyCodeLine{00092\ \ \ \ \ \ \ \textcolor{comment}{//\ semantics\ of\ the\ push\ to\ queue)}}
\DoxyCodeLine{00093\ \ \ \ \ \ \ sdu\_states[pdcp\_sn\_value\ \%\ capacity].store(pdcp\_sn\_value,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00094\ \ \ \ \ \}}
\DoxyCodeLine{00095\ }
\DoxyCodeLine{00096\ \ \ \ \ \textcolor{comment}{//\ push\ SDU\ to\ queue}}
\DoxyCodeLine{00097\ \ \ \ \ \textcolor{keywordtype}{bool}\ pushed\ =\ queue-\/>try\_push(std::move(sdu));}
\DoxyCodeLine{00098\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ pushed)\ \{}
\DoxyCodeLine{00099\ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ failed\ to\ enqueue\ pdcp\_sn=\{\}.\ Queue\ is\ full"{}},\ pdcp\_sn);}
\DoxyCodeLine{00100\ \ \ \ \ \ \ \textcolor{comment}{//\ if\ the\ SDU\ has\ a\ PDCP\ SN,\ release\ the\ slot\ (memory\_order\_relaxed,\ don't\ care\ about\ value\ of\ sdu\_size)}}
\DoxyCodeLine{00101\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (pdcp\_sn.has\_value())\ \{}
\DoxyCodeLine{00102\ \ \ \ \ \ \ \ \ sdu\_states[pdcp\_sn.value()\ \%\ capacity].store(STATE\_FREE,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00103\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00104\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00105\ \ \ \ \ \}}
\DoxyCodeLine{00106\ }
\DoxyCodeLine{00107\ \ \ \ \ \textcolor{comment}{//\ update\ totals}}
\DoxyCodeLine{00108\ \ \ \ \ n\_sdus.fetch\_add(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00109\ \ \ \ \ n\_bytes.fetch\_add(sdu\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00110\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00111\ \ \ \}}
\DoxyCodeLine{00112\ }
\DoxyCodeLine{00113\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Marks\ an\ RLC\ SDU\ as\ "{}discarded"{},\ if\ possible.}}
\DoxyCodeLine{00114\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00115\ \ \ \textcolor{comment}{///\ This\ function\ may\ be\ called\ by\ the\ upper-\/layer\ thread.}}
\DoxyCodeLine{00116\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00117\ \ \ \textcolor{comment}{///\ The\ function\ fails\ (returns\ false)\ in\ the\ following\ cases:}}
\DoxyCodeLine{00118\ \ \ \textcolor{comment}{///\ -\/\ The\ SDU\ with\ the\ PDCP\ SN\ is\ already\ marked\ as\ discarded.}}
\DoxyCodeLine{00119\ \ \ \textcolor{comment}{///\ -\/\ The\ SDU\ with\ the\ PDCP\ SN\ is\ not\ in\ the\ queue.}}
\DoxyCodeLine{00120\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00121\ \ \ \textcolor{comment}{///\ In\ case\ of\ success,\ the\ number\ of\ SDUs/bytes\ will\ be\ updated\ immediately.}}
\DoxyCodeLine{00122\ \ \ \textcolor{comment}{///\ However,\ the\ actual\ SDU\ remains\ in\ the\ internal\ queue\ until\ it\ is\ popped\ and\ finally\ discarded\ via\ \(\backslash\)c\ read.}}
\DoxyCodeLine{00123\ \ \ \textcolor{comment}{///\ Meanwhile,\ no\ further\ SDU\ with\ the\ same\ value\ of\ [PDCP\_SN\ mod\ capacity]\ can\ be\ added\ to\ the\ queue.}}
\DoxyCodeLine{00124\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00125\ \ \ \textcolor{comment}{///\ \(\backslash\)param\ pdcp\_sn\ The\ PDCP\ SN\ of\ the\ SDU\ that\ shall\ be\ discarded.}}
\DoxyCodeLine{00126\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ True\ if\ the\ RLC\ SDU\ was\ successfully\ discarded,\ otherwise\ false.}}
\DoxyCodeLine{00127\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a5918fa48177cf34b10fef220c8fc719f}{try\_discard}}(uint32\_t\ pdcp\_sn)}
\DoxyCodeLine{00128\ \ \ \{}
\DoxyCodeLine{00129\ \ \ \ \ uint32\_t\ expected\_state\ =\ pdcp\_sn;}
\DoxyCodeLine{00130\ \ \ \ \ uint32\_t\ desired\_state\ \ =\ STATE\_DISCARDED;}
\DoxyCodeLine{00131\ \ \ \ \ \textcolor{comment}{//\ set\ slot\ state\ as\ "{}discarded"{}\ only\ if\ it\ holds\ the\ PDCP\ SN;\ otherwise\ load\ the\ existing\ state}}
\DoxyCodeLine{00132\ \ \ \ \ \textcolor{comment}{//\ -\/\ on\ success:\ memory\_order\_acquire\ ensures\ sdu\_size\ is\ up\ to\ date}}
\DoxyCodeLine{00133\ \ \ \ \ \textcolor{comment}{//\ -\/\ on\ failure:\ memory\_order\_relaxed,\ don't\ care\ about\ value\ of\ sdu\_size}}
\DoxyCodeLine{00134\ \ \ \ \ \textcolor{keywordtype}{bool}\ success\ =\ sdu\_states[pdcp\_sn\ \%\ capacity].compare\_exchange\_strong(}
\DoxyCodeLine{00135\ \ \ \ \ \ \ \ \ expected\_state,\ desired\_state,\ std::memory\_order\_acquire,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00136\ \ \ \ \ uint32\_t\ sdu\_size\ =\ sdu\_sizes[pdcp\_sn\ \%\ capacity].load(std::memory\_order\_relaxed);}
\DoxyCodeLine{00137\ }
\DoxyCodeLine{00138\ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ success)\ \{}
\DoxyCodeLine{00139\ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (expected\_state)\ \{}
\DoxyCodeLine{00140\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ STATE\_DISCARDED:}
\DoxyCodeLine{00141\ \ \ \ \ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ cannot\ discard\ pdcp\_sn=\{\}.\ Slot\ is\ already\ discarded"{}},\ pdcp\_sn);}
\DoxyCodeLine{00142\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00143\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ STATE\_FREE:}
\DoxyCodeLine{00144\ \ \ \ \ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ cannot\ discard\ pdcp\_sn=\{\}.\ Slot\ is\ already\ free"{}},\ pdcp\_sn);}
\DoxyCodeLine{00145\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00146\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00147\ \ \ \ \ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ cannot\ discard\ pdcp\_sn=\{\}.\ Slot\ holds\ pdcp\_sn=\{\}"{}},\ pdcp\_sn,\ expected\_state);}
\DoxyCodeLine{00148\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00149\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00150\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00151\ \ \ \ \ \}}
\DoxyCodeLine{00152\ }
\DoxyCodeLine{00153\ \ \ \ \ \textcolor{comment}{//\ update\ totals}}
\DoxyCodeLine{00154\ \ \ \ \ n\_sdus.fetch\_sub(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00155\ \ \ \ \ n\_bytes.fetch\_sub(sdu\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00156\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00157\ \ \ \}}
\DoxyCodeLine{00158\ }
\DoxyCodeLine{00159\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Reads\ an\ RLC\ SDU\ (with\ optional\ PDCP\ SN)\ from\ the\ queue,\ if\ possible.}}
\DoxyCodeLine{00160\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00161\ \ \ \textcolor{comment}{///\ This\ function\ may\ be\ called\ by\ the\ lower-\/layer\ thread.}}
\DoxyCodeLine{00162\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00163\ \ \ \textcolor{comment}{///\ The\ read\ fails\ (returns\ false)\ in\ the\ following\ cases:}}
\DoxyCodeLine{00164\ \ \ \textcolor{comment}{///\ -\/\ The\ internal\ queue\ only\ contains\ SDUs\ that\ are\ marked\ as\ discarded.}}
\DoxyCodeLine{00165\ \ \ \textcolor{comment}{///\ -\/\ The\ internal\ queue\ is\ empty.}}
\DoxyCodeLine{00166\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00167\ \ \ \textcolor{comment}{///\ Each\ call\ of\ this\ function\ pops\ and\ drops\ SDUs\ that\ are\ marked\ as\ discarded\ from\ the\ internal\ queue\ in\ a\ loop}}
\DoxyCodeLine{00168\ \ \ \textcolor{comment}{///\ until\ a\ valid\ SDU\ is\ popped\ (return\ true)\ or\ the\ queue\ is\ empty\ (returns\ false).}}
\DoxyCodeLine{00169\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00170\ \ \ \textcolor{comment}{///\ \(\backslash\)param\ sdu\ Reference\ to\ a\ \(\backslash\)c\ rlc\_sdu\ object\ that\ will\ be\ filled\ with\ the\ read\ RLC\ SDU.}}
\DoxyCodeLine{00171\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ True\ if\ an\ RLC\ SDU\ was\ successfully\ read\ from\ the\ queue,\ otherwise\ false.}}
\DoxyCodeLine{00172\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a5b2d6733746aaf17fd87a0743ba52501}{read}}(\mbox{\hyperlink{structsrsran_1_1rlc__sdu}{rlc\_sdu}}\&\ sdu)}
\DoxyCodeLine{00173\ \ \ \{}
\DoxyCodeLine{00174\ \ \ \ \ \textcolor{keywordtype}{bool}\ sdu\_is\_valid\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00175\ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{00176\ \ \ \ \ \ \ \textcolor{comment}{//\ first\ try\ to\ pop\ front\ (SDU\ can\ still\ get\ discarded\ from\ upper\ layers)}}
\DoxyCodeLine{00177\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ popped\ =\ queue-\/>try\_pop(sdu);}
\DoxyCodeLine{00178\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{not}\ popped)\ \{}
\DoxyCodeLine{00179\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ queue\ is\ empty}}
\DoxyCodeLine{00180\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00181\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00182\ }
\DoxyCodeLine{00183\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (sdu.pdcp\_sn.has\_value())\ \{}
\DoxyCodeLine{00184\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Check\ if\ the\ SDU\ is\ still\ valid\ (i.e.\ the\ PDCP\ SN\ was\ not\ already\ discarded)\ and\ release\ the\ slot}}
\DoxyCodeLine{00185\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ uint32\_t\ pdcp\_sn\ =\ sdu.pdcp\_sn.value();}
\DoxyCodeLine{00186\ \ \ \ \ \ \ \ \ sdu\_is\_valid\ \ \ \ \ \ \ \ \ \ \ =\ check\_and\_release(pdcp\_sn);\ \textcolor{comment}{//\ this\ also\ updates\ totals}}
\DoxyCodeLine{00187\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00188\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ SDUs\ without\ PDCP\ SN\ are\ alway\ valid\ as\ they\ can't\ be\ discarded}}
\DoxyCodeLine{00189\ \ \ \ \ \ \ \ \ sdu\_is\_valid\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00190\ }
\DoxyCodeLine{00191\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ update\ totals}}
\DoxyCodeLine{00192\ \ \ \ \ \ \ \ \ n\_sdus.fetch\_sub(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00193\ \ \ \ \ \ \ \ \ n\_bytes.fetch\_sub(sdu.buf.length(),\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00194\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00195\ \ \ \ \ \ \ \textcolor{comment}{//\ try\ again\ if\ SDU\ is\ not\ valid}}
\DoxyCodeLine{00196\ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{not}\ sdu\_is\_valid);}
\DoxyCodeLine{00197\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00198\ \ \ \}}
\DoxyCodeLine{00199\ }
\DoxyCodeLine{00200\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Reads\ the\ number\ of\ buffered\ SDUs\ that\ are\ not\ marked\ as\ discarded.}}
\DoxyCodeLine{00201\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00202\ \ \ \textcolor{comment}{///\ This\ function\ may\ be\ called\ by\ any\ thread.}}
\DoxyCodeLine{00203\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00204\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ The\ number\ of\ buffered\ SDUs\ that\ are\ not\ marked\ as\ discarded.}}
\DoxyCodeLine{00205\ \ \ uint32\_t\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a4c4aca80a693e78a7030d130e1116c09}{size\_sdus}}()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ n\_sdus.load(std::memory\_order\_relaxed);\ \}}
\DoxyCodeLine{00206\ }
\DoxyCodeLine{00207\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Reads\ the\ number\ of\ buffered\ SDU\ bytes\ that\ are\ not\ marked\ as\ discarded.}}
\DoxyCodeLine{00208\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00209\ \ \ \textcolor{comment}{///\ This\ function\ may\ be\ called\ by\ any\ thread.}}
\DoxyCodeLine{00210\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00211\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ The\ number\ of\ buffered\ SDU\ bytes\ that\ are\ not\ marked\ as\ discarded.}}
\DoxyCodeLine{00212\ \ \ uint32\_t\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_ab2d800cfef5a9542f480da984fc3e2d0}{size\_bytes}}()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ n\_bytes.load(std::memory\_order\_relaxed);\ \}}
\DoxyCodeLine{00213\ }
\DoxyCodeLine{00214\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Checks\ if\ the\ internal\ queue\ is\ empty.}}
\DoxyCodeLine{00215\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00216\ \ \ \textcolor{comment}{///\ This\ function\ may\ be\ called\ by\ any\ thread.}}
\DoxyCodeLine{00217\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00218\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ True\ if\ the\ internal\ queue\ is\ empty,\ otherwise\ false.}}
\DoxyCodeLine{00219\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a7ba1e310d8d662703f2922303c627a7a}{is\_empty}}()\ \{\ \textcolor{keywordflow}{return}\ queue-\/>empty();\ \}}
\DoxyCodeLine{00220\ }
\DoxyCodeLine{00221\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Checks\ if\ the\ internal\ queue\ is\ full.}}
\DoxyCodeLine{00222\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00223\ \ \ \textcolor{comment}{///\ This\ function\ may\ be\ called\ by\ any\ thread.}}
\DoxyCodeLine{00224\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00225\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ True\ if\ the\ internal\ queue\ is\ full,\ otherwise\ false.}}
\DoxyCodeLine{00226\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a68ac4760854df275260a793d0c71cf99}{is\_full}}()\ \{\ \textcolor{keywordflow}{return}\ queue-\/>size()\ >=\ capacity;\ \}}
\DoxyCodeLine{00227\ }
\DoxyCodeLine{00228\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00229\ \ \ \textcolor{comment}{///\ \(\backslash\)brief\ Checks\ if\ the\ RLC\ SDU\ with\ a\ PDCP\ SN\ is\ valid\ (i.e.\ not\ marked\ as\ discarded)\ and\ marks\ the\ respective\ slot}}
\DoxyCodeLine{00230\ \ \ \textcolor{comment}{///\ as\ free.}}
\DoxyCodeLine{00231\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00232\ \ \ \textcolor{comment}{///\ This\ private\ function\ may\ be\ called\ by\ \(\backslash\)c\ read\ by\ the\ lower-\/layer\ thread.}}
\DoxyCodeLine{00233\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00234\ \ \ \textcolor{comment}{///\ The\ function\ fails\ (returns\ false)\ in\ the\ following\ cases:}}
\DoxyCodeLine{00235\ \ \ \textcolor{comment}{///\ -\/\ The\ SDU\ with\ the\ PDCP\ SN\ is\ already\ marked\ as\ discarded.}}
\DoxyCodeLine{00236\ \ \ \textcolor{comment}{///\ -\/\ The\ SDU\ with\ the\ PDCP\ SN\ is\ not\ in\ the\ queue.}}
\DoxyCodeLine{00237\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00238\ \ \ \textcolor{comment}{///\ The\ number\ of\ SDUs/bytes\ will\ be\ updated\ unless\ the\ SDU\ is\ marked\ as\ discarded\ (in\ that\ case\ it\ was\ already}}
\DoxyCodeLine{00239\ \ \ \textcolor{comment}{///\ updated\ by\ \(\backslash\)c\ try\_discard).}}
\DoxyCodeLine{00240\ \ \ \textcolor{comment}{///}}
\DoxyCodeLine{00241\ \ \ \textcolor{comment}{///\ \(\backslash\)param\ pdcp\_sn\ The\ PDCP\ SN\ of\ the\ SDU\ that\ shall\ be\ checked\ and\ released.}}
\DoxyCodeLine{00242\ \ \ \textcolor{comment}{///\ \(\backslash\)return\ True\ if\ the\ RLC\ SDU\ with\ given\ PDCP\ SN\ is\ valid,\ otherwise\ false.}}
\DoxyCodeLine{00243\ \ \ \textcolor{keywordtype}{bool}\ check\_and\_release(uint32\_t\ pdcp\_sn)}
\DoxyCodeLine{00244\ \ \ \{}
\DoxyCodeLine{00245\ \ \ \ \ uint32\_t\ sdu\_size\ =\ sdu\_sizes[pdcp\_sn\ \%\ capacity].load(std::memory\_order\_relaxed);}
\DoxyCodeLine{00246\ \ \ \ \ \textcolor{comment}{//\ free\ the\ slot\ (memory\_order\_release\ ensures\ sdu\_size\ is\ read\ before\ the\ state\ is\ set\ to\ free)}}
\DoxyCodeLine{00247\ \ \ \ \ uint32\_t\ old\_state\ =\ sdu\_states[pdcp\_sn\ \%\ capacity].exchange(STATE\_FREE,\ std::memory\_order\_release);}
\DoxyCodeLine{00248\ }
\DoxyCodeLine{00249\ \ \ \ \ \textcolor{keywordtype}{bool}\ sdu\_is\_valid;}
\DoxyCodeLine{00250\ \ \ \ \ \textcolor{keywordflow}{if}\ (old\_state\ ==\ pdcp\_sn)\ \{}
\DoxyCodeLine{00251\ \ \ \ \ \ \ sdu\_is\_valid\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00252\ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ released\ valid\ pdcp\_sn=\{\}"{}},\ pdcp\_sn);}
\DoxyCodeLine{00253\ \ \ \ \ \}}
\DoxyCodeLine{00254\ \ \ \ \ \textcolor{keywordflow}{if}\ (old\_state\ !=\ pdcp\_sn)\ \{}
\DoxyCodeLine{00255\ \ \ \ \ \ \ sdu\_is\_valid\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00256\ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (old\_state)\ \{}
\DoxyCodeLine{00257\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ STATE\_DISCARDED:}
\DoxyCodeLine{00258\ \ \ \ \ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ released\ discarded\ pdcp\_sn=\{\}"{}},\ pdcp\_sn);}
\DoxyCodeLine{00259\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};\ \textcolor{comment}{//\ totals\ were\ already\ updated\ on\ discard}}
\DoxyCodeLine{00260\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ STATE\_FREE:}
\DoxyCodeLine{00261\ \ \ \ \ \ \ \ \ \ \ logger.log\_error(\textcolor{stringliteral}{"{}SDU\ queue\ error:\ Invalid\ release\ of\ pdcp\_sn=\{\}.\ Slot\ was\ already\ free"{}},\ pdcp\_sn);}
\DoxyCodeLine{00262\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00263\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00264\ \ \ \ \ \ \ \ \ \ \ logger.log\_error(\textcolor{stringliteral}{"{}SDU\ queue\ error:\ Invalid\ release\ of\ pdcp\_sn=\{\}.\ Slot\ holds\ pdcp\_sn=\{\}"{}},\ pdcp\_sn,\ old\_state);}
\DoxyCodeLine{00265\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00266\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00267\ \ \ \ \ \}}
\DoxyCodeLine{00268\ }
\DoxyCodeLine{00269\ \ \ \ \ \textcolor{comment}{//\ update\ totals}}
\DoxyCodeLine{00270\ \ \ \ \ n\_sdus.fetch\_sub(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00271\ \ \ \ \ n\_bytes.fetch\_sub(sdu\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00272\ \ \ \ \ \textcolor{keywordflow}{return}\ sdu\_is\_valid;}
\DoxyCodeLine{00273\ \ \ \}}
\DoxyCodeLine{00274\ }
\DoxyCodeLine{00275\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ uint32\_t\ STATE\_FREE\ \ \ \ \ \ =\ 0xffffffff;\ \textcolor{comment}{///<\ Sentinel\ value\ to\ mark\ a\ slot\ as\ free.}}
\DoxyCodeLine{00276\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ uint32\_t\ STATE\_DISCARDED\ =\ 0xfffffffe;\ \textcolor{comment}{///<\ Sentinel\ value\ to\ mark\ a\ slot\ as\ discarded.}}
\DoxyCodeLine{00277\ }
\DoxyCodeLine{00278\ \ \ rlc\_bearer\_logger\&\ logger;}
\DoxyCodeLine{00279\ }
\DoxyCodeLine{00280\ \ \ uint16\_t\ \ \ \ \ \ \ \ \ \ \ \ \ \ capacity;}
\DoxyCodeLine{00281\ \ \ std::atomic<uint32\_t>\ n\_bytes\ =\ \{0\};}
\DoxyCodeLine{00282\ \ \ std::atomic<uint32\_t>\ n\_sdus\ \ =\ \{0\};}
\DoxyCodeLine{00283\ }
\DoxyCodeLine{00284\ \ \ std::unique\_ptr<}
\DoxyCodeLine{00285\ \ \ \ \ \ \ concurrent\_queue<rlc\_sdu,\ concurrent\_queue\_policy::lockfree\_spsc,\ concurrent\_queue\_wait\_policy::non\_blocking>>}
\DoxyCodeLine{00286\ \ \ \ \ \ \ queue;}
\DoxyCodeLine{00287\ }
\DoxyCodeLine{00288\ \ \ std::unique\_ptr<std::atomic<uint32\_t>[]>\ sdu\_states;}
\DoxyCodeLine{00289\ \ \ std::unique\_ptr<std::atomic<size\_t>[]>\ \ \ sdu\_sizes;}
\DoxyCodeLine{00290\ \};}
\DoxyCodeLine{00291\ }
\DoxyCodeLine{00292\ \}\ \textcolor{comment}{//\ namespace\ srsran}}
\DoxyCodeLine{00293\ }
\DoxyCodeLine{00294\ \textcolor{keyword}{namespace}\ fmt\ \{}
\DoxyCodeLine{00295\ \textcolor{keyword}{template}\ <>}
\DoxyCodeLine{00296\ \textcolor{keyword}{struct}\ formatter<srsran::rlc\_sdu\_queue\_lockfree>\ \{}
\DoxyCodeLine{00297\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ParseContext>}
\DoxyCodeLine{00298\ \ \ \textcolor{keyword}{auto}\ parse(ParseContext\&\ ctx)\ -\/>\ \textcolor{keyword}{decltype}(ctx.begin())}
\DoxyCodeLine{00299\ \ \ \{}
\DoxyCodeLine{00300\ \ \ \ \ \textcolor{keywordflow}{return}\ ctx.begin();}
\DoxyCodeLine{00301\ \ \ \}}
\DoxyCodeLine{00302\ }
\DoxyCodeLine{00303\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FormatContext>}
\DoxyCodeLine{00304\ \ \ \textcolor{keyword}{auto}\ format(\textcolor{keyword}{const}\ srsran::rlc\_sdu\_queue\_lockfree\&\ q,\ FormatContext\&\ ctx)}
\DoxyCodeLine{00305\ \ \ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(std::declval<FormatContext>().out())}
\DoxyCodeLine{00306\ \ \ \{}
\DoxyCodeLine{00307\ \ \ \ \ \textcolor{keywordflow}{return}\ format\_to(ctx.out(),\ \textcolor{stringliteral}{"{}queued\_sdus=\{\}\ queued\_bytes=\{\}"{}},\ q.size\_sdus(),\ q.size\_bytes());}
\DoxyCodeLine{00308\ \ \ \}}
\DoxyCodeLine{00309\ \};}
\DoxyCodeLine{00310\ }
\DoxyCodeLine{00311\ \}\ \textcolor{comment}{//\ namespace\ fmt}}

\end{DoxyCode}
