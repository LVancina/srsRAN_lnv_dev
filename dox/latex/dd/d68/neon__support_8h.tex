\doxysection{lib/phy/upper/channel\+\_\+coding/ldpc/neon\+\_\+support.h File Reference}
\hypertarget{neon__support_8h}{}\label{neon__support_8h}\index{lib/phy/upper/channel\_coding/ldpc/neon\_support.h@{lib/phy/upper/channel\_coding/ldpc/neon\_support.h}}


NEON support for LDPC.  


{\ttfamily \#include "{}simd\+\_\+support.\+h"{}}\newline
Include dependency graph for neon\+\_\+support.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d0/da8/neon__support_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d6/d85/neon__support_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespacesrsran}{srsran}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{neon__support_8h_ab0030217caf2d7e2b327d07751e4c2be}\label{neon__support_8h_ab0030217caf2d7e2b327d07751e4c2be} 
\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{using}} {\bfseries srsran\+::neon\+::neon\+\_\+span} = \mbox{\hyperlink{classsrsran_1_1detail_1_1simd__span}{detail\+::simd\+\_\+span}}$<$\mbox{\hyperlink{structsrsran_1_1detail_1_1simd128__wrapper}{detail\+::simd128\+\_\+wrapper}}, int8\+\_\+t$>$
\item 
\Hypertarget{neon__support_8h_a5d97d705a15a676154f5ea4d072aba01}\label{neon__support_8h_a5d97d705a15a676154f5ea4d072aba01} 
\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{using}} {\bfseries srsran\+::neon\+::neon\+\_\+const\+\_\+span} = \mbox{\hyperlink{classsrsran_1_1detail_1_1simd__span}{detail\+::simd\+\_\+span}}$<$\mbox{\hyperlink{structsrsran_1_1detail_1_1simd128__wrapper}{detail\+::simd128\+\_\+wrapper}}, \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{const}} int8\+\_\+t$>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{int8x16\+\_\+t}} \mbox{\hyperlink{neon__support_8h_aab6a50e8ea3df82c53e874c2059fd1a7}{srsran\+::neon\+::scale\+\_\+s8}} (\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{int8x16\+\_\+t}} a, \mbox{\hyperlink{classfloat}{float}} \mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{sf}}, \mbox{\hyperlink{classuint8__t}{uint8\+\_\+t}} \mbox{\hyperlink{namespacesrsran_a2918c0347dde854fce1aaebb70a16c33}{max}})
\begin{DoxyCompactList}\small\item\em Scales packed 8-\/bit integers in {\ttfamily a} by the scaling factor {\ttfamily sf}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
NEON support for LDPC. 

Builds upon \doxylink{simd__support_8h}{simd\+\_\+support.\+h} and specializes functions and templates for NEON registers. 

\doxysubsection{Function Documentation}
\Hypertarget{neon__support_8h_aab6a50e8ea3df82c53e874c2059fd1a7}\label{neon__support_8h_aab6a50e8ea3df82c53e874c2059fd1a7} 
\index{neon\_support.h@{neon\_support.h}!scale\_s8@{scale\_s8}}
\index{scale\_s8@{scale\_s8}!neon\_support.h@{neon\_support.h}}
\doxysubsubsection{\texorpdfstring{scale\_s8()}{scale\_s8()}}
{\footnotesize\ttfamily int8x16\+\_\+t srsran\+::neon\+::scale\+\_\+s8 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacesrsran_a58e7c9f2c51a9ad6a0899b46d5315723}{int8x16\+\_\+t}}}]{a,  }\item[{\mbox{\hyperlink{classfloat}{float}}}]{sf,  }\item[{\mbox{\hyperlink{classuint8__t}{uint8\+\_\+t}}}]{max }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Scales packed 8-\/bit integers in {\ttfamily a} by the scaling factor {\ttfamily sf}. 

Values of {\ttfamily a} larger than {\ttfamily max} or smaller than {\ttfamily -\/max} are forwarded unaltered. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a} & Vector of packed 8-\/bit integers. \\
\hline
\mbox{\texttt{ in}}  & {\em sf} & Scaling factor (0, 1\mbox{]}. \\
\hline
\mbox{\texttt{ in}}  & {\em max} & Maximum input value (in absolute value) to which the scaling is applied \mbox{[}0, 127). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of packed 8-\/bit integers with the scaling result. 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00065\ \{}
\DoxyCodeLine{00066\ \ \ srsran\_assert((sf\ >\ 0)\ \&\&\ (sf\ <=\ 1),\ \textcolor{stringliteral}{"{}Scaling\ factor\ out\ of\ range."{}});}
\DoxyCodeLine{00067\ \ \ srsran\_assert(max\ <\ 127,\ \textcolor{stringliteral}{"{}Parameter\ max\ out\ of\ range."{}});}
\DoxyCodeLine{00068\ }
\DoxyCodeLine{00069\ \ \ \textcolor{keywordflow}{if}\ (sf\ >=\ .9999)\ \{}
\DoxyCodeLine{00070\ \ \ \ \ \textcolor{keywordflow}{return}\ a;}
\DoxyCodeLine{00071\ \ \ \}}
\DoxyCodeLine{00072\ \ \ \textcolor{comment}{//\ FLOAT2INT\ =\ 2\string^8\ =\ 256}}
\DoxyCodeLine{00073\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{unsigned}\ FLOAT2INT\ \ \ \ \ \ \ =\ 1U\ <<\ 8U;}
\DoxyCodeLine{00074\ \ \ \textcolor{keyword}{const}\ int8x16\_t\ \ \ \ \ \ \ \ \ \ \ MAX\_s8\ \ \ \ \ \ \ \ \ \ =\ vdupq\_n\_s8(max);}
\DoxyCodeLine{00075\ \ \ \textcolor{keyword}{const}\ int8x16\_t\ \ \ \ \ \ \ \ \ \ \ MIN\_s8\ \ \ \ \ \ \ \ \ \ =\ vdupq\_n\_s8(-\/max);}
\DoxyCodeLine{00076\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ uint16x8\_t\ \ \ mask\_even\_bytes\ =\ vdupq\_n\_u16(0x00ff);}
\DoxyCodeLine{00077\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ uint16x8\_t\ \ \ mask\_odd\_bytes\ \ =\ vdupq\_n\_u16(0xff00);}
\DoxyCodeLine{00078\ }
\DoxyCodeLine{00079\ \ \ \textcolor{comment}{//\ Scaling\ factor\ times\ FLOAT2INT.\ Note\ that\ the\ upper\ bound\ on\ sf\ implies}}
\DoxyCodeLine{00080\ \ \ \textcolor{comment}{//\ that\ (sf\ *\ FLOAT2INT)\ can\ be\ represented\ over\ 8\ bits.}}
\DoxyCodeLine{00081\ \ \ uint8x8\_t\ \ \ \ sf\_u8\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ vdup\_n\_u8(\textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classuint8__t}{uint8\_t}}\textcolor{keyword}{>}(sf\ *\ FLOAT2INT));}
\DoxyCodeLine{00082\ \ \ uint8x16x2\_t\ even\_odd\_deinterlvd\ =\ vuzpq\_u8(vreinterpretq\_u8\_s8(a),\ vreinterpretq\_u8\_s8(a));}
\DoxyCodeLine{00083\ \ \ \textcolor{comment}{//\ The\ above\ instruction\ results\ in:}}
\DoxyCodeLine{00084\ \ \ \textcolor{comment}{//\ even\ bytes\ of\ input\ vector\ placed\ in\ interleaved.val[0]}}
\DoxyCodeLine{00085\ \ \ \textcolor{comment}{//\ odd\ bytes\ of\ input\ vector\ \ placed\ in\ interleaved.val[1]}}
\DoxyCodeLine{00086\ \ \ uint16x8\_t\ p\_even\_u16\ =\ vmull\_u8(vget\_low\_u8(even\_odd\_deinterlvd.val[0]),\ sf\_u8);}
\DoxyCodeLine{00087\ \ \ uint16x8\_t\ p\_odd\_u16\ \ =\ vmull\_u8(vget\_low\_u8(even\_odd\_deinterlvd.val[1]),\ sf\_u8);}
\DoxyCodeLine{00088\ \ \ \textcolor{comment}{//\ Shift\ right\ MSB\ byte\ in\ every\ element\ of\ p\_even\_u16,\ mask\ it\ and\ xor\ with\ odd\ bytes\ stored\ in\ p\_odd\_u16.}}
\DoxyCodeLine{00089\ \ \ p\_odd\_u16\ \ \ \ \ \ \ \ =\ vandq\_u16(p\_odd\_u16,\ mask\_odd\_bytes);}
\DoxyCodeLine{00090\ \ \ p\_even\_u16\ \ \ \ \ \ \ =\ vandq\_u16(vshrq\_n\_u16(p\_even\_u16,\ 8),\ mask\_even\_bytes);}
\DoxyCodeLine{00091\ \ \ int8x16\_t\ result\ =\ vreinterpretq\_s8\_u16(vorrq\_u16(p\_even\_u16,\ p\_odd\_u16));}
\DoxyCodeLine{00092\ }
\DoxyCodeLine{00093\ \ \ \textcolor{comment}{//\ Replace\ values\ corresponding\ to\ "{}large"{}\ inputs\ with\ their\ original\ values.}}
\DoxyCodeLine{00094\ \ \ uint8x16\_t\ mask\_u8\ =\ vcgtq\_s8(a,\ MAX\_s8);}
\DoxyCodeLine{00095\ \ \ result\ \ \ \ \ \ \ \ \ \ \ \ \ =\ vbslq\_s8(mask\_u8,\ a,\ result);}
\DoxyCodeLine{00096\ \ \ mask\_u8\ \ \ \ \ \ \ \ \ \ \ \ =\ vcgtq\_s8(MIN\_s8,\ a);}
\DoxyCodeLine{00097\ \ \ result\ \ \ \ \ \ \ \ \ \ \ \ \ =\ vbslq\_s8(mask\_u8,\ a,\ result);}
\DoxyCodeLine{00098\ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00099\ \}}

\end{DoxyCode}
