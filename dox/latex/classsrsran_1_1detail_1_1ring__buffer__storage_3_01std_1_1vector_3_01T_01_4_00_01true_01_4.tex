\doxysection{srsran\+::detail\+::ring\+\_\+buffer\+\_\+storage\texorpdfstring{$<$}{<} std\+::vector\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>}, true \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4}{}\label{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4}\index{srsran::detail::ring\_buffer\_storage$<$ std::vector$<$ T $>$, true $>$@{srsran::detail::ring\_buffer\_storage$<$ std::vector$<$ T $>$, true $>$}}


Specialization of internal ring\+\_\+buffer data storage for the case a std\+::vector is used. For this specialization, the compiler does not know the size of the buffer at compile time, but it knows that it is a power of 2. Thus, it is able to avoid the \% operator, and uses instead a bit-\/wise and.  




{\ttfamily \#include $<$ring\+\_\+buffer.\+h$>$}

Inheritance diagram for srsran\+::detail\+::ring\+\_\+buffer\+\_\+storage\texorpdfstring{$<$}{<} std\+::vector\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>}, true \texorpdfstring{$>$}{>}\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_abaaaf79a74702acf8646046c402864f3}\label{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_abaaaf79a74702acf8646046c402864f3} 
{\bfseries ring\+\_\+buffer\+\_\+storage} (unsigned sz)
\item 
\Hypertarget{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_a7e10f7a45848cbc0ef0be0c75a9ebf84}\label{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_a7e10f7a45848cbc0ef0be0c75a9ebf84} 
void {\bfseries set\+\_\+size} (unsigned sz)
\item 
\Hypertarget{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_a7152ffbd29681e0797a0ebb3c6b3a169}\label{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_a7152ffbd29681e0797a0ebb3c6b3a169} 
unsigned {\bfseries advance\+\_\+pos} (unsigned pos, unsigned n) const noexcept
\begin{DoxyCompactList}\small\item\em Advance {\ttfamily pos} by {\ttfamily n} positions accounting for wrap-\/around. Leverages the fact that max\+\_\+size() is a power of 2. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_a991e1ab417fa3e274bc1107b757302e7}\label{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_a991e1ab417fa3e274bc1107b757302e7} 
size\+\_\+t {\bfseries max\+\_\+size} () const noexcept
\item 
\Hypertarget{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_a2e515ad46c9c30d23d61f019d0e3115a}\label{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_a2e515ad46c9c30d23d61f019d0e3115a} 
void {\bfseries swap} (\mbox{\hyperlink{classsrsran_1_1detail_1_1ring__buffer__storage}{ring\+\_\+buffer\+\_\+storage}} \&\mbox{\hyperlink{namespacesrsran_aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf}{other}}) noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_a75679a46a8fb9e66c7edd18326cdeffd}\label{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_a75679a46a8fb9e66c7edd18326cdeffd} 
unsigned {\bfseries count}
\begin{DoxyCompactList}\small\item\em Number of elements in the buffer. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_ae2a0f94aea5183396298861c880ba49a}\label{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_ae2a0f94aea5183396298861c880ba49a} 
std\+::vector$<$ T $>$ {\bfseries data}
\begin{DoxyCompactList}\small\item\em Container where elements are stored. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_ab033409451b0c986080ebab6a918edac}\label{classsrsran_1_1detail_1_1ring__buffer__storage_3_01std_1_1vector_3_01T_01_4_00_01true_01_4_ab033409451b0c986080ebab6a918edac} 
unsigned {\bfseries rpos}
\begin{DoxyCompactList}\small\item\em Reading position. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\newline
class srsran\+::detail\+::ring\+\_\+buffer\+\_\+storage$<$ std\+::vector$<$ T $>$, true $>$}
Specialization of internal ring\+\_\+buffer data storage for the case a std\+::vector is used. For this specialization, the compiler does not know the size of the buffer at compile time, but it knows that it is a power of 2. Thus, it is able to avoid the \% operator, and uses instead a bit-\/wise and. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/srsran/adt/ring\+\_\+buffer.\+h\end{DoxyCompactItemize}
