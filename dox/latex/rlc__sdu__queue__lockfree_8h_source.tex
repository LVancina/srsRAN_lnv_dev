\doxysection{rlc\+\_\+sdu\+\_\+queue\+\_\+lockfree.\+h}
\hypertarget{rlc__sdu__queue__lockfree_8h_source}{}\label{rlc__sdu__queue__lockfree_8h_source}\index{lib/rlc/rlc\_sdu\_queue\_lockfree.h@{lib/rlc/rlc\_sdu\_queue\_lockfree.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{/*}}
\DoxyCodeLine{00002\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00003\ \textcolor{comment}{\ *\ Copyright\ 2021-\/2024\ Software\ Radio\ Systems\ Limited}}
\DoxyCodeLine{00004\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00005\ \textcolor{comment}{\ *\ This\ file\ is\ part\ of\ srsRAN.}}
\DoxyCodeLine{00006\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00007\ \textcolor{comment}{\ *\ srsRAN\ is\ free\ software:\ you\ can\ redistribute\ it\ and/or\ modify}}
\DoxyCodeLine{00008\ \textcolor{comment}{\ *\ it\ under\ the\ terms\ of\ the\ GNU\ Affero\ General\ Public\ License\ as}}
\DoxyCodeLine{00009\ \textcolor{comment}{\ *\ published\ by\ the\ Free\ Software\ Foundation,\ either\ version\ 3\ of}}
\DoxyCodeLine{00010\ \textcolor{comment}{\ *\ the\ License,\ or\ (at\ your\ option)\ any\ later\ version.}}
\DoxyCodeLine{00011\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00012\ \textcolor{comment}{\ *\ srsRAN\ is\ distributed\ in\ the\ hope\ that\ it\ will\ be\ useful,}}
\DoxyCodeLine{00013\ \textcolor{comment}{\ *\ but\ WITHOUT\ ANY\ WARRANTY;\ without\ even\ the\ implied\ warranty\ of}}
\DoxyCodeLine{00014\ \textcolor{comment}{\ *\ MERCHANTABILITY\ or\ FITNESS\ FOR\ A\ PARTICULAR\ PURPOSE.\ \ See\ the}}
\DoxyCodeLine{00015\ \textcolor{comment}{\ *\ GNU\ Affero\ General\ Public\ License\ for\ more\ details.}}
\DoxyCodeLine{00016\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00017\ \textcolor{comment}{\ *\ A\ copy\ of\ the\ GNU\ Affero\ General\ Public\ License\ can\ be\ found\ in}}
\DoxyCodeLine{00018\ \textcolor{comment}{\ *\ the\ LICENSE\ file\ in\ the\ top-\/level\ directory\ of\ this\ distribution}}
\DoxyCodeLine{00019\ \textcolor{comment}{\ *\ and\ at\ http://www.gnu.org/licenses/.}}
\DoxyCodeLine{00020\ \textcolor{comment}{\ *}}
\DoxyCodeLine{00021\ \textcolor{comment}{\ */}}
\DoxyCodeLine{00022\ }
\DoxyCodeLine{00023\ \textcolor{preprocessor}{\#pragma\ once}}
\DoxyCodeLine{00024\ }
\DoxyCodeLine{00025\ \textcolor{preprocessor}{\#include\ "{}rlc\_bearer\_logger.h"{}}}
\DoxyCodeLine{00026\ \textcolor{preprocessor}{\#include\ "{}srsran/adt/concurrent\_queue.h"{}}}
\DoxyCodeLine{00027\ \textcolor{preprocessor}{\#include\ "{}srsran/rlc/rlc\_tx.h"{}}}
\DoxyCodeLine{00028\ }
\DoxyCodeLine{00029\ \textcolor{keyword}{namespace\ }\mbox{\hyperlink{namespacesrsran}{srsran}}\ \{}
\DoxyCodeLine{00030\ }
\DoxyCodeLine{00047\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree}{rlc\_sdu\_queue\_lockfree}}}
\DoxyCodeLine{00048\ \{}
\DoxyCodeLine{00049\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00050\ \ \ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree}{rlc\_sdu\_queue\_lockfree}}(uint16\_t\ capacity\_,\ \mbox{\hyperlink{classsrsran_1_1prefixed__logger}{rlc\_bearer\_logger}}\&\ logger\_)\ :\ logger(logger\_),\ capacity(capacity\_)}
\DoxyCodeLine{00051\ \ \ \{}
\DoxyCodeLine{00052\ \ \ \ \ sdu\_states\ =\ std::make\_unique<std::atomic<uint32\_t>[]>(capacity);}
\DoxyCodeLine{00053\ \ \ \ \ sdu\_sizes\ \ =\ std::make\_unique<std::atomic<size\_t>[]>(capacity);}
\DoxyCodeLine{00054\ }
\DoxyCodeLine{00055\ \ \ \ \ \textcolor{keywordflow}{for}\ (uint16\_t\ i\ =\ 0;\ i\ <\ capacity;\ i++)\ \{}
\DoxyCodeLine{00056\ \ \ \ \ \ \ sdu\_states[i].store(STATE\_FREE,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00057\ \ \ \ \ \}}
\DoxyCodeLine{00058\ }
\DoxyCodeLine{00059\ \ \ \ \ queue\ =\ std::make\_unique<}
\DoxyCodeLine{00060\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1concurrent__queue}{concurrent\_queue<rlc\_sdu,\ concurrent\_queue\_policy::lockfree\_spsc,\ concurrent\_queue\_wait\_policy::non\_blocking>}}>(}
\DoxyCodeLine{00061\ \ \ \ \ \ \ \ \ capacity);}
\DoxyCodeLine{00062\ \ \ \}}
\DoxyCodeLine{00063\ }
\DoxyCodeLine{00074\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a1a653b33da96f2caea9471794877464c}{write}}(\mbox{\hyperlink{structsrsran_1_1rlc__sdu}{rlc\_sdu}}\ sdu)}
\DoxyCodeLine{00075\ \ \ \{}
\DoxyCodeLine{00076\ \ \ \ \ \textcolor{comment}{//\ if\ the\ SDU\ has\ a\ PDCP\ SN,\ first\ check\ the\ slot\ is\ available}}
\DoxyCodeLine{00077\ \ \ \ \ \mbox{\hyperlink{classsrsran_1_1optional}{optional<uint32\_t>}}\ pdcp\_sn\ \ =\ sdu.pdcp\_sn;}
\DoxyCodeLine{00078\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ \ \ \ \ \ \ sdu\_size\ =\ sdu.buf.\mbox{\hyperlink{classsrsran_1_1byte__buffer_a7168fb8841a83a60b60a2ae06b59662d}{length}}();}
\DoxyCodeLine{00079\ \ \ \ \ \textcolor{keywordflow}{if}\ (pdcp\_sn.\mbox{\hyperlink{classsrsran_1_1optional_a2f160539a76c3f4dd0b50b339b81202e}{has\_value}}())\ \{}
\DoxyCodeLine{00080\ \ \ \ \ \ \ \textcolor{keyword}{const}\ uint32\_t\ pdcp\_sn\_value\ =\ sdu.pdcp\_sn.value();}
\DoxyCodeLine{00081\ \ \ \ \ \ \ \textcolor{comment}{//\ load\ slot\ state\ (memory\_order\_acquire\ ensures\ sdu\_size\ is\ written\ after\ this)}}
\DoxyCodeLine{00082\ \ \ \ \ \ \ uint32\_t\ slot\_state\ =\ sdu\_states[pdcp\_sn\_value\ \%\ capacity].load(std::memory\_order\_acquire);}
\DoxyCodeLine{00083\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (slot\_state\ !=\ STATE\_FREE)\ \{}
\DoxyCodeLine{00084\ \ \ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ failed\ to\ enqueue\ pdcp\_sn=\{\}.\ Slot\ holds\ pdcp\_sn=\{\}"{}},\ pdcp\_sn\_value,\ slot\_state);}
\DoxyCodeLine{00085\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00086\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00087\ }
\DoxyCodeLine{00088\ \ \ \ \ \ \ \textcolor{comment}{//\ slot\ is\ free,\ we\ can\ safely\ store\ the\ SDU\ size}}
\DoxyCodeLine{00089\ \ \ \ \ \ \ sdu\_sizes[pdcp\_sn\_value\ \%\ capacity].store(sdu\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00090\ }
\DoxyCodeLine{00091\ \ \ \ \ \ \ \textcolor{comment}{//\ allocate\ slot\ by\ writing\ the\ PDCP\ SN\ into\ it\ (memory\_order\_relaxed,\ don't\ care\ about\ order\ because\ of\ "{}release"{}}}
\DoxyCodeLine{00092\ \ \ \ \ \ \ \textcolor{comment}{//\ semantics\ of\ the\ push\ to\ queue)}}
\DoxyCodeLine{00093\ \ \ \ \ \ \ sdu\_states[pdcp\_sn\_value\ \%\ capacity].store(pdcp\_sn\_value,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00094\ \ \ \ \ \}}
\DoxyCodeLine{00095\ }
\DoxyCodeLine{00096\ \ \ \ \ \textcolor{comment}{//\ push\ SDU\ to\ queue}}
\DoxyCodeLine{00097\ \ \ \ \ \textcolor{keywordtype}{bool}\ pushed\ =\ queue-\/>try\_push(std::move(sdu));}
\DoxyCodeLine{00098\ \ \ \ \ \textcolor{keywordflow}{if}\ (not\ pushed)\ \{}
\DoxyCodeLine{00099\ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ failed\ to\ enqueue\ pdcp\_sn=\{\}.\ Queue\ is\ full"{}},\ pdcp\_sn);}
\DoxyCodeLine{00100\ \ \ \ \ \ \ \textcolor{comment}{//\ if\ the\ SDU\ has\ a\ PDCP\ SN,\ release\ the\ slot\ (memory\_order\_relaxed,\ don't\ care\ about\ value\ of\ sdu\_size)}}
\DoxyCodeLine{00101\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (pdcp\_sn.\mbox{\hyperlink{classsrsran_1_1optional_a2f160539a76c3f4dd0b50b339b81202e}{has\_value}}())\ \{}
\DoxyCodeLine{00102\ \ \ \ \ \ \ \ \ sdu\_states[pdcp\_sn.value()\ \%\ capacity].store(STATE\_FREE,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00103\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00104\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00105\ \ \ \ \ \}}
\DoxyCodeLine{00106\ }
\DoxyCodeLine{00107\ \ \ \ \ \textcolor{comment}{//\ update\ totals}}
\DoxyCodeLine{00108\ \ \ \ \ n\_sdus.fetch\_add(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00109\ \ \ \ \ n\_bytes.fetch\_add(sdu\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00110\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00111\ \ \ \}}
\DoxyCodeLine{00112\ }
\DoxyCodeLine{00127\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a5918fa48177cf34b10fef220c8fc719f}{try\_discard}}(uint32\_t\ pdcp\_sn)}
\DoxyCodeLine{00128\ \ \ \{}
\DoxyCodeLine{00129\ \ \ \ \ uint32\_t\ expected\_state\ =\ pdcp\_sn;}
\DoxyCodeLine{00130\ \ \ \ \ uint32\_t\ desired\_state\ \ =\ STATE\_DISCARDED;}
\DoxyCodeLine{00131\ \ \ \ \ \textcolor{comment}{//\ set\ slot\ state\ as\ "{}discarded"{}\ only\ if\ it\ holds\ the\ PDCP\ SN;\ otherwise\ load\ the\ existing\ state}}
\DoxyCodeLine{00132\ \ \ \ \ \textcolor{comment}{//\ -\/\ on\ success:\ memory\_order\_acquire\ ensures\ sdu\_size\ is\ up\ to\ date}}
\DoxyCodeLine{00133\ \ \ \ \ \textcolor{comment}{//\ -\/\ on\ failure:\ memory\_order\_relaxed,\ don't\ care\ about\ value\ of\ sdu\_size}}
\DoxyCodeLine{00134\ \ \ \ \ \textcolor{keywordtype}{bool}\ success\ =\ sdu\_states[pdcp\_sn\ \%\ capacity].compare\_exchange\_strong(}
\DoxyCodeLine{00135\ \ \ \ \ \ \ \ \ expected\_state,\ desired\_state,\ std::memory\_order\_acquire,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00136\ \ \ \ \ uint32\_t\ sdu\_size\ =\ sdu\_sizes[pdcp\_sn\ \%\ capacity].load(std::memory\_order\_relaxed);}
\DoxyCodeLine{00137\ }
\DoxyCodeLine{00138\ \ \ \ \ \textcolor{keywordflow}{if}\ (not\ success)\ \{}
\DoxyCodeLine{00139\ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (expected\_state)\ \{}
\DoxyCodeLine{00140\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ STATE\_DISCARDED:}
\DoxyCodeLine{00141\ \ \ \ \ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ cannot\ discard\ pdcp\_sn=\{\}.\ Slot\ is\ already\ discarded"{}},\ pdcp\_sn);}
\DoxyCodeLine{00142\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00143\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ STATE\_FREE:}
\DoxyCodeLine{00144\ \ \ \ \ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ cannot\ discard\ pdcp\_sn=\{\}.\ Slot\ is\ already\ free"{}},\ pdcp\_sn);}
\DoxyCodeLine{00145\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00146\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00147\ \ \ \ \ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ cannot\ discard\ pdcp\_sn=\{\}.\ Slot\ holds\ pdcp\_sn=\{\}"{}},\ pdcp\_sn,\ expected\_state);}
\DoxyCodeLine{00148\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00149\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00150\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00151\ \ \ \ \ \}}
\DoxyCodeLine{00152\ }
\DoxyCodeLine{00153\ \ \ \ \ \textcolor{comment}{//\ update\ totals}}
\DoxyCodeLine{00154\ \ \ \ \ n\_sdus.fetch\_sub(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00155\ \ \ \ \ n\_bytes.fetch\_sub(sdu\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00156\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00157\ \ \ \}}
\DoxyCodeLine{00158\ }
\DoxyCodeLine{00172\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a5b2d6733746aaf17fd87a0743ba52501}{read}}(\mbox{\hyperlink{structsrsran_1_1rlc__sdu}{rlc\_sdu}}\&\ sdu)}
\DoxyCodeLine{00173\ \ \ \{}
\DoxyCodeLine{00174\ \ \ \ \ \textcolor{keywordtype}{bool}\ sdu\_is\_valid\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00175\ \ \ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{00176\ \ \ \ \ \ \ \textcolor{comment}{//\ first\ try\ to\ pop\ front\ (SDU\ can\ still\ get\ discarded\ from\ upper\ layers)}}
\DoxyCodeLine{00177\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ popped\ =\ queue-\/>try\_pop(sdu);}
\DoxyCodeLine{00178\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (not\ popped)\ \{}
\DoxyCodeLine{00179\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ queue\ is\ empty}}
\DoxyCodeLine{00180\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00181\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00182\ }
\DoxyCodeLine{00183\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (sdu.pdcp\_sn.\mbox{\hyperlink{classsrsran_1_1optional_a2f160539a76c3f4dd0b50b339b81202e}{has\_value}}())\ \{}
\DoxyCodeLine{00184\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Check\ if\ the\ SDU\ is\ still\ valid\ (i.e.\ the\ PDCP\ SN\ was\ not\ already\ discarded)\ and\ release\ the\ slot}}
\DoxyCodeLine{00185\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ uint32\_t\ pdcp\_sn\ =\ sdu.pdcp\_sn.value();}
\DoxyCodeLine{00186\ \ \ \ \ \ \ \ \ sdu\_is\_valid\ \ \ \ \ \ \ \ \ \ \ =\ check\_and\_release(pdcp\_sn);\ \textcolor{comment}{//\ this\ also\ updates\ totals}}
\DoxyCodeLine{00187\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00188\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ SDUs\ without\ PDCP\ SN\ are\ alway\ valid\ as\ they\ can't\ be\ discarded}}
\DoxyCodeLine{00189\ \ \ \ \ \ \ \ \ sdu\_is\_valid\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00190\ }
\DoxyCodeLine{00191\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ update\ totals}}
\DoxyCodeLine{00192\ \ \ \ \ \ \ \ \ n\_sdus.fetch\_sub(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00193\ \ \ \ \ \ \ \ \ n\_bytes.fetch\_sub(sdu.buf.\mbox{\hyperlink{classsrsran_1_1byte__buffer_a7168fb8841a83a60b60a2ae06b59662d}{length}}(),\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00194\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00195\ \ \ \ \ \ \ \textcolor{comment}{//\ try\ again\ if\ SDU\ is\ not\ valid}}
\DoxyCodeLine{00196\ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (not\ sdu\_is\_valid);}
\DoxyCodeLine{00197\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00198\ \ \ \}}
\DoxyCodeLine{00199\ }
\DoxyCodeLine{00205\ \ \ uint32\_t\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a4c4aca80a693e78a7030d130e1116c09}{size\_sdus}}()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ n\_sdus.load(std::memory\_order\_relaxed);\ \}}
\DoxyCodeLine{00206\ }
\DoxyCodeLine{00212\ \ \ uint32\_t\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_ab2d800cfef5a9542f480da984fc3e2d0}{size\_bytes}}()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ n\_bytes.load(std::memory\_order\_relaxed);\ \}}
\DoxyCodeLine{00213\ }
\DoxyCodeLine{00219\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a7ba1e310d8d662703f2922303c627a7a}{is\_empty}}()\ \{\ \textcolor{keywordflow}{return}\ queue-\/>empty();\ \}}
\DoxyCodeLine{00220\ }
\DoxyCodeLine{00226\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a68ac4760854df275260a793d0c71cf99}{is\_full}}()\ \{\ \textcolor{keywordflow}{return}\ queue-\/>size()\ >=\ capacity;\ \}}
\DoxyCodeLine{00227\ }
\DoxyCodeLine{00228\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00243\ \ \ \textcolor{keywordtype}{bool}\ check\_and\_release(uint32\_t\ pdcp\_sn)}
\DoxyCodeLine{00244\ \ \ \{}
\DoxyCodeLine{00245\ \ \ \ \ uint32\_t\ sdu\_size\ =\ sdu\_sizes[pdcp\_sn\ \%\ capacity].load(std::memory\_order\_relaxed);}
\DoxyCodeLine{00246\ \ \ \ \ \textcolor{comment}{//\ free\ the\ slot\ (memory\_order\_release\ ensures\ sdu\_size\ is\ read\ before\ the\ state\ is\ set\ to\ free)}}
\DoxyCodeLine{00247\ \ \ \ \ uint32\_t\ old\_state\ =\ sdu\_states[pdcp\_sn\ \%\ capacity].exchange(STATE\_FREE,\ std::memory\_order\_release);}
\DoxyCodeLine{00248\ }
\DoxyCodeLine{00249\ \ \ \ \ \textcolor{keywordtype}{bool}\ sdu\_is\_valid;}
\DoxyCodeLine{00250\ \ \ \ \ \textcolor{keywordflow}{if}\ (old\_state\ ==\ pdcp\_sn)\ \{}
\DoxyCodeLine{00251\ \ \ \ \ \ \ sdu\_is\_valid\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00252\ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ released\ valid\ pdcp\_sn=\{\}"{}},\ pdcp\_sn);}
\DoxyCodeLine{00253\ \ \ \ \ \}}
\DoxyCodeLine{00254\ \ \ \ \ \textcolor{keywordflow}{if}\ (old\_state\ !=\ pdcp\_sn)\ \{}
\DoxyCodeLine{00255\ \ \ \ \ \ \ sdu\_is\_valid\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00256\ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (old\_state)\ \{}
\DoxyCodeLine{00257\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ STATE\_DISCARDED:}
\DoxyCodeLine{00258\ \ \ \ \ \ \ \ \ \ \ logger.log\_debug(\textcolor{stringliteral}{"{}SDU\ queue\ released\ discarded\ pdcp\_sn=\{\}"{}},\ pdcp\_sn);}
\DoxyCodeLine{00259\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};\ \textcolor{comment}{//\ totals\ were\ already\ updated\ on\ discard}}
\DoxyCodeLine{00260\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ STATE\_FREE:}
\DoxyCodeLine{00261\ \ \ \ \ \ \ \ \ \ \ logger.log\_error(\textcolor{stringliteral}{"{}SDU\ queue\ error:\ Invalid\ release\ of\ pdcp\_sn=\{\}.\ Slot\ was\ already\ free"{}},\ pdcp\_sn);}
\DoxyCodeLine{00262\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00263\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00264\ \ \ \ \ \ \ \ \ \ \ logger.log\_error(\textcolor{stringliteral}{"{}SDU\ queue\ error:\ Invalid\ release\ of\ pdcp\_sn=\{\}.\ Slot\ holds\ pdcp\_sn=\{\}"{}},\ pdcp\_sn,\ old\_state);}
\DoxyCodeLine{00265\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00266\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00267\ \ \ \ \ \}}
\DoxyCodeLine{00268\ }
\DoxyCodeLine{00269\ \ \ \ \ \textcolor{comment}{//\ update\ totals}}
\DoxyCodeLine{00270\ \ \ \ \ n\_sdus.fetch\_sub(1,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00271\ \ \ \ \ n\_bytes.fetch\_sub(sdu\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00272\ \ \ \ \ \textcolor{keywordflow}{return}\ sdu\_is\_valid;}
\DoxyCodeLine{00273\ \ \ \}}
\DoxyCodeLine{00274\ }
\DoxyCodeLine{00275\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ uint32\_t\ STATE\_FREE\ \ \ \ \ \ =\ 0xffffffff;\ }
\DoxyCodeLine{00276\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ uint32\_t\ STATE\_DISCARDED\ =\ 0xfffffffe;\ }
\DoxyCodeLine{00277\ }
\DoxyCodeLine{00278\ \ \ rlc\_bearer\_logger\&\ logger;}
\DoxyCodeLine{00279\ }
\DoxyCodeLine{00280\ \ \ uint16\_t\ \ \ \ \ \ \ \ \ \ \ \ \ \ capacity;}
\DoxyCodeLine{00281\ \ \ std::atomic<uint32\_t>\ n\_bytes\ =\ \{0\};}
\DoxyCodeLine{00282\ \ \ std::atomic<uint32\_t>\ n\_sdus\ \ =\ \{0\};}
\DoxyCodeLine{00283\ }
\DoxyCodeLine{00284\ \ \ std::unique\_ptr<}
\DoxyCodeLine{00285\ \ \ \ \ \ \ concurrent\_queue<rlc\_sdu,\ concurrent\_queue\_policy::lockfree\_spsc,\ concurrent\_queue\_wait\_policy::non\_blocking>>}
\DoxyCodeLine{00286\ \ \ \ \ \ \ queue;}
\DoxyCodeLine{00287\ }
\DoxyCodeLine{00288\ \ \ std::unique\_ptr<std::atomic<uint32\_t>[]>\ sdu\_states;}
\DoxyCodeLine{00289\ \ \ std::unique\_ptr<std::atomic<size\_t>[]>\ \ \ sdu\_sizes;}
\DoxyCodeLine{00290\ \};}
\DoxyCodeLine{00291\ }
\DoxyCodeLine{00292\ \}\ \textcolor{comment}{//\ namespace\ srsran}}
\DoxyCodeLine{00293\ }
\DoxyCodeLine{00294\ \textcolor{keyword}{namespace\ }fmt\ \{}
\DoxyCodeLine{00295\ \textcolor{keyword}{template}\ <>}
\DoxyCodeLine{00296\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structformatter}{formatter}}<\mbox{\hyperlink{namespacesrsran}{srsran}}::rlc\_sdu\_queue\_lockfree>\ \{}
\DoxyCodeLine{00297\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ParseContext>}
\DoxyCodeLine{00298\ \ \ \textcolor{keyword}{auto}\ parse(ParseContext\&\ ctx)\ -\/>\ \textcolor{keyword}{decltype}(ctx.begin())}
\DoxyCodeLine{00299\ \ \ \{}
\DoxyCodeLine{00300\ \ \ \ \ \textcolor{keywordflow}{return}\ ctx.begin();}
\DoxyCodeLine{00301\ \ \ \}}
\DoxyCodeLine{00302\ }
\DoxyCodeLine{00303\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FormatContext>}
\DoxyCodeLine{00304\ \ \ \textcolor{keyword}{auto}\ format(\textcolor{keyword}{const}\ \mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree}{srsran::rlc\_sdu\_queue\_lockfree}}\&\ q,\ FormatContext\&\ ctx)}
\DoxyCodeLine{00305\ \ \ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(std::declval<FormatContext>().out())}
\DoxyCodeLine{00306\ \ \ \{}
\DoxyCodeLine{00307\ \ \ \ \ \textcolor{keywordflow}{return}\ format\_to(ctx.out(),\ \textcolor{stringliteral}{"{}queued\_sdus=\{\}\ queued\_bytes=\{\}"{}},\ q.\mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_a4c4aca80a693e78a7030d130e1116c09}{size\_sdus}}(),\ q.\mbox{\hyperlink{classsrsran_1_1rlc__sdu__queue__lockfree_ab2d800cfef5a9542f480da984fc3e2d0}{size\_bytes}}());}
\DoxyCodeLine{00308\ \ \ \}}
\DoxyCodeLine{00309\ \};}
\DoxyCodeLine{00310\ }
\DoxyCodeLine{00311\ \}\ \textcolor{comment}{//\ namespace\ fmt}}

\end{DoxyCode}
