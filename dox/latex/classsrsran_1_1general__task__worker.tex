\doxysection{srsran\+::general\+\_\+task\+\_\+worker\texorpdfstring{$<$}{<} Queue\+Policy, Wait\+Policy \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classsrsran_1_1general__task__worker}{}\label{classsrsran_1_1general__task__worker}\index{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$@{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$}}


Single thread worker with a locking MPSC input task queue. This worker type is ideal for the cases where there is low contention between task producers.  




{\ttfamily \#include $<$task\+\_\+worker.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$\mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} W = Wait\+Policy, std\+::enable\+\_\+if\+\_\+t$<$ W==concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::condition\+\_\+variable, int $>$  = 0$>$ }\\\mbox{\hyperlink{classsrsran_1_1general__task__worker_afe8228780fee476a55d205a20d60f797}{general\+\_\+task\+\_\+worker}} (std\+::string thread\+\_\+name, unsigned queue\+\_\+size, \mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority}{os\+\_\+thread\+\_\+realtime\+\_\+priority}} prio=\mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority_af2cf72da038c74badffd988ce6a08e46}{os\+\_\+thread\+\_\+realtime\+\_\+priority\+::no\+\_\+realtime}}(), const \mbox{\hyperlink{structsrsran_1_1os__sched__affinity__bitmask}{os\+\_\+sched\+\_\+affinity\+\_\+bitmask}} \&\mbox{\hyperlink{namespacesrsran_ad24c439c1013fdd70334019fc3d1d1fbaf2ce11ebf110993621bedd8e747d7b1b}{mask}}=\{\})
\begin{DoxyCompactList}\small\item\em Creates a task worker instance that uses a condition variable to notify pushes of new tasks. \end{DoxyCompactList}\item 
{\footnotesize template$<$\mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} W = Wait\+Policy, std\+::enable\+\_\+if\+\_\+t$<$ W==concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::sleep, int $>$  = 0$>$ }\\\mbox{\hyperlink{classsrsran_1_1general__task__worker_aabf92a2ad956c95166e3f6589bd7150b}{general\+\_\+task\+\_\+worker}} (std\+::string thread\+\_\+name, unsigned queue\+\_\+size, std\+::chrono\+::microseconds wait\+\_\+sleep\+\_\+time, \mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority}{os\+\_\+thread\+\_\+realtime\+\_\+priority}} prio=\mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority_af2cf72da038c74badffd988ce6a08e46}{os\+\_\+thread\+\_\+realtime\+\_\+priority\+::no\+\_\+realtime}}(), const \mbox{\hyperlink{structsrsran_1_1os__sched__affinity__bitmask}{os\+\_\+sched\+\_\+affinity\+\_\+bitmask}} \&\mbox{\hyperlink{namespacesrsran_ad24c439c1013fdd70334019fc3d1d1fbaf2ce11ebf110993621bedd8e747d7b1b}{mask}}=\{\})
\begin{DoxyCompactList}\small\item\em Creates a task worker instance that uses a condition variable to notify pushes of new tasks. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1general__task__worker_aa60c441f80e09120745b0131655fb258}\label{classsrsran_1_1general__task__worker_aa60c441f80e09120745b0131655fb258} 
{\bfseries general\+\_\+task\+\_\+worker} (const \mbox{\hyperlink{classsrsran_1_1general__task__worker}{general\+\_\+task\+\_\+worker}} \&)=delete
\item 
\Hypertarget{classsrsran_1_1general__task__worker_ad408bc68e43f564e4bc041dea10c7a30}\label{classsrsran_1_1general__task__worker_ad408bc68e43f564e4bc041dea10c7a30} 
{\bfseries general\+\_\+task\+\_\+worker} (\mbox{\hyperlink{classsrsran_1_1general__task__worker}{general\+\_\+task\+\_\+worker}} \&\&)=delete
\item 
\Hypertarget{classsrsran_1_1general__task__worker_a02d2153da65fdf50837f6655326c7910}\label{classsrsran_1_1general__task__worker_a02d2153da65fdf50837f6655326c7910} 
\mbox{\hyperlink{classsrsran_1_1general__task__worker}{general\+\_\+task\+\_\+worker}} \& {\bfseries operator=} (const \mbox{\hyperlink{classsrsran_1_1general__task__worker}{general\+\_\+task\+\_\+worker}} \&)=delete
\item 
\Hypertarget{classsrsran_1_1general__task__worker_a9a5b192d2369347e473c35336d658387}\label{classsrsran_1_1general__task__worker_a9a5b192d2369347e473c35336d658387} 
\mbox{\hyperlink{classsrsran_1_1general__task__worker}{general\+\_\+task\+\_\+worker}} \& {\bfseries operator=} (\mbox{\hyperlink{classsrsran_1_1general__task__worker}{general\+\_\+task\+\_\+worker}} \&\&)=delete
\item 
\Hypertarget{classsrsran_1_1general__task__worker_a5854f9ea03b5592f87f3bbdfbba17edc}\label{classsrsran_1_1general__task__worker_a5854f9ea03b5592f87f3bbdfbba17edc} 
void {\bfseries stop} ()
\begin{DoxyCompactList}\small\item\em Stop task worker, if running. \end{DoxyCompactList}\item 
\mbox{\hyperlink{compiler_8h_a84270d7b45f0280051bd27685657e03e}{SRSRAN\+\_\+\+NODISCARD}} bool \mbox{\hyperlink{classsrsran_1_1general__task__worker_ad8a2f53181eee17a52f231f1cd73eed8}{push\+\_\+task}} (\mbox{\hyperlink{classsrsran_1_1unique__function}{task\+\_\+t}} \&\&task)
\begin{DoxyCompactList}\small\item\em Push a new task to FIFO to be processed by the task worker. If the task FIFO is full, enqueueing fails. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1general__task__worker_a4234eab02e6d076ed51c3ae4debed0cb}\label{classsrsran_1_1general__task__worker_a4234eab02e6d076ed51c3ae4debed0cb} 
void {\bfseries push\+\_\+task\+\_\+blocking} (\mbox{\hyperlink{classsrsran_1_1unique__function}{task\+\_\+t}} \&\&task)
\begin{DoxyCompactList}\small\item\em Push a new task to FIFO to be processed by the task worker. If the task FIFO is full, this call blocks, until the FIFO has space to enqueue the task. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1general__task__worker_a4be630c0aab42c483e48056b2866258f}\label{classsrsran_1_1general__task__worker_a4be630c0aab42c483e48056b2866258f} 
void {\bfseries wait\+\_\+pending\+\_\+tasks} ()
\begin{DoxyCompactList}\small\item\em Wait for all the currently enqueued tasks to complete. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1general__task__worker_a33f90259b8bbfcd0480d6abcb5e5c677}\label{classsrsran_1_1general__task__worker_a33f90259b8bbfcd0480d6abcb5e5c677} 
unsigned {\bfseries nof\+\_\+pending\+\_\+tasks} () const
\begin{DoxyCompactList}\small\item\em Number of pending tasks. It requires locking mutex. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1general__task__worker_adb079942b2c16d3e2a657556a406b71a}\label{classsrsran_1_1general__task__worker_adb079942b2c16d3e2a657556a406b71a} 
unsigned {\bfseries max\+\_\+pending\+\_\+tasks} () const
\begin{DoxyCompactList}\small\item\em Maximum number of pending tasks the task FIFO can hold. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1general__task__worker_aef133f3f020336d759d68bb4a51e2149}\label{classsrsran_1_1general__task__worker_aef133f3f020336d759d68bb4a51e2149} 
std\+::thread\+::id {\bfseries get\+\_\+id} () const
\begin{DoxyCompactList}\small\item\em Get worker thread id. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1general__task__worker_aa2ef57fd194c6abad6a1e95a30089850}\label{classsrsran_1_1general__task__worker_aa2ef57fd194c6abad6a1e95a30089850} 
const char \texorpdfstring{$\ast$}{*} {\bfseries worker\+\_\+name} () const
\begin{DoxyCompactList}\small\item\em Get worker thread name. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$\mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Queue\+Policy = concurrent\+\_\+queue\+\_\+policy\+::locking\+\_\+mpsc, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Wait\+Policy = concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::condition\+\_\+variable$>$\newline
class srsran\+::general\+\_\+task\+\_\+worker$<$ Queue\+Policy, Wait\+Policy $>$}
Single thread worker with a locking MPSC input task queue. This worker type is ideal for the cases where there is low contention between task producers. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classsrsran_1_1general__task__worker_afe8228780fee476a55d205a20d60f797}\label{classsrsran_1_1general__task__worker_afe8228780fee476a55d205a20d60f797} 
\index{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$@{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$}!general\_task\_worker@{general\_task\_worker}}
\index{general\_task\_worker@{general\_task\_worker}!srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$@{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$}}
\doxysubsubsection{\texorpdfstring{general\_task\_worker()}{general\_task\_worker()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Queue\+Policy = concurrent\+\_\+queue\+\_\+policy\+::locking\+\_\+mpsc, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Wait\+Policy = concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::condition\+\_\+variable$>$ \\
template$<$\mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} W = Wait\+Policy, std\+::enable\+\_\+if\+\_\+t$<$ W==concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::condition\+\_\+variable, int $>$  = 0$>$ \\
\mbox{\hyperlink{classsrsran_1_1general__task__worker}{srsran\+::general\+\_\+task\+\_\+worker}}$<$ Queue\+Policy, Wait\+Policy $>$\+::general\+\_\+task\+\_\+worker (\begin{DoxyParamCaption}\item[{std\+::string}]{thread\+\_\+name,  }\item[{unsigned}]{queue\+\_\+size,  }\item[{\mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority}{os\+\_\+thread\+\_\+realtime\+\_\+priority}}}]{prio = {\ttfamily \mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority_af2cf72da038c74badffd988ce6a08e46}{os\+\_\+thread\+\_\+realtime\+\_\+priority\+::no\+\_\+realtime}}()},  }\item[{const \mbox{\hyperlink{structsrsran_1_1os__sched__affinity__bitmask}{os\+\_\+sched\+\_\+affinity\+\_\+bitmask}} \&}]{mask = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a task worker instance that uses a condition variable to notify pushes of new tasks. 


\begin{DoxyParams}{Parameters}
{\em thread\+\_\+name} & Name of the thread instantiated by this task worker. \\
\hline
{\em queue\+\_\+size} & Number of pending tasks that this task worker can hold. \\
\hline
{\em prio} & OS thread realtime priority. \\
\hline
{\em mask} & OS scheduler thread affinity mask. \\
\hline
\end{DoxyParams}
\Hypertarget{classsrsran_1_1general__task__worker_aabf92a2ad956c95166e3f6589bd7150b}\label{classsrsran_1_1general__task__worker_aabf92a2ad956c95166e3f6589bd7150b} 
\index{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$@{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$}!general\_task\_worker@{general\_task\_worker}}
\index{general\_task\_worker@{general\_task\_worker}!srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$@{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$}}
\doxysubsubsection{\texorpdfstring{general\_task\_worker()}{general\_task\_worker()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Queue\+Policy = concurrent\+\_\+queue\+\_\+policy\+::locking\+\_\+mpsc, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Wait\+Policy = concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::condition\+\_\+variable$>$ \\
template$<$\mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} W = Wait\+Policy, std\+::enable\+\_\+if\+\_\+t$<$ W==concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::sleep, int $>$  = 0$>$ \\
\mbox{\hyperlink{classsrsran_1_1general__task__worker}{srsran\+::general\+\_\+task\+\_\+worker}}$<$ Queue\+Policy, Wait\+Policy $>$\+::general\+\_\+task\+\_\+worker (\begin{DoxyParamCaption}\item[{std\+::string}]{thread\+\_\+name,  }\item[{unsigned}]{queue\+\_\+size,  }\item[{std\+::chrono\+::microseconds}]{wait\+\_\+sleep\+\_\+time,  }\item[{\mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority}{os\+\_\+thread\+\_\+realtime\+\_\+priority}}}]{prio = {\ttfamily \mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority_af2cf72da038c74badffd988ce6a08e46}{os\+\_\+thread\+\_\+realtime\+\_\+priority\+::no\+\_\+realtime}}()},  }\item[{const \mbox{\hyperlink{structsrsran_1_1os__sched__affinity__bitmask}{os\+\_\+sched\+\_\+affinity\+\_\+bitmask}} \&}]{mask = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a task worker instance that uses a condition variable to notify pushes of new tasks. 


\begin{DoxyParams}{Parameters}
{\em thread\+\_\+name} & Name of the thread instantiated by this task worker. \\
\hline
{\em queue\+\_\+size} & Number of pending tasks that this task worker can hold. \\
\hline
{\em wait\+\_\+sleep\+\_\+time} & Time the worker spends sleeping when there are no enqueued tasks. \\
\hline
{\em prio} & OS thread realtime priority. \\
\hline
{\em mask} & OS scheduler thread affinity mask. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{classsrsran_1_1general__task__worker_ad8a2f53181eee17a52f231f1cd73eed8}\label{classsrsran_1_1general__task__worker_ad8a2f53181eee17a52f231f1cd73eed8} 
\index{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$@{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$}!push\_task@{push\_task}}
\index{push\_task@{push\_task}!srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$@{srsran::general\_task\_worker$<$ QueuePolicy, WaitPolicy $>$}}
\doxysubsubsection{\texorpdfstring{push\_task()}{push\_task()}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{namespacesrsran_a08f31ae01c088c535705650443feec0c}{concurrent\+\_\+queue\+\_\+policy}} Queue\+Policy = concurrent\+\_\+queue\+\_\+policy\+::locking\+\_\+mpsc, \mbox{\hyperlink{namespacesrsran_a1aa5b9ae2fbb3e003686513bd761c0a4}{concurrent\+\_\+queue\+\_\+wait\+\_\+policy}} Wait\+Policy = concurrent\+\_\+queue\+\_\+wait\+\_\+policy\+::condition\+\_\+variable$>$ \\
\mbox{\hyperlink{compiler_8h_a84270d7b45f0280051bd27685657e03e}{SRSRAN\+\_\+\+NODISCARD}} bool \mbox{\hyperlink{classsrsran_1_1general__task__worker}{srsran\+::general\+\_\+task\+\_\+worker}}$<$ Queue\+Policy, Wait\+Policy $>$\+::push\+\_\+task (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsrsran_1_1unique__function}{task\+\_\+t}} \&\&}]{task }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Push a new task to FIFO to be processed by the task worker. If the task FIFO is full, enqueueing fails. 

\begin{DoxyReturn}{Returns}
true if task was successfully enqueued. False if task FIFO was full. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/srsran/support/executors/task\+\_\+worker.\+h\item 
lib/support/executors/task\+\_\+worker.\+cpp\end{DoxyCompactItemize}
