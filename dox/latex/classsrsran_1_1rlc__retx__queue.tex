\doxysection{srsran\+::rlc\+\_\+retx\+\_\+queue Class Reference}
\hypertarget{classsrsran_1_1rlc__retx__queue}{}\label{classsrsran_1_1rlc__retx__queue}\index{srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsrsran_1_1rlc__retx__queue_ae4a34fa65b922222bb9ea2370f8545ff}\label{classsrsran_1_1rlc__retx__queue_ae4a34fa65b922222bb9ea2370f8545ff} 
{\bfseries rlc\+\_\+retx\+\_\+queue} (size\+\_\+t capacity)
\item 
bool \mbox{\hyperlink{classsrsran_1_1rlc__retx__queue_a7741fbc6f94d04570bb6e1f5c2bfd736}{try\+\_\+push}} (const \mbox{\hyperlink{structsrsran_1_1rlc__tx__amd__retx}{rlc\+\_\+tx\+\_\+amd\+\_\+retx}} \&retx)
\begin{DoxyCompactList}\small\item\em Tries to push a Re\+Tx to the queue. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1rlc__retx__queue_acdbf994801b211ef036133cdfffc537e}\label{classsrsran_1_1rlc__retx__queue_acdbf994801b211ef036133cdfffc537e} 
void {\bfseries pop} ()
\begin{DoxyCompactList}\small\item\em Removes the first element from the front together with any following invalid elements such that front is either a valid element or the queue is empty. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{structsrsran_1_1rlc__tx__amd__retx}{rlc\+\_\+tx\+\_\+amd\+\_\+retx}} \& \mbox{\hyperlink{classsrsran_1_1rlc__retx__queue_a26dc77688e90caf1aa10ef6da4164298}{front}} () const
\begin{DoxyCompactList}\small\item\em Access the first valid element of the queue unless the queue is empty. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classsrsran_1_1rlc__retx__queue_a96503d2319022f117b851c7a130de56b}{replace\+\_\+front}} (const \mbox{\hyperlink{structsrsran_1_1rlc__tx__amd__retx}{rlc\+\_\+tx\+\_\+amd\+\_\+retx}} \&retx)
\begin{DoxyCompactList}\small\item\em Replaces the first valid element of the queue. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1rlc__retx__queue_af2976c5644f936cf2a01edddec5db543}\label{classsrsran_1_1rlc__retx__queue_af2976c5644f936cf2a01edddec5db543} 
void {\bfseries clear} ()
\begin{DoxyCompactList}\small\item\em Clear the container and reset state to the initial state. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classsrsran_1_1rlc__retx__queue_a484070008d093c081e44bd88a41c3acd}{size}} () const
\begin{DoxyCompactList}\small\item\em Total number of elements (valid + invalid) in the queue. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classsrsran_1_1rlc__retx__queue_a778792b878a76c69aec610429a6f243d}{empty}} () const
\begin{DoxyCompactList}\small\item\em Checks the presence of at least one valid element. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classsrsran_1_1rlc__retx__queue__state}{rlc\+\_\+retx\+\_\+queue\+\_\+state}} \mbox{\hyperlink{classsrsran_1_1rlc__retx__queue_a41a054d271901433a6844d6740f2cd64}{state}} () const
\begin{DoxyCompactList}\small\item\em Access to the internal state of the queue. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classsrsran_1_1rlc__retx__queue_a6494bee31fca36ba6448fe1bafb0e10f}{has\+\_\+sn}} (uint32\+\_\+t sn) const
\item 
bool \mbox{\hyperlink{classsrsran_1_1rlc__retx__queue_a430aff019b144c1e1722c8cb3bbca314}{has\+\_\+sn}} (uint32\+\_\+t sn, uint32\+\_\+t so, uint32\+\_\+t length) const
\item 
bool \mbox{\hyperlink{classsrsran_1_1rlc__retx__queue_a6820aedd320db49e258231371fcc6cfa}{remove\+\_\+sn}} (uint32\+\_\+t sn)
\begin{DoxyCompactList}\small\item\em Removes all elements with a given SN from queue and removes any invalid elements at the front. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1rlc__retx__queue_a853031c6354dc22e697ffe8b4b60f224}\label{classsrsran_1_1rlc__retx__queue_a853031c6354dc22e697ffe8b4b60f224} 
void {\bfseries clean\+\_\+invalid\+\_\+front} ()
\begin{DoxyCompactList}\small\item\em Advances the front of the queue to the first valid element or to the end of the queue. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\Hypertarget{classsrsran_1_1rlc__retx__queue_a778792b878a76c69aec610429a6f243d}\label{classsrsran_1_1rlc__retx__queue_a778792b878a76c69aec610429a6f243d} 
\index{srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}!empty@{empty}}
\index{empty@{empty}!srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily bool srsran\+::rlc\+\_\+retx\+\_\+queue\+::empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Checks the presence of at least one valid element. 

\begin{DoxyReturn}{Returns}
True if no valid element is queued; False if at least one valid element is queued. 
\end{DoxyReturn}
\Hypertarget{classsrsran_1_1rlc__retx__queue_a26dc77688e90caf1aa10ef6da4164298}\label{classsrsran_1_1rlc__retx__queue_a26dc77688e90caf1aa10ef6da4164298} 
\index{srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}!front@{front}}
\index{front@{front}!srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}}
\doxysubsubsection{\texorpdfstring{front()}{front()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{structsrsran_1_1rlc__tx__amd__retx}{rlc\+\_\+tx\+\_\+amd\+\_\+retx}} \& srsran\+::rlc\+\_\+retx\+\_\+queue\+::front (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Access the first valid element of the queue unless the queue is empty. 

\begin{DoxyReturn}{Returns}
First valid element in the queue 
\end{DoxyReturn}
\Hypertarget{classsrsran_1_1rlc__retx__queue_a6494bee31fca36ba6448fe1bafb0e10f}\label{classsrsran_1_1rlc__retx__queue_a6494bee31fca36ba6448fe1bafb0e10f} 
\index{srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}!has\_sn@{has\_sn}}
\index{has\_sn@{has\_sn}!srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}}
\doxysubsubsection{\texorpdfstring{has\_sn()}{has\_sn()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool srsran\+::rlc\+\_\+retx\+\_\+queue\+::has\+\_\+sn (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{sn }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Checks if the queue contains an element with a given SN. 
\begin{DoxyParams}{Parameters}
{\em sn} & The sequence number to look up. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if queue contains the SN, false otherwise. 
\end{DoxyReturn}
\Hypertarget{classsrsran_1_1rlc__retx__queue_a430aff019b144c1e1722c8cb3bbca314}\label{classsrsran_1_1rlc__retx__queue_a430aff019b144c1e1722c8cb3bbca314} 
\index{srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}!has\_sn@{has\_sn}}
\index{has\_sn@{has\_sn}!srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}}
\doxysubsubsection{\texorpdfstring{has\_sn()}{has\_sn()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool srsran\+::rlc\+\_\+retx\+\_\+queue\+::has\+\_\+sn (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{sn,  }\item[{uint32\+\_\+t}]{so,  }\item[{uint32\+\_\+t}]{length }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Checks if the queue contains an element with a given SN and also includes a specified segment interval given by a segment offset and segment length. 
\begin{DoxyParams}{Parameters}
{\em sn} & The sequence number to look up. \\
\hline
{\em so} & The segment offset to check. \\
\hline
{\em length} & The segment length to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if queue contains the SN and the element includes the given segment interval, false otherwise. 
\end{DoxyReturn}
\Hypertarget{classsrsran_1_1rlc__retx__queue_a6820aedd320db49e258231371fcc6cfa}\label{classsrsran_1_1rlc__retx__queue_a6820aedd320db49e258231371fcc6cfa} 
\index{srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}!remove\_sn@{remove\_sn}}
\index{remove\_sn@{remove\_sn}!srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}}
\doxysubsubsection{\texorpdfstring{remove\_sn()}{remove\_sn()}}
{\footnotesize\ttfamily bool srsran\+::rlc\+\_\+retx\+\_\+queue\+::remove\+\_\+sn (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{sn }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes all elements with a given SN from queue and removes any invalid elements at the front. 

The Re\+Tx for matching SN will be marked as invalid and its content will be subtracted from the state. Subsequently, any invalid elements are removed from the front.


\begin{DoxyParams}{Parameters}
{\em sn} & sequence number to be removed from queue. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if at least one element was removed, false if no element to remove was found. 
\end{DoxyReturn}
\Hypertarget{classsrsran_1_1rlc__retx__queue_a96503d2319022f117b851c7a130de56b}\label{classsrsran_1_1rlc__retx__queue_a96503d2319022f117b851c7a130de56b} 
\index{srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}!replace\_front@{replace\_front}}
\index{replace\_front@{replace\_front}!srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}}
\doxysubsubsection{\texorpdfstring{replace\_front()}{replace\_front()}}
{\footnotesize\ttfamily void srsran\+::rlc\+\_\+retx\+\_\+queue\+::replace\+\_\+front (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structsrsran_1_1rlc__tx__amd__retx}{rlc\+\_\+tx\+\_\+amd\+\_\+retx}} \&}]{retx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replaces the first valid element of the queue. 


\begin{DoxyParams}{Parameters}
{\em retx} & The Re\+Tx to be written. \\
\hline
\end{DoxyParams}
\Hypertarget{classsrsran_1_1rlc__retx__queue_a484070008d093c081e44bd88a41c3acd}\label{classsrsran_1_1rlc__retx__queue_a484070008d093c081e44bd88a41c3acd} 
\index{srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}!size@{size}}
\index{size@{size}!srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily size\+\_\+t srsran\+::rlc\+\_\+retx\+\_\+queue\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Total number of elements (valid + invalid) in the queue. 

\begin{DoxyReturn}{Returns}
Number of any elements in the queue. 
\end{DoxyReturn}
\Hypertarget{classsrsran_1_1rlc__retx__queue_a41a054d271901433a6844d6740f2cd64}\label{classsrsran_1_1rlc__retx__queue_a41a054d271901433a6844d6740f2cd64} 
\index{srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}!state@{state}}
\index{state@{state}!srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}}
\doxysubsubsection{\texorpdfstring{state()}{state()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsrsran_1_1rlc__retx__queue__state}{rlc\+\_\+retx\+\_\+queue\+\_\+state}} srsran\+::rlc\+\_\+retx\+\_\+queue\+::state (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Access to the internal state of the queue. 

\begin{DoxyReturn}{Returns}
The internal state of the queue. 
\end{DoxyReturn}
\Hypertarget{classsrsran_1_1rlc__retx__queue_a7741fbc6f94d04570bb6e1f5c2bfd736}\label{classsrsran_1_1rlc__retx__queue_a7741fbc6f94d04570bb6e1f5c2bfd736} 
\index{srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}!try\_push@{try\_push}}
\index{try\_push@{try\_push}!srsran::rlc\_retx\_queue@{srsran::rlc\_retx\_queue}}
\doxysubsubsection{\texorpdfstring{try\_push()}{try\_push()}}
{\footnotesize\ttfamily bool srsran\+::rlc\+\_\+retx\+\_\+queue\+::try\+\_\+push (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structsrsran_1_1rlc__tx__amd__retx}{rlc\+\_\+tx\+\_\+amd\+\_\+retx}} \&}]{retx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Tries to push a Re\+Tx to the queue. 


\begin{DoxyParams}{Parameters}
{\em retx} & The Re\+Tx to be added. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the Re\+Tx was added successfully; False if the queue was full. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
lib/rlc/rlc\+\_\+retx\+\_\+queue.\+h\end{DoxyCompactItemize}
