\doxysection{srsran\+::task\+\_\+worker\+\_\+pool\texorpdfstring{$<$}{<} Queue\+Policies \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classsrsran_1_1task__worker__pool}{}\label{classsrsran_1_1task__worker__pool}\index{srsran::task\_worker\_pool$<$ QueuePolicies $>$@{srsran::task\_worker\_pool$<$ QueuePolicies $>$}}


Simple pool of task workers/threads. The workers share the same queue of task and do not perform work-\/stealing.  




{\ttfamily \#include $<$task\+\_\+worker\+\_\+pool.\+h$>$}

Inheritance diagram for srsran\+::task\+\_\+worker\+\_\+pool\texorpdfstring{$<$}{<} Queue\+Policies \texorpdfstring{$>$}{>}\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.435897cm]{classsrsran_1_1task__worker__pool}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Queue\+Sizes $>$ }\\\mbox{\hyperlink{classsrsran_1_1task__worker__pool_a4d1345a9af95daddd569120f29726e40}{task\+\_\+worker\+\_\+pool}} (unsigned nof\+\_\+workers\+\_\+, const Queue\+Sizes \&queue\+\_\+sizes, std\+::string worker\+\_\+pool\+\_\+name, std\+::chrono\+::microseconds wait\+\_\+sleep\+\_\+time=std\+::chrono\+::microseconds\{100\}, \mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority}{os\+\_\+thread\+\_\+realtime\+\_\+priority}} prio=\mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority_af2cf72da038c74badffd988ce6a08e46}{os\+\_\+thread\+\_\+realtime\+\_\+priority\+::no\+\_\+realtime}}(), \mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ const \mbox{\hyperlink{structsrsran_1_1os__sched__affinity__bitmask}{os\+\_\+sched\+\_\+affinity\+\_\+bitmask}} $>$ cpu\+\_\+masks=\{\})
\begin{DoxyCompactList}\small\item\em Creates a task worker pool. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1task__worker__pool_aef62e53b76bc00b46167a620be3e98fe}\label{classsrsran_1_1task__worker__pool_aef62e53b76bc00b46167a620be3e98fe} 
void {\bfseries stop} ()
\begin{DoxyCompactList}\small\item\em Stop task worker pool, if running. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1task__worker__pool_a26935bb457ac2f54966f2797b49d9542}\label{classsrsran_1_1task__worker__pool_a26935bb457ac2f54966f2797b49d9542} 
unsigned {\bfseries nof\+\_\+pending\+\_\+tasks} () const
\begin{DoxyCompactList}\small\item\em Number of tasks currently enqueued. \end{DoxyCompactList}\item 
\Hypertarget{classsrsran_1_1task__worker__pool_a40264d4e39b9df2d1fd8cd55fb72fc1c}\label{classsrsran_1_1task__worker__pool_a40264d4e39b9df2d1fd8cd55fb72fc1c} 
void {\bfseries wait\+\_\+pending\+\_\+tasks} ()
\begin{DoxyCompactList}\small\item\em Wait for all the currently enqueued tasks to complete. If more tasks get enqueued after this function call those tasks are not accounted for in the waiting. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classsrsran_1_1detail_1_1base__worker__pool}{srsran\+::detail\+::base\+\_\+worker\+\_\+pool}}}
\begin{DoxyCompactItemize}
\item 
{\bfseries base\+\_\+worker\+\_\+pool} (unsigned nof\+\_\+workers\+\_\+, const std\+::string \&worker\+\_\+pool\+\_\+name, const std\+::function$<$ void()$>$ \&run\+\_\+tasks\+\_\+job, \mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority}{os\+\_\+thread\+\_\+realtime\+\_\+priority}} prio=\mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority_af2cf72da038c74badffd988ce6a08e46}{os\+\_\+thread\+\_\+realtime\+\_\+priority\+::no\+\_\+realtime}}(), \mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ const \mbox{\hyperlink{structsrsran_1_1os__sched__affinity__bitmask}{os\+\_\+sched\+\_\+affinity\+\_\+bitmask}} $>$ cpu\+\_\+masks=\{\})
\item 
{\bfseries base\+\_\+worker\+\_\+pool} (const \mbox{\hyperlink{classsrsran_1_1detail_1_1base__worker__pool}{base\+\_\+worker\+\_\+pool}} \&)=delete
\item 
{\bfseries base\+\_\+worker\+\_\+pool} (\mbox{\hyperlink{classsrsran_1_1detail_1_1base__worker__pool}{base\+\_\+worker\+\_\+pool}} \&\&)=delete
\item 
\mbox{\hyperlink{classsrsran_1_1detail_1_1base__worker__pool}{base\+\_\+worker\+\_\+pool}} \& {\bfseries operator=} (const \mbox{\hyperlink{classsrsran_1_1detail_1_1base__worker__pool}{base\+\_\+worker\+\_\+pool}} \&)=delete
\item 
\mbox{\hyperlink{classsrsran_1_1detail_1_1base__worker__pool}{base\+\_\+worker\+\_\+pool}} \& {\bfseries operator=} (\mbox{\hyperlink{classsrsran_1_1detail_1_1base__worker__pool}{base\+\_\+worker\+\_\+pool}} \&\&)=delete
\item 
const char \texorpdfstring{$\ast$}{*} {\bfseries name} () const
\begin{DoxyCompactList}\small\item\em Name given to the pool. \end{DoxyCompactList}\item 
unsigned {\bfseries nof\+\_\+workers} () const
\begin{DoxyCompactList}\small\item\em Number of workers that compose the worker pool. \end{DoxyCompactList}\item 
bool {\bfseries is\+\_\+in\+\_\+thread\+\_\+pool} () const
\begin{DoxyCompactList}\small\item\em Determines whether the caller is inside the pool. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Attributes inherited from \mbox{\hyperlink{classsrsran_1_1detail_1_1base__worker__pool}{srsran\+::detail\+::base\+\_\+worker\+\_\+pool}}}
\begin{DoxyCompactItemize}
\item 
std\+::string {\bfseries pool\+\_\+name}
\item 
std\+::vector$<$ \mbox{\hyperlink{classsrsran_1_1unique__thread}{unique\+\_\+thread}} $>$ {\bfseries worker\+\_\+threads}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$concurrent\+\_\+queue\+\_\+policy... Queue\+Policies$>$\newline
class srsran\+::task\+\_\+worker\+\_\+pool$<$ Queue\+Policies $>$}
Simple pool of task workers/threads. The workers share the same queue of task and do not perform work-\/stealing. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classsrsran_1_1task__worker__pool_a4d1345a9af95daddd569120f29726e40}\label{classsrsran_1_1task__worker__pool_a4d1345a9af95daddd569120f29726e40} 
\index{srsran::task\_worker\_pool$<$ QueuePolicies $>$@{srsran::task\_worker\_pool$<$ QueuePolicies $>$}!task\_worker\_pool@{task\_worker\_pool}}
\index{task\_worker\_pool@{task\_worker\_pool}!srsran::task\_worker\_pool$<$ QueuePolicies $>$@{srsran::task\_worker\_pool$<$ QueuePolicies $>$}}
\doxysubsubsection{\texorpdfstring{task\_worker\_pool()}{task\_worker\_pool()}}
{\footnotesize\ttfamily template$<$concurrent\+\_\+queue\+\_\+policy... Queue\+Policies$>$ \\
template$<$typename Queue\+Sizes $>$ \\
\mbox{\hyperlink{classsrsran_1_1task__worker__pool}{srsran\+::task\+\_\+worker\+\_\+pool}}$<$ Queue\+Policies $>$\+::task\+\_\+worker\+\_\+pool (\begin{DoxyParamCaption}\item[{unsigned}]{nof\+\_\+workers\+\_\+,  }\item[{const Queue\+Sizes \&}]{queue\+\_\+sizes,  }\item[{std\+::string}]{worker\+\_\+pool\+\_\+name,  }\item[{std\+::chrono\+::microseconds}]{wait\+\_\+sleep\+\_\+time = {\ttfamily std\+:\+:chrono\+:\+:microseconds\{100\}},  }\item[{\mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority}{os\+\_\+thread\+\_\+realtime\+\_\+priority}}}]{prio = {\ttfamily \mbox{\hyperlink{classsrsran_1_1os__thread__realtime__priority_af2cf72da038c74badffd988ce6a08e46}{os\+\_\+thread\+\_\+realtime\+\_\+priority\+::no\+\_\+realtime}}()},  }\item[{\mbox{\hyperlink{classsrsran_1_1span}{span}}$<$ const \mbox{\hyperlink{structsrsran_1_1os__sched__affinity__bitmask}{os\+\_\+sched\+\_\+affinity\+\_\+bitmask}} $>$}]{cpu\+\_\+masks = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a task worker pool. 


\begin{DoxyParams}{Parameters}
{\em nof\+\_\+workers} & Number of workers of the worker pool. \\
\hline
{\em queue\+\_\+size} & Size of the task queue. \\
\hline
{\em pool\+\_\+name} & String with the name for the worker pool. Individual workers of the pool will be assigned the name "{}$<$pool\+\_\+name$>$\#$<$worker index$>$"{}. E.\+g. for pool\+\_\+name="{}\+Pool"{}, the second worker will be called "{}\+Pool\#1"{}. \\
\hline
{\em prio} & Workers realtime thread priority. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/srsran/support/executors/task\+\_\+worker\+\_\+pool.\+h\item 
lib/support/executors/task\+\_\+worker\+\_\+pool.\+cpp\end{DoxyCompactItemize}
