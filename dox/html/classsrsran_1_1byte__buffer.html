<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>srsRAN Docs: srsran::byte_buffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">srsRAN Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesrsran.html">srsran</a></li><li class="navelem"><a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsrsran_1_1byte__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">srsran::byte_buffer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks. This container is not contiguous in memory. Default copy ctor and assignment is disabled in this container. The user should instead std::move to transfer ownership, .<a class="el" href="#a1f08be439b9c2c174b4b2827c18feda6" title="Performs a shallow copy. Head segment reference counter is incremented.">copy()</a> for shallow copies with shared ownership and .<a class="el" href="#aa79a5e270dbb5dd01b83c034853b9fb3" title="Performs a deep copy (byte by bytes) of this byte_buffer.">deep_copy()</a> for byte-wise copies.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="byte__buffer_8h_source.html">byte_buffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for srsran::byte_buffer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsrsran_1_1byte__buffer.png" usemap="#srsran::byte_5Fbuffer_map" alt=""/>
  <map id="srsran::byte_5Fbuffer_map" name="srsran::byte_5Fbuffer_map">
<area href="classasn1_1_1unbounded__octstring.html" alt="asn1::unbounded_octstring&lt; true &gt;" shape="rect" coords="0,56,214,80"/>
<area href="classasn1_1_1unbounded__octstring.html" alt="asn1::unbounded_octstring&lt; false &gt;" shape="rect" coords="224,56,438,80"/>
<area href="classasn1_1_1unbounded__octstring.html" alt="asn1::unbounded_octstring&lt; Al &gt;" shape="rect" coords="448,56,662,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a78ecde31e45c3c0e655c27cb9a75f2fd" id="r_a78ecde31e45c3c0e655c27cb9a75f2fd"><td class="memItemLeft" align="right" valign="top"><a id="a78ecde31e45c3c0e655c27cb9a75f2fd" name="a78ecde31e45c3c0e655c27cb9a75f2fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = uint8_t</td></tr>
<tr class="separator:a78ecde31e45c3c0e655c27cb9a75f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653243020132cbb858c0c6c02838f8a4" id="r_a653243020132cbb858c0c6c02838f8a4"><td class="memItemLeft" align="right" valign="top"><a id="a653243020132cbb858c0c6c02838f8a4" name="a653243020132cbb858c0c6c02838f8a4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">detail::byte_buffer_segment_list_byte_iterator</a></td></tr>
<tr class="separator:a653243020132cbb858c0c6c02838f8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489fa0a1de906542bdbdb8ad65cbc2bf" id="r_a489fa0a1de906542bdbdb8ad65cbc2bf"><td class="memItemLeft" align="right" valign="top"><a id="a489fa0a1de906542bdbdb8ad65cbc2bf" name="a489fa0a1de906542bdbdb8ad65cbc2bf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">detail::byte_buffer_segment_list_byte_const_iterator</a></td></tr>
<tr class="separator:a489fa0a1de906542bdbdb8ad65cbc2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d95648e141616eb82e4db1be807148c" id="r_a9d95648e141616eb82e4db1be807148c"><td class="memItemLeft" align="right" valign="top"><a id="a9d95648e141616eb82e4db1be807148c" name="a9d95648e141616eb82e4db1be807148c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>byte_buffer</b> () noexcept=default</td></tr>
<tr class="memdesc:a9d95648e141616eb82e4db1be807148c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. <br /></td></tr>
<tr class="separator:a9d95648e141616eb82e4db1be807148c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de51a4dc546559b66af861d51e29fc3" id="r_a6de51a4dc546559b66af861d51e29fc3"><td class="memItemLeft" align="right" valign="top"><a id="a6de51a4dc546559b66af861d51e29fc3" name="a6de51a4dc546559b66af861d51e29fc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>byte_buffer</b> (const <a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;) noexcept=default</td></tr>
<tr class="memdesc:a6de51a4dc546559b66af861d51e29fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit copy ctor. User should use <a class="el" href="#a1f08be439b9c2c174b4b2827c18feda6" title="Performs a shallow copy. Head segment reference counter is incremented.">copy()</a> method for copy assignments. <br /></td></tr>
<tr class="separator:a6de51a4dc546559b66af861d51e29fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68178f768cd233f55b4e6ebba378bf1e" id="r_a68178f768cd233f55b4e6ebba378bf1e"><td class="memItemLeft" align="right" valign="top"><a id="a68178f768cd233f55b4e6ebba378bf1e" name="a68178f768cd233f55b4e6ebba378bf1e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>byte_buffer</b> (<a class="el" href="classsrsran_1_1span.html">span</a>&lt; const uint8_t &gt; <a class="el" href="classbytes.html">bytes</a>)</td></tr>
<tr class="memdesc:a68178f768cd233f55b4e6ebba378bf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> with content provided by a span of bytes. <br /></td></tr>
<tr class="separator:a68178f768cd233f55b4e6ebba378bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23243c3899f5fb66157c4b8151136dbd" id="r_a23243c3899f5fb66157c4b8151136dbd"><td class="memItemLeft" align="right" valign="top"><a id="a23243c3899f5fb66157c4b8151136dbd" name="a23243c3899f5fb66157c4b8151136dbd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>byte_buffer</b> (std::initializer_list&lt; uint8_t &gt; lst)</td></tr>
<tr class="memdesc:a23243c3899f5fb66157c4b8151136dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> with data intialized via a initializer list. <br /></td></tr>
<tr class="separator:a23243c3899f5fb66157c4b8151136dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bffb2221d9e273d2227d182403a2016" id="r_a3bffb2221d9e273d2227d182403a2016"><td class="memTemplParams" colspan="2"><a id="a3bffb2221d9e273d2227d182403a2016" name="a3bffb2221d9e273d2227d182403a2016"></a>
template&lt;typename It &gt; </td></tr>
<tr class="memitem:a3bffb2221d9e273d2227d182403a2016"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>byte_buffer</b> (It other_begin, It other_end)</td></tr>
<tr class="memdesc:a3bffb2221d9e273d2227d182403a2016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> with data assigned from a range of bytes. <br /></td></tr>
<tr class="separator:a3bffb2221d9e273d2227d182403a2016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bd84dfe3119fbeb1c63e4028361aed" id="r_a82bd84dfe3119fbeb1c63e4028361aed"><td class="memItemLeft" align="right" valign="top"><a id="a82bd84dfe3119fbeb1c63e4028361aed" name="a82bd84dfe3119fbeb1c63e4028361aed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>byte_buffer</b> (<a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&amp;<a class="el" href="namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept=default</td></tr>
<tr class="memdesc:a82bd84dfe3119fbeb1c63e4028361aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a82bd84dfe3119fbeb1c63e4028361aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af519f1b008b53df31f03005e4a590ae6" id="r_af519f1b008b53df31f03005e4a590ae6"><td class="memItemLeft" align="right" valign="top"><a id="af519f1b008b53df31f03005e4a590ae6" name="af519f1b008b53df31f03005e4a590ae6"></a>
<a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;) noexcept=delete</td></tr>
<tr class="memdesc:af519f1b008b53df31f03005e4a590ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment is disabled. Use std::move, .<a class="el" href="#a1f08be439b9c2c174b4b2827c18feda6" title="Performs a shallow copy. Head segment reference counter is incremented.">copy()</a> or .<a class="el" href="#aa79a5e270dbb5dd01b83c034853b9fb3" title="Performs a deep copy (byte by bytes) of this byte_buffer.">deep_copy()</a> instead. <br /></td></tr>
<tr class="separator:af519f1b008b53df31f03005e4a590ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a40af12ed4cd3da56159f069131df8" id="r_a10a40af12ed4cd3da56159f069131df8"><td class="memItemLeft" align="right" valign="top"><a id="a10a40af12ed4cd3da56159f069131df8" name="a10a40af12ed4cd3da56159f069131df8"></a>
<a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&amp;<a class="el" href="namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept=default</td></tr>
<tr class="memdesc:a10a40af12ed4cd3da56159f069131df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment of <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. It avoids unnecessary reference counting increment. <br /></td></tr>
<tr class="separator:a10a40af12ed4cd3da56159f069131df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2ffb4df18c0d3ddc15a68b75664b43" id="r_a4d2ffb4df18c0d3ddc15a68b75664b43"><td class="memItemLeft" align="right" valign="top"><a id="a4d2ffb4df18c0d3ddc15a68b75664b43" name="a4d2ffb4df18c0d3ddc15a68b75664b43"></a>
<a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classsrsran_1_1span.html">span</a>&lt; const uint8_t &gt; <a class="el" href="classbytes.html">bytes</a>) noexcept</td></tr>
<tr class="memdesc:a4d2ffb4df18c0d3ddc15a68b75664b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of span of bytes. <br /></td></tr>
<tr class="separator:a4d2ffb4df18c0d3ddc15a68b75664b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79a5e270dbb5dd01b83c034853b9fb3" id="r_aa79a5e270dbb5dd01b83c034853b9fb3"><td class="memItemLeft" align="right" valign="top"><a id="aa79a5e270dbb5dd01b83c034853b9fb3" name="aa79a5e270dbb5dd01b83c034853b9fb3"></a>
<a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deep_copy</b> () const</td></tr>
<tr class="memdesc:aa79a5e270dbb5dd01b83c034853b9fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep copy (byte by bytes) of this <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. <br /></td></tr>
<tr class="separator:aa79a5e270dbb5dd01b83c034853b9fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f08be439b9c2c174b4b2827c18feda6" id="r_a1f08be439b9c2c174b4b2827c18feda6"><td class="memItemLeft" align="right" valign="top"><a id="a1f08be439b9c2c174b4b2827c18feda6" name="a1f08be439b9c2c174b4b2827c18feda6"></a>
<a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> () const</td></tr>
<tr class="memdesc:a1f08be439b9c2c174b4b2827c18feda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a shallow copy. Head segment reference counter is incremented. <br /></td></tr>
<tr class="separator:a1f08be439b9c2c174b4b2827c18feda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190484f4224c88acb2f1b3334b28421b" id="r_a190484f4224c88acb2f1b3334b28421b"><td class="memTemplParams" colspan="2"><a id="a190484f4224c88acb2f1b3334b28421b" name="a190484f4224c88acb2f1b3334b28421b"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a190484f4224c88acb2f1b3334b28421b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append</b> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a190484f4224c88acb2f1b3334b28421b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append bytes of a iterator range. <br /></td></tr>
<tr class="separator:a190484f4224c88acb2f1b3334b28421b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c9b29ce6019b29798495213d68096c" id="r_ad7c9b29ce6019b29798495213d68096c"><td class="memItemLeft" align="right" valign="top"><a id="ad7c9b29ce6019b29798495213d68096c" name="ad7c9b29ce6019b29798495213d68096c"></a>
<a class="el" href="compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (<a class="el" href="classsrsran_1_1span.html">span</a>&lt; const uint8_t &gt; <a class="el" href="classbytes.html">bytes</a>)</td></tr>
<tr class="memdesc:ad7c9b29ce6019b29798495213d68096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends bytes to the byte buffer. This function may retrieve new segments from a memory pool. <br /></td></tr>
<tr class="separator:ad7c9b29ce6019b29798495213d68096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244844e979a2bf6e2bdb96574c65584b" id="r_a244844e979a2bf6e2bdb96574c65584b"><td class="memItemLeft" align="right" valign="top"><a id="a244844e979a2bf6e2bdb96574c65584b" name="a244844e979a2bf6e2bdb96574c65584b"></a>
<a class="el" href="compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (const std::initializer_list&lt; uint8_t &gt; &amp;<a class="el" href="classbytes.html">bytes</a>)</td></tr>
<tr class="memdesc:a244844e979a2bf6e2bdb96574c65584b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends an initializer list of bytes. <br /></td></tr>
<tr class="separator:a244844e979a2bf6e2bdb96574c65584b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cbb3c32365a49af9d01ae53360a43c" id="r_af6cbb3c32365a49af9d01ae53360a43c"><td class="memItemLeft" align="right" valign="top"><a id="af6cbb3c32365a49af9d01ae53360a43c" name="af6cbb3c32365a49af9d01ae53360a43c"></a>
<a class="el" href="compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (const <a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;<a class="el" href="namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:af6cbb3c32365a49af9d01ae53360a43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends bytes from another <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments. <br /></td></tr>
<tr class="separator:af6cbb3c32365a49af9d01ae53360a43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef452363346e8bf3176c8d2d31a5171" id="r_a4ef452363346e8bf3176c8d2d31a5171"><td class="memItemLeft" align="right" valign="top"><a id="a4ef452363346e8bf3176c8d2d31a5171" name="a4ef452363346e8bf3176c8d2d31a5171"></a>
<a class="el" href="compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (<a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&amp;<a class="el" href="namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:a4ef452363346e8bf3176c8d2d31a5171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends bytes from another rvalue <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments. <br /></td></tr>
<tr class="separator:a4ef452363346e8bf3176c8d2d31a5171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74d9a2442b1103a2ac0852afd7f3e1a" id="r_ae74d9a2442b1103a2ac0852afd7f3e1a"><td class="memItemLeft" align="right" valign="top"><a id="ae74d9a2442b1103a2ac0852afd7f3e1a" name="ae74d9a2442b1103a2ac0852afd7f3e1a"></a>
<a class="el" href="compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (uint8_t byte)</td></tr>
<tr class="memdesc:ae74d9a2442b1103a2ac0852afd7f3e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends bytes to the byte buffer. This function may allocate new segments. <br /></td></tr>
<tr class="separator:ae74d9a2442b1103a2ac0852afd7f3e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4563ca3bb9e2b8634e96ec87911c838" id="r_af4563ca3bb9e2b8634e96ec87911c838"><td class="memItemLeft" align="right" valign="top"><a id="af4563ca3bb9e2b8634e96ec87911c838" name="af4563ca3bb9e2b8634e96ec87911c838"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (const <a class="el" href="classsrsran_1_1byte__buffer__view.html">byte_buffer_view</a> &amp;view)</td></tr>
<tr class="memdesc:af4563ca3bb9e2b8634e96ec87911c838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a view of bytes into current byte buffer. <br /></td></tr>
<tr class="separator:af4563ca3bb9e2b8634e96ec87911c838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a8d0f483eeaaa7c31d576782070647" id="r_a60a8d0f483eeaaa7c31d576782070647"><td class="memItemLeft" align="right" valign="top"><a id="a60a8d0f483eeaaa7c31d576782070647" name="a60a8d0f483eeaaa7c31d576782070647"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (const <a class="el" href="classsrsran_1_1byte__buffer__slice.html">byte_buffer_slice</a> &amp;view)</td></tr>
<tr class="memdesc:a60a8d0f483eeaaa7c31d576782070647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends an owning view of bytes into current byte buffer. <br /></td></tr>
<tr class="separator:a60a8d0f483eeaaa7c31d576782070647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8478410e24f9b23cafda0cbabdbf403" id="r_ae8478410e24f9b23cafda0cbabdbf403"><td class="memItemLeft" align="right" valign="top"><a id="ae8478410e24f9b23cafda0cbabdbf403" name="ae8478410e24f9b23cafda0cbabdbf403"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>prepend</b> (<a class="el" href="classsrsran_1_1span.html">span</a>&lt; const uint8_t &gt; <a class="el" href="classbytes.html">bytes</a>)</td></tr>
<tr class="memdesc:ae8478410e24f9b23cafda0cbabdbf403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends bytes to <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments. <br /></td></tr>
<tr class="separator:ae8478410e24f9b23cafda0cbabdbf403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acac0fd07a5577ba3a430b636c74741" id="r_a6acac0fd07a5577ba3a430b636c74741"><td class="memItemLeft" align="right" valign="top"><a id="a6acac0fd07a5577ba3a430b636c74741" name="a6acac0fd07a5577ba3a430b636c74741"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>prepend</b> (const <a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;<a class="el" href="namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:a6acac0fd07a5577ba3a430b636c74741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend data of byte buffer to this byte buffer. <br /></td></tr>
<tr class="separator:a6acac0fd07a5577ba3a430b636c74741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababbb591f47600a9a0ffbf5a91b19e87" id="r_ababbb591f47600a9a0ffbf5a91b19e87"><td class="memItemLeft" align="right" valign="top"><a id="ababbb591f47600a9a0ffbf5a91b19e87" name="ababbb591f47600a9a0ffbf5a91b19e87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>prepend</b> (<a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&amp;<a class="el" href="namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:ababbb591f47600a9a0ffbf5a91b19e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend data of r-value byte buffer to this byte buffer. The segments of the provided byte buffer can get "stolen" if the byte buffer is the last reference to the segments. <br /></td></tr>
<tr class="separator:ababbb591f47600a9a0ffbf5a91b19e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dbd27b3715bfe6abc890fbfd170245" id="r_ad8dbd27b3715bfe6abc890fbfd170245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrsran_1_1byte__buffer__view.html">byte_buffer_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8dbd27b3715bfe6abc890fbfd170245">reserve_prepend</a> (size_t nof_bytes)</td></tr>
<tr class="separator:ad8dbd27b3715bfe6abc890fbfd170245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8882b6403ea3f246d63c64dd122f10" id="r_a7c8882b6403ea3f246d63c64dd122f10"><td class="memItemLeft" align="right" valign="top"><a id="a7c8882b6403ea3f246d63c64dd122f10" name="a7c8882b6403ea3f246d63c64dd122f10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a7c8882b6403ea3f246d63c64dd122f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear byte buffer. <br /></td></tr>
<tr class="separator:a7c8882b6403ea3f246d63c64dd122f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832175c27ef0d111b127c1a0bc421ec3" id="r_a832175c27ef0d111b127c1a0bc421ec3"><td class="memItemLeft" align="right" valign="top"><a id="a832175c27ef0d111b127c1a0bc421ec3" name="a832175c27ef0d111b127c1a0bc421ec3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>trim_head</b> (size_t nof_bytes)</td></tr>
<tr class="memdesc:a832175c27ef0d111b127c1a0bc421ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes "nof_bytes" from the head of the <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. <br /></td></tr>
<tr class="separator:a832175c27ef0d111b127c1a0bc421ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94ff05447760ce113c0ee12f92cb503" id="r_ad94ff05447760ce113c0ee12f92cb503"><td class="memItemLeft" align="right" valign="top"><a id="ad94ff05447760ce113c0ee12f92cb503" name="ad94ff05447760ce113c0ee12f92cb503"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>trim_tail</b> (size_t nof_bytes)</td></tr>
<tr class="memdesc:ad94ff05447760ce113c0ee12f92cb503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove "nof_bytes" bytes at the end of the <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. If the length is greater than the length of the last segment, the function will fail and return -1 without modifying the <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. <br /></td></tr>
<tr class="separator:ad94ff05447760ce113c0ee12f92cb503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d77b44f1d800f8b2f92bb76e80512f3" id="r_a4d77b44f1d800f8b2f92bb76e80512f3"><td class="memItemLeft" align="right" valign="top"><a id="a4d77b44f1d800f8b2f92bb76e80512f3" name="a4d77b44f1d800f8b2f92bb76e80512f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:a4d77b44f1d800f8b2f92bb76e80512f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> is empty. <br /></td></tr>
<tr class="separator:a4d77b44f1d800f8b2f92bb76e80512f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7168fb8841a83a60b60a2ae06b59662d" id="r_a7168fb8841a83a60b60a2ae06b59662d"><td class="memItemLeft" align="right" valign="top"><a id="a7168fb8841a83a60b60a2ae06b59662d" name="a7168fb8841a83a60b60a2ae06b59662d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> () const</td></tr>
<tr class="memdesc:a7168fb8841a83a60b60a2ae06b59662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> length. <br /></td></tr>
<tr class="separator:a7168fb8841a83a60b60a2ae06b59662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf855416c7e41a6c3d8c4941d4783c99" id="r_abf855416c7e41a6c3d8c4941d4783c99"><td class="memItemLeft" align="right" valign="top"><a id="abf855416c7e41a6c3d8c4941d4783c99" name="abf855416c7e41a6c3d8c4941d4783c99"></a>
uint8_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> ()</td></tr>
<tr class="separator:abf855416c7e41a6c3d8c4941d4783c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9378faa8c62fbb48e4d262f4571305c7" id="r_a9378faa8c62fbb48e4d262f4571305c7"><td class="memItemLeft" align="right" valign="top"><a id="a9378faa8c62fbb48e4d262f4571305c7" name="a9378faa8c62fbb48e4d262f4571305c7"></a>
const uint8_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> () const</td></tr>
<tr class="separator:a9378faa8c62fbb48e4d262f4571305c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bd6d35edc057057878c260bb770ac6" id="r_ae8bd6d35edc057057878c260bb770ac6"><td class="memItemLeft" align="right" valign="top"><a id="ae8bd6d35edc057057878c260bb770ac6" name="ae8bd6d35edc057057878c260bb770ac6"></a>
const uint8_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t i) const</td></tr>
<tr class="separator:ae8bd6d35edc057057878c260bb770ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ad328b7f3a1993fa922079a3325572" id="r_a67ad328b7f3a1993fa922079a3325572"><td class="memItemLeft" align="right" valign="top"><a id="a67ad328b7f3a1993fa922079a3325572" name="a67ad328b7f3a1993fa922079a3325572"></a>
uint8_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t i)</td></tr>
<tr class="separator:a67ad328b7f3a1993fa922079a3325572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6158880f84f9e70bcad65ec41d3947d" id="r_aa6158880f84f9e70bcad65ec41d3947d"><td class="memItemLeft" align="right" valign="top"><a id="aa6158880f84f9e70bcad65ec41d3947d" name="aa6158880f84f9e70bcad65ec41d3947d"></a>
<a class="el" href="classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:aa6158880f84f9e70bcad65ec41d3947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d229af09452739a4134b3c5cc6c10bb" id="r_a3d229af09452739a4134b3c5cc6c10bb"><td class="memItemLeft" align="right" valign="top"><a id="a3d229af09452739a4134b3c5cc6c10bb" name="a3d229af09452739a4134b3c5cc6c10bb"></a>
<a class="el" href="classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const</td></tr>
<tr class="separator:a3d229af09452739a4134b3c5cc6c10bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89725b9abf675e324b80cd97f2c59939" id="r_a89725b9abf675e324b80cd97f2c59939"><td class="memItemLeft" align="right" valign="top"><a id="a89725b9abf675e324b80cd97f2c59939" name="a89725b9abf675e324b80cd97f2c59939"></a>
<a class="el" href="classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a89725b9abf675e324b80cd97f2c59939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b09f39ae09c1675dcc1f24cfafac00" id="r_a01b09f39ae09c1675dcc1f24cfafac00"><td class="memItemLeft" align="right" valign="top"><a id="a01b09f39ae09c1675dcc1f24cfafac00" name="a01b09f39ae09c1675dcc1f24cfafac00"></a>
<a class="el" href="classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a01b09f39ae09c1675dcc1f24cfafac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93337b886e3228c314441a3d9bc64664" id="r_a93337b886e3228c314441a3d9bc64664"><td class="memItemLeft" align="right" valign="top"><a id="a93337b886e3228c314441a3d9bc64664" name="a93337b886e3228c314441a3d9bc64664"></a>
<a class="el" href="classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:a93337b886e3228c314441a3d9bc64664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0488305e1061fbd56b03863cd4cb06a" id="r_ad0488305e1061fbd56b03863cd4cb06a"><td class="memItemLeft" align="right" valign="top"><a id="ad0488305e1061fbd56b03863cd4cb06a" name="ad0488305e1061fbd56b03863cd4cb06a"></a>
<a class="el" href="classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const</td></tr>
<tr class="separator:ad0488305e1061fbd56b03863cd4cb06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35457b6e2f22016d8f8736ed4dd405e" id="r_af35457b6e2f22016d8f8736ed4dd405e"><td class="memItemLeft" align="right" valign="top"><a id="af35457b6e2f22016d8f8736ed4dd405e" name="af35457b6e2f22016d8f8736ed4dd405e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_contiguous</b> () const</td></tr>
<tr class="memdesc:af35457b6e2f22016d8f8736ed4dd405e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if byte buffer is contiguous in memory, i.e. it has only one segment. <br /></td></tr>
<tr class="separator:af35457b6e2f22016d8f8736ed4dd405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68551742e508e22eb0729f9701a6a87" id="r_ad68551742e508e22eb0729f9701a6a87"><td class="memItemLeft" align="right" valign="top"><a id="ad68551742e508e22eb0729f9701a6a87" name="ad68551742e508e22eb0729f9701a6a87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>linearize</b> ()</td></tr>
<tr class="memdesc:ad68551742e508e22eb0729f9701a6a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the bytes stored in different segments of the <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> into first segment. <br /></td></tr>
<tr class="separator:ad68551742e508e22eb0729f9701a6a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854af8571f283c815b9b429393c5b0dd" id="r_a854af8571f283c815b9b429393c5b0dd"><td class="memItemLeft" align="right" valign="top"><a id="a854af8571f283c815b9b429393c5b0dd" name="a854af8571f283c815b9b429393c5b0dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_t new_sz)</td></tr>
<tr class="memdesc:a854af8571f283c815b9b429393c5b0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> length. Note: It doesn't initialize newly created bytes. <br /></td></tr>
<tr class="separator:a854af8571f283c815b9b429393c5b0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b324249f8e1d4366bbe869fe464444" id="r_a43b324249f8e1d4366bbe869fe464444"><td class="memItemLeft" align="right" valign="top"><a id="a43b324249f8e1d4366bbe869fe464444" name="a43b324249f8e1d4366bbe869fe464444"></a>
<a class="el" href="namespacesrsran.html#a2c874a03d72343d6bd7fd30e8b9b2ff1">byte_buffer_segment_span_range</a>&#160;</td><td class="memItemRight" valign="bottom"><b>segments</b> ()</td></tr>
<tr class="memdesc:a43b324249f8e1d4366bbe869fe464444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-owning list of segments that compose the <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. <br /></td></tr>
<tr class="separator:a43b324249f8e1d4366bbe869fe464444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b346068b8b1fe33af98fd085301a7" id="r_aea8b346068b8b1fe33af98fd085301a7"><td class="memItemLeft" align="right" valign="top"><a id="aea8b346068b8b1fe33af98fd085301a7" name="aea8b346068b8b1fe33af98fd085301a7"></a>
<a class="el" href="classsrsran_1_1detail_1_1byte__buffer__segment__list__span__range__impl.html">const_byte_buffer_segment_span_range</a>&#160;</td><td class="memItemRight" valign="bottom"><b>segments</b> () const</td></tr>
<tr class="separator:aea8b346068b8b1fe33af98fd085301a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a02c6cbc753f5908a4e21237c5001c939" id="r_a02c6cbc753f5908a4e21237c5001c939"><td class="memTemplParams" colspan="2"><a id="a02c6cbc753f5908a4e21237c5001c939" name="a02c6cbc753f5908a4e21237c5001c939"></a>
template&lt;typename R &gt; </td></tr>
<tr class="memitem:a02c6cbc753f5908a4e21237c5001c939"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;lhs, const R &amp;r)</td></tr>
<tr class="memdesc:a02c6cbc753f5908a4e21237c5001c939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between byte buffer view and another range. <br /></td></tr>
<tr class="separator:a02c6cbc753f5908a4e21237c5001c939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322a5da9c84a7238d19d91a0a2f8094f" id="r_a322a5da9c84a7238d19d91a0a2f8094f"><td class="memTemplParams" colspan="2"><a id="a322a5da9c84a7238d19d91a0a2f8094f" name="a322a5da9c84a7238d19d91a0a2f8094f"></a>
template&lt;typename T , std::enable_if_t&lt; std::is_convertible&lt; T, <a class="el" href="classsrsran_1_1span.html">span</a>&lt; const uint8_t &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a322a5da9c84a7238d19d91a0a2f8094f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;r, const <a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;rhs)</td></tr>
<tr class="separator:a322a5da9c84a7238d19d91a0a2f8094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc458560f59e4ddd2f7a3913f7986c24" id="r_abc458560f59e4ddd2f7a3913f7986c24"><td class="memTemplParams" colspan="2"><a id="abc458560f59e4ddd2f7a3913f7986c24" name="abc458560f59e4ddd2f7a3913f7986c24"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc458560f59e4ddd2f7a3913f7986c24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;lhs, const T &amp;r)</td></tr>
<tr class="separator:abc458560f59e4ddd2f7a3913f7986c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab399a14c39e6fa6b9fc84328273100b3" id="r_ab399a14c39e6fa6b9fc84328273100b3"><td class="memTemplParams" colspan="2"><a id="ab399a14c39e6fa6b9fc84328273100b3" name="ab399a14c39e6fa6b9fc84328273100b3"></a>
template&lt;typename T , std::enable_if_t&lt; std::is_convertible&lt; T, <a class="el" href="classsrsran_1_1span.html">span</a>&lt; const uint8_t &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab399a14c39e6fa6b9fc84328273100b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;r, const <a class="el" href="classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;rhs)</td></tr>
<tr class="separator:ab399a14c39e6fa6b9fc84328273100b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks. This container is not contiguous in memory. Default copy ctor and assignment is disabled in this container. The user should instead std::move to transfer ownership, .<a class="el" href="#a1f08be439b9c2c174b4b2827c18feda6" title="Performs a shallow copy. Head segment reference counter is incremented.">copy()</a> for shallow copies with shared ownership and .<a class="el" href="#aa79a5e270dbb5dd01b83c034853b9fb3" title="Performs a deep copy (byte by bytes) of this byte_buffer.">deep_copy()</a> for byte-wise copies. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad8dbd27b3715bfe6abc890fbfd170245" name="ad8dbd27b3715bfe6abc890fbfd170245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8dbd27b3715bfe6abc890fbfd170245">&#9670;&#160;</a></span>reserve_prepend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrsran_1_1byte__buffer__view.html">byte_buffer_view</a> byte_buffer::reserve_prepend </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nof_bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepends space in <a class="el" href="classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nof_bytes</td><td>Number of bytes to reserve at header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range of bytes that were reserved. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/srsran/adt/<a class="el" href="byte__buffer_8h_source.html">byte_buffer.h</a></li>
<li>lib/support/<b>byte_buffer.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
