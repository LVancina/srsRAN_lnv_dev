<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>srsRAN Docs: srsran::rlc_sdu_queue_lockfree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">srsRAN Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesrsran.html">srsran</a></li><li class="navelem"><a class="el" href="classsrsran_1_1rlc__sdu__queue__lockfree.html">rlc_sdu_queue_lockfree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsrsran_1_1rlc__sdu__queue__lockfree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">srsran::rlc_sdu_queue_lockfree Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Lockfree RLC SDU queue.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rlc__sdu__queue__lockfree_8h_source.html">rlc_sdu_queue_lockfree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adb2630d9a4ef331848d6ef3b35c79540" id="r_adb2630d9a4ef331848d6ef3b35c79540"><td class="memItemLeft" align="right" valign="top"><a id="adb2630d9a4ef331848d6ef3b35c79540" name="adb2630d9a4ef331848d6ef3b35c79540"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rlc_sdu_queue_lockfree</b> (uint16_t capacity_, <a class="el" href="classsrsran_1_1prefixed__logger.html">rlc_bearer_logger</a> &amp;logger_)</td></tr>
<tr class="separator:adb2630d9a4ef331848d6ef3b35c79540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a653b33da96f2caea9471794877464c" id="r_a1a653b33da96f2caea9471794877464c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a653b33da96f2caea9471794877464c">write</a> (<a class="el" href="structsrsran_1_1rlc__sdu.html">rlc_sdu</a> sdu)</td></tr>
<tr class="memdesc:a1a653b33da96f2caea9471794877464c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an RLC SDU (with optional PDCP SN) to the queue, if possible.  <br /></td></tr>
<tr class="separator:a1a653b33da96f2caea9471794877464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5918fa48177cf34b10fef220c8fc719f" id="r_a5918fa48177cf34b10fef220c8fc719f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5918fa48177cf34b10fef220c8fc719f">try_discard</a> (uint32_t pdcp_sn)</td></tr>
<tr class="memdesc:a5918fa48177cf34b10fef220c8fc719f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks an RLC SDU as "discarded", if possible.  <br /></td></tr>
<tr class="separator:a5918fa48177cf34b10fef220c8fc719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2d6733746aaf17fd87a0743ba52501" id="r_a5b2d6733746aaf17fd87a0743ba52501"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b2d6733746aaf17fd87a0743ba52501">read</a> (<a class="el" href="structsrsran_1_1rlc__sdu.html">rlc_sdu</a> &amp;sdu)</td></tr>
<tr class="memdesc:a5b2d6733746aaf17fd87a0743ba52501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an RLC SDU (with optional PDCP SN) from the queue, if possible.  <br /></td></tr>
<tr class="separator:a5b2d6733746aaf17fd87a0743ba52501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4aca80a693e78a7030d130e1116c09" id="r_a4c4aca80a693e78a7030d130e1116c09"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c4aca80a693e78a7030d130e1116c09">size_sdus</a> () const</td></tr>
<tr class="memdesc:a4c4aca80a693e78a7030d130e1116c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the number of buffered SDUs that are not marked as discarded.  <br /></td></tr>
<tr class="separator:a4c4aca80a693e78a7030d130e1116c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d800cfef5a9542f480da984fc3e2d0" id="r_ab2d800cfef5a9542f480da984fc3e2d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2d800cfef5a9542f480da984fc3e2d0">size_bytes</a> () const</td></tr>
<tr class="memdesc:ab2d800cfef5a9542f480da984fc3e2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the number of buffered SDU bytes that are not marked as discarded.  <br /></td></tr>
<tr class="separator:ab2d800cfef5a9542f480da984fc3e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba1e310d8d662703f2922303c627a7a" id="r_a7ba1e310d8d662703f2922303c627a7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ba1e310d8d662703f2922303c627a7a">is_empty</a> ()</td></tr>
<tr class="memdesc:a7ba1e310d8d662703f2922303c627a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the internal queue is empty.  <br /></td></tr>
<tr class="separator:a7ba1e310d8d662703f2922303c627a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ac4760854df275260a793d0c71cf99" id="r_a68ac4760854df275260a793d0c71cf99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68ac4760854df275260a793d0c71cf99">is_full</a> ()</td></tr>
<tr class="memdesc:a68ac4760854df275260a793d0c71cf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the internal queue is full.  <br /></td></tr>
<tr class="separator:a68ac4760854df275260a793d0c71cf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lockfree RLC SDU queue. </p>
<p>This class is used as FIFO buffer for RLC SDUs from upper layers that shall be transmitted by the RLC Tx entity. It implements SPSC (single producer single consumer) semantics, i.e. allows concurrent access by one upper-layer thread and one lower-layer thread. Internally, this class wraps a lock-free SPSC queue to store the actual SDUs and involves additional bookkeeping to support discard of SDUs and to track the amount of buffered SDUs and bytes.</p>
<p>From the perspective of the upper-layer thread this class provides methods to write RLC SDUs (with or without PDCP SN) and to discard SDUs by their PDCP SN. SDUs without PDCP SN cannot be discarded. SDUs that are marked as discarded remain in the internal queue until they are popped (and dropped) via <code>read</code>. Writing to the queue fails if the internal queue is either full or the queue already contains an SDU (whether valid or marked as discarded) with the same value for [PDCP_SN mod capacity].</p>
<p>From the perspective of the lower-layer thread it provides methods to read RLC SDUs and to query the total number of buffered SDUs and bytes. SDUs are read in the same order as they were written into the queue. There is no reordering by PDCP SN. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7ba1e310d8d662703f2922303c627a7a" name="a7ba1e310d8d662703f2922303c627a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba1e310d8d662703f2922303c627a7a">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool srsran::rlc_sdu_queue_lockfree::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the internal queue is empty. </p>
<p>This function may be called by any thread.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the internal queue is empty, otherwise false. </dd></dl>

</div>
</div>
<a id="a68ac4760854df275260a793d0c71cf99" name="a68ac4760854df275260a793d0c71cf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ac4760854df275260a793d0c71cf99">&#9670;&#160;</a></span>is_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool srsran::rlc_sdu_queue_lockfree::is_full </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the internal queue is full. </p>
<p>This function may be called by any thread.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the internal queue is full, otherwise false. </dd></dl>

</div>
</div>
<a id="a5b2d6733746aaf17fd87a0743ba52501" name="a5b2d6733746aaf17fd87a0743ba52501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2d6733746aaf17fd87a0743ba52501">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool srsran::rlc_sdu_queue_lockfree::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrsran_1_1rlc__sdu.html">rlc_sdu</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sdu</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads an RLC SDU (with optional PDCP SN) from the queue, if possible. </p>
<p>This function may be called by the lower-layer thread.</p>
<p>The read fails (returns false) in the following cases:</p><ul>
<li>The internal queue only contains SDUs that are marked as discarded.</li>
<li>The internal queue is empty.</li>
</ul>
<p>Each call of this function pops and drops SDUs that are marked as discarded from the internal queue in a loop until a valid SDU is popped (return true) or the queue is empty (returns false).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdu</td><td>Reference to a <code><a class="el" href="structsrsran_1_1rlc__sdu.html">rlc_sdu</a></code> object that will be filled with the read RLC SDU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an RLC SDU was successfully read from the queue, otherwise false. </dd></dl>

</div>
</div>
<a id="ab2d800cfef5a9542f480da984fc3e2d0" name="ab2d800cfef5a9542f480da984fc3e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d800cfef5a9542f480da984fc3e2d0">&#9670;&#160;</a></span>size_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t srsran::rlc_sdu_queue_lockfree::size_bytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the number of buffered SDU bytes that are not marked as discarded. </p>
<p>This function may be called by any thread.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of buffered SDU bytes that are not marked as discarded. </dd></dl>

</div>
</div>
<a id="a4c4aca80a693e78a7030d130e1116c09" name="a4c4aca80a693e78a7030d130e1116c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4aca80a693e78a7030d130e1116c09">&#9670;&#160;</a></span>size_sdus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t srsran::rlc_sdu_queue_lockfree::size_sdus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the number of buffered SDUs that are not marked as discarded. </p>
<p>This function may be called by any thread.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of buffered SDUs that are not marked as discarded. </dd></dl>

</div>
</div>
<a id="a5918fa48177cf34b10fef220c8fc719f" name="a5918fa48177cf34b10fef220c8fc719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5918fa48177cf34b10fef220c8fc719f">&#9670;&#160;</a></span>try_discard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool srsran::rlc_sdu_queue_lockfree::try_discard </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>pdcp_sn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks an RLC SDU as "discarded", if possible. </p>
<p>This function may be called by the upper-layer thread.</p>
<p>The function fails (returns false) in the following cases:</p><ul>
<li>The SDU with the PDCP SN is already marked as discarded.</li>
<li>The SDU with the PDCP SN is not in the queue.</li>
</ul>
<p>In case of success, the number of SDUs/bytes will be updated immediately. However, the actual SDU remains in the internal queue until it is popped and finally discarded via <code>read</code>. Meanwhile, no further SDU with the same value of [PDCP_SN mod capacity] can be added to the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdcp_sn</td><td>The PDCP SN of the SDU that shall be discarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the RLC SDU was successfully discarded, otherwise false. </dd></dl>

</div>
</div>
<a id="a1a653b33da96f2caea9471794877464c" name="a1a653b33da96f2caea9471794877464c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a653b33da96f2caea9471794877464c">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool srsran::rlc_sdu_queue_lockfree::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrsran_1_1rlc__sdu.html">rlc_sdu</a></td>          <td class="paramname"><span class="paramname"><em>sdu</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an RLC SDU (with optional PDCP SN) to the queue, if possible. </p>
<p>This function may be called by the upper-layer thread.</p>
<p>The write fails (returns false) in the following cases:</p><ul>
<li>The internal queue is full.</li>
<li>Another SDU with same value of [PDCP_SN mod capacity] exists (either valid or discarded) in the queue.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdu</td><td>The RLC SDU that shall be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the RLC SDU was successfully written to the queue, otherwise false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/rlc/<a class="el" href="rlc__sdu__queue__lockfree_8h_source.html">rlc_sdu_queue_lockfree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
