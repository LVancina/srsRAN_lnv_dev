<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>srsRAN Docs: srsran::rb_allocation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">srsRAN Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesrsran.html">srsran</a></li><li class="navelem"><a class="el" href="classsrsran_1_1rb__allocation.html">rb_allocation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classsrsran_1_1rb__allocation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">srsran::rb_allocation Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Describes the frequency allocation for PDSCH and PUSCH transmissions.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rb__allocation_8h_source.html">rb_allocation.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc67b968fd627acaf5b6121aab0c84c3" id="r_afc67b968fd627acaf5b6121aab0c84c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc67b968fd627acaf5b6121aab0c84c3">rb_allocation</a> ()=default</td></tr>
<tr class="memdesc:afc67b968fd627acaf5b6121aab0c84c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:afc67b968fd627acaf5b6121aab0c84c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaf27d8deb6f93f0458ebef2dadb4dc" id="r_a0aaf27d8deb6f93f0458ebef2dadb4dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aaf27d8deb6f93f0458ebef2dadb4dc">operator==</a> (const <a class="el" href="classsrsran_1_1rb__allocation.html">rb_allocation</a> &amp;<a class="el" href="namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) const</td></tr>
<tr class="memdesc:a0aaf27d8deb6f93f0458ebef2dadb4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two frequency domain allocations.  <br /></td></tr>
<tr class="separator:a0aaf27d8deb6f93f0458ebef2dadb4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371f2f118ca976f0a2958c7f6d4baf0e" id="r_a371f2f118ca976f0a2958c7f6d4baf0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a371f2f118ca976f0a2958c7f6d4baf0e">is_contiguous</a> () const</td></tr>
<tr class="memdesc:a371f2f118ca976f0a2958c7f6d4baf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if resultant VRB-to-PRB allocation is contiguous in frequency domain.  <br /></td></tr>
<tr class="separator:a371f2f118ca976f0a2958c7f6d4baf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8e75c73e734a72c89d6f4052102a98" id="r_a1f8e75c73e734a72c89d6f4052102a98"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f8e75c73e734a72c89d6f4052102a98">get_prb_begin</a> (unsigned bwp_start_rb) const</td></tr>
<tr class="memdesc:a1f8e75c73e734a72c89d6f4052102a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lowest allocated PRB index.  <br /></td></tr>
<tr class="separator:a1f8e75c73e734a72c89d6f4052102a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e6e188111c58827be610671fe3fb93" id="r_a82e6e188111c58827be610671fe3fb93"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82e6e188111c58827be610671fe3fb93">get_prb_end</a> (unsigned bwp_start_rb) const</td></tr>
<tr class="memdesc:a82e6e188111c58827be610671fe3fb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the highest allocated PRB index plus one.  <br /></td></tr>
<tr class="separator:a82e6e188111c58827be610671fe3fb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60e2f7d4e1def8e22e8092f6ecde649" id="r_ae60e2f7d4e1def8e22e8092f6ecde649"><td class="memItemLeft" align="right" valign="top"><a id="ae60e2f7d4e1def8e22e8092f6ecde649" name="ae60e2f7d4e1def8e22e8092f6ecde649"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>get_nof_rb</b> () const</td></tr>
<tr class="memdesc:ae60e2f7d4e1def8e22e8092f6ecde649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of allocated VRB. <br /></td></tr>
<tr class="separator:ae60e2f7d4e1def8e22e8092f6ecde649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff159e20220d4f65d552a24fbf6bf651" id="r_aff159e20220d4f65d552a24fbf6bf651"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff159e20220d4f65d552a24fbf6bf651">is_bwp_valid</a> (unsigned bwp_start_rb, unsigned bwp_size_rb) const</td></tr>
<tr class="memdesc:aff159e20220d4f65d552a24fbf6bf651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the resource block allocation is valid for a given bandwidth part.  <br /></td></tr>
<tr class="separator:aff159e20220d4f65d552a24fbf6bf651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4742e3a79eea3d38e3aaba7d17301ac4" id="r_a4742e3a79eea3d38e3aaba7d17301ac4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrsran_1_1bounded__bitset.html">bounded_bitset</a>&lt; MAX_RB &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4742e3a79eea3d38e3aaba7d17301ac4">get_prb_mask</a> (unsigned bwp_start_rb, unsigned bwp_size_rb) const</td></tr>
<tr class="memdesc:a4742e3a79eea3d38e3aaba7d17301ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the PRB allocation mask for the frequency domain allocation.  <br /></td></tr>
<tr class="separator:a4742e3a79eea3d38e3aaba7d17301ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9c90b67ebb0b15838289d73ce6475c" id="r_a9e9c90b67ebb0b15838289d73ce6475c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrsran_1_1static__vector.html">static_vector</a>&lt; uint16_t, MAX_RB &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e9c90b67ebb0b15838289d73ce6475c">get_prb_indices</a> (unsigned bwp_start_rb, unsigned bwp_size_rb) const</td></tr>
<tr class="memdesc:a9e9c90b67ebb0b15838289d73ce6475c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the PRB allocation indexes for the frequency domain allocation.  <br /></td></tr>
<tr class="separator:a9e9c90b67ebb0b15838289d73ce6475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a19d5a57bcce401e95415548136018855" id="r_a19d5a57bcce401e95415548136018855"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsrsran_1_1rb__allocation.html">rb_allocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d5a57bcce401e95415548136018855">make_type0</a> (const <a class="el" href="classsrsran_1_1bounded__bitset.html">bounded_bitset</a>&lt; MAX_RB &gt; &amp;vrb_bitmap, const <a class="el" href="classsrsran_1_1optional.html">optional</a>&lt; <a class="el" href="classsrsran_1_1vrb__to__prb__mapper.html">vrb_to_prb_mapper</a> &gt; &amp;vrb_to_prb_map_={})</td></tr>
<tr class="memdesc:a19d5a57bcce401e95415548136018855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Type 0 RB allocation object.  <br /></td></tr>
<tr class="separator:a19d5a57bcce401e95415548136018855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1861747820537bc3e81b2ac9b03d96" id="r_a2c1861747820537bc3e81b2ac9b03d96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsrsran_1_1rb__allocation.html">rb_allocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c1861747820537bc3e81b2ac9b03d96">make_type1</a> (unsigned rb_start, unsigned rb_count, const <a class="el" href="classsrsran_1_1optional.html">optional</a>&lt; <a class="el" href="classsrsran_1_1vrb__to__prb__mapper.html">vrb_to_prb_mapper</a> &gt; &amp;vrb_to_prb_map_={})</td></tr>
<tr class="memdesc:a2c1861747820537bc3e81b2ac9b03d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Type 1 RB allocation object.  <br /></td></tr>
<tr class="separator:a2c1861747820537bc3e81b2ac9b03d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1078c9f5cc61e34f72ae1bb518da6d0" id="r_ae1078c9f5cc61e34f72ae1bb518da6d0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsrsran_1_1rb__allocation.html">rb_allocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1078c9f5cc61e34f72ae1bb518da6d0">make_custom</a> (std::initializer_list&lt; const unsigned &gt; vrb_indexes, const <a class="el" href="classsrsran_1_1optional.html">optional</a>&lt; <a class="el" href="classsrsran_1_1vrb__to__prb__mapper.html">vrb_to_prb_mapper</a> &gt; &amp;vrb_to_prb_map_={})</td></tr>
<tr class="memdesc:ae1078c9f5cc61e34f72ae1bb518da6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a custom allocation object using a list of VRB indexes.  <br /></td></tr>
<tr class="separator:ae1078c9f5cc61e34f72ae1bb518da6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Describes the frequency allocation for PDSCH and PUSCH transmissions. </p>
<p>The frequency allocation is defined at VRB level and it can be of type 0, type 1 or custom. Frequency allocation Types 0 and 1 are described in TS38.214 Section 5.1.2.2 for PDSCH and Section 6.1.2.2 for PUSCH.</p>
<p>The VRB allocation is made using one of the maker methods:</p><ul>
<li><a class="el" href="#a19d5a57bcce401e95415548136018855" title="Creates a Type 0 RB allocation object.">make_type0()</a> for making a type0 allocation,</li>
<li><a class="el" href="#a2c1861747820537bc3e81b2ac9b03d96" title="Creates a Type 1 RB allocation object.">make_type1()</a> for making a type1 allocation, or</li>
<li><a class="el" href="#ae1078c9f5cc61e34f72ae1bb518da6d0" title="Creates a custom allocation object using a list of VRB indexes.">make_custom()</a> for making a custom allocation.</li>
</ul>
<p>Each of the makers optionally take a VRB-to-PRB mapper for PDSCH transmissions. If the VRB-to-PRB mapper is not provided, the VRB-to-PRB is defaulted. The default VRB-to-PRB mapper corresponds to non-interleaved and to a PDSCH transmission is not scheduled in a common SS.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsrsran_1_1vrb__to__prb__mapper.html" title="Describes a VRB-to-PRB mapping.">vrb_to_prb_mapper</a> for more information regarding the VRB-to-PRB mapping for PDSCH.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The default constructor <a class="el" href="#afc67b968fd627acaf5b6121aab0c84c3" title="Default constructor.">rb_allocation()</a> does not allocate any VRB.</li>
<li>Use <a class="el" href="#a371f2f118ca976f0a2958c7f6d4baf0e" title="Determines if resultant VRB-to-PRB allocation is contiguous in frequency domain.">is_contiguous()</a> to determine whether the resultant allocation on the resource grid is contiguous.</li>
<li>Use <a class="el" href="#a9e9c90b67ebb0b15838289d73ce6475c" title="Generates the PRB allocation indexes for the frequency domain allocation.">get_prb_indices()</a> to generate the list of PRB indices.</li>
<li>If the resultant physical allocation is contiguous, the methods <a class="el" href="#a1f8e75c73e734a72c89d6f4052102a98" title="Gets the lowest allocated PRB index.">get_prb_begin()</a> and <a class="el" href="#a82e6e188111c58827be610671fe3fb93" title="Gets the highest allocated PRB index plus one.">get_prb_end()</a> can be used to determine the first and last PRB indices without requiring to generate a list of PRB indices.</li>
<li>Independently of the allocation type and VRB-to-PRB mapping, the method <a class="el" href="#a4742e3a79eea3d38e3aaba7d17301ac4" title="Generates the PRB allocation mask for the frequency domain allocation.">get_prb_mask()</a> generates a mask indicating the PRB used for the transmission. </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afc67b968fd627acaf5b6121aab0c84c3" name="afc67b968fd627acaf5b6121aab0c84c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc67b968fd627acaf5b6121aab0c84c3">&#9670;&#160;</a></span>rb_allocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">srsran::rb_allocation::rb_allocation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>It constructs an empty allocation with default VRB-to-PRB mapping. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f8e75c73e734a72c89d6f4052102a98" name="a1f8e75c73e734a72c89d6f4052102a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8e75c73e734a72c89d6f4052102a98">&#9670;&#160;</a></span>get_prb_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned srsran::rb_allocation::get_prb_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>bwp_start_rb</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the lowest allocated PRB index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bwp_start_rb</td><td>Indicates the BWP lowest PRB index relative to CRB0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A PRB index relative to CRB0 (PointA) if there are active VRB. Otherwise, zero. </dd></dl>

</div>
</div>
<a id="a82e6e188111c58827be610671fe3fb93" name="a82e6e188111c58827be610671fe3fb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e6e188111c58827be610671fe3fb93">&#9670;&#160;</a></span>get_prb_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned srsran::rb_allocation::get_prb_end </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>bwp_start_rb</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the highest allocated PRB index plus one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bwp_start_rb</td><td>Indicates the BWP lowest PRB index relative to CRB0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-zero PRB index relative to CRB0 (PointA) if there are active VRB. Otherwise, zero. </dd></dl>

</div>
</div>
<a id="a9e9c90b67ebb0b15838289d73ce6475c" name="a9e9c90b67ebb0b15838289d73ce6475c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9c90b67ebb0b15838289d73ce6475c">&#9670;&#160;</a></span>get_prb_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrsran_1_1static__vector.html">static_vector</a>&lt; uint16_t, MAX_RB &gt; rb_allocation::get_prb_indices </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>bwp_start_rb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>bwp_size_rb</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the PRB allocation indexes for the frequency domain allocation. </p>
<p>Calculates the PRB allocation indexes considering the BWP frequency allocation, the VRB mask and the VRB-to-PRB mapping.</p>
<p>The resultant indices are represented in a <code>static_vector&lt;uint16_t,MAX_RB&gt;</code> of size <picture><source srcset="form_79_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N_{BWP,i}^{start}+N_{BWP,i}^{size}$" src="form_79.png"/></picture>. The indices are relative to CRB0 (PointA) and they are indexed in VRB increasing order. In other words, the first index indicates the PRB index of the lowest active VRB. Correspondingly, the last index corresponds to the highest active VRB.</p>
<p>This method is intended for non-contiguous and/or interleaved allocation. For contiguous non-interleaved transmission use <code><a class="el" href="#a1f8e75c73e734a72c89d6f4052102a98" title="Gets the lowest allocated PRB index.">get_prb_begin()</a></code> and <code><a class="el" href="#a82e6e188111c58827be610671fe3fb93" title="Gets the highest allocated PRB index plus one.">get_prb_end()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bwp_start_rb</td><td>Indicates the BWP lowest PRB index relative to CRB0 (PointA) as <picture><source srcset="form_77_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N_{BWP,i}^{start}$" src="form_77.png"/></picture>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bwp_size_rb</td><td>Indicates the BWP size in PRB as <picture><source srcset="form_78_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N_{BWP,i}^{size}$" src="form_78.png"/></picture>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resultant PRB allocation indices represented as a static vector. </dd></dl>

</div>
</div>
<a id="a4742e3a79eea3d38e3aaba7d17301ac4" name="a4742e3a79eea3d38e3aaba7d17301ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4742e3a79eea3d38e3aaba7d17301ac4">&#9670;&#160;</a></span>get_prb_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrsran_1_1bounded__bitset.html">bounded_bitset</a>&lt; MAX_RB &gt; rb_allocation::get_prb_mask </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>bwp_start_rb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>bwp_size_rb</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the PRB allocation mask for the frequency domain allocation. </p>
<p>Calculates the PRB allocation mask considering the BWP frequency allocation, the VRB mask and the VRB-to-PRB mapping.</p>
<p>The resultant mask is represented in a <code><a class="el" href="classsrsran_1_1bounded__bitset.html">bounded_bitset&lt;MAX_RB&gt;</a></code> of size <picture><source srcset="form_79_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N_{BWP,i}^{start}+N_{BWP,i}^{size}$" src="form_79.png"/></picture> in which every set bit represents an active PRB. The first bit of the mask belongs to CRB0 (PointA).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bwp_start_rb</td><td>Indicates the BWP lowest PRB index relative to CRB0 (PointA) as <picture><source srcset="form_77_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N_{BWP,i}^{start}$" src="form_77.png"/></picture>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bwp_size_rb</td><td>Indicates the BWP size in PRB as <picture><source srcset="form_78_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N_{BWP,i}^{size}$" src="form_78.png"/></picture>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The PRB allocation mask represented as a bounded bitset. </dd></dl>

</div>
</div>
<a id="aff159e20220d4f65d552a24fbf6bf651" name="aff159e20220d4f65d552a24fbf6bf651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff159e20220d4f65d552a24fbf6bf651">&#9670;&#160;</a></span>is_bwp_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool srsran::rb_allocation::is_bwp_valid </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>bwp_start_rb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>bwp_size_rb</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the resource block allocation is valid for a given bandwidth part. </p>
<p>The resource block allocation combined with the BWP parameters are valid if:</p><ul>
<li>the sum of the BWP start and size does not exceed MAX_RB; and</li>
<li>the size of the virtual resource block allocation does not exceed the size of the available physical resources.</li>
</ul>
<p>For PDSCH transmissions scheduled by DCI in a common SS, the PRBs used for VRB to PRB mapping start from the lowest numbered resource block in the CORESET. For all other allocations, the available physical resources for VRB to PRB mapping comprise the entire BWP size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bwp_start_rb</td><td>Lowest PRB index of the BWP relative to CRB0 (PointA), i.e. <picture><source srcset="form_77_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N_{BWP,i}^{start}$" src="form_77.png"/></picture>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bwp_size_rb</td><td>BWP size in PRB, i.e. <picture><source srcset="form_78_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N_{BWP,i}^{size}$" src="form_78.png"/></picture>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the combination of BWP and resource block is valid, false otherwise. </dd></dl>

</div>
</div>
<a id="a371f2f118ca976f0a2958c7f6d4baf0e" name="a371f2f118ca976f0a2958c7f6d4baf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371f2f118ca976f0a2958c7f6d4baf0e">&#9670;&#160;</a></span>is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool srsran::rb_allocation::is_contiguous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if resultant VRB-to-PRB allocation is contiguous in frequency domain. </p>
<p>The PRB allocation is contiguous if:</p><ul>
<li>the VRB allocated for the transmission are contiguous, and</li>
<li>the VRB-to-PRB mapping is not interleaved.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if the PRB allocation is contiguous. Otherwise, false. </dd></dl>

</div>
</div>
<a id="ae1078c9f5cc61e34f72ae1bb518da6d0" name="ae1078c9f5cc61e34f72ae1bb518da6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1078c9f5cc61e34f72ae1bb518da6d0">&#9670;&#160;</a></span>make_custom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrsran_1_1rb__allocation.html">rb_allocation</a> srsran::rb_allocation::make_custom </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const unsigned &gt;</td>          <td class="paramname"><span class="paramname"><em>vrb_indexes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsrsran_1_1optional.html">optional</a>&lt; <a class="el" href="classsrsran_1_1vrb__to__prb__mapper.html">vrb_to_prb_mapper</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vrb_to_prb_map_</em><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a custom allocation object using a list of VRB indexes. </p>
<p>The custom allocation is indexed for testing and it is not described in the TS. The VRB mask is constructed from an integer initializer list that indicates the VRBs used for the PDSCH or PUSCH transmission.</p>
<p>The index list order is irrelevant and the index zero represents VRB0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vrb_indexes</td><td>Provides the VRB indexes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrb_to_prb_map_</td><td>Optional VRB-to-PRB mapping (for PDSCH only). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An RB allocation instance. </dd></dl>

</div>
</div>
<a id="a19d5a57bcce401e95415548136018855" name="a19d5a57bcce401e95415548136018855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d5a57bcce401e95415548136018855">&#9670;&#160;</a></span>make_type0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrsran_1_1rb__allocation.html">rb_allocation</a> srsran::rb_allocation::make_type0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsrsran_1_1bounded__bitset.html">bounded_bitset</a>&lt; MAX_RB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vrb_bitmap</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsrsran_1_1optional.html">optional</a>&lt; <a class="el" href="classsrsran_1_1vrb__to__prb__mapper.html">vrb_to_prb_mapper</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vrb_to_prb_map_</em><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Type 0 RB allocation object. </p>
<p>Type 0 allocation is described in TS38.214 Section 5.1.2.2.1 for PDSCH and Section 6.1.2.2.1 for PUSCH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vrb_bitmap</td><td>VRB allocation bitmap in which each entry represents an active RB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrb_to_prb_map_</td><td>Optional VRB-to-PRB mapping (for PDSCH only). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An RB allocation instance. </dd></dl>

</div>
</div>
<a id="a2c1861747820537bc3e81b2ac9b03d96" name="a2c1861747820537bc3e81b2ac9b03d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1861747820537bc3e81b2ac9b03d96">&#9670;&#160;</a></span>make_type1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrsran_1_1rb__allocation.html">rb_allocation</a> srsran::rb_allocation::make_type1 </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>rb_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>rb_count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsrsran_1_1optional.html">optional</a>&lt; <a class="el" href="classsrsran_1_1vrb__to__prb__mapper.html">vrb_to_prb_mapper</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vrb_to_prb_map_</em><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Type 1 RB allocation object. </p>
<p>Type 1 allocation is described in TS38.214 Section 5.1.2.2.2 for PDSCH and Section 6.1.2.2.2 for PUSCH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rb_start</td><td>Indicates the lowest VRB used for this transmission as <picture><source srcset="form_75_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$RB_{start}$" src="form_75.png"/></picture>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rb_count</td><td>Indicates the number of consecutive active VRB for this transmission as <picture><source srcset="form_76_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$L_{RB_s}$" src="form_76.png"/></picture>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrb_to_prb_map_</td><td>Optional VRB-to-PRB mapping (for PDSCH only). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An RB allocation instance. </dd></dl>

</div>
</div>
<a id="a0aaf27d8deb6f93f0458ebef2dadb4dc" name="a0aaf27d8deb6f93f0458ebef2dadb4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aaf27d8deb6f93f0458ebef2dadb4dc">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool srsran::rb_allocation::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsrsran_1_1rb__allocation.html">rb_allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two frequency domain allocations. </p>
<p>Two allocations are considered equal if:</p><ul>
<li>their VRB masks are equal, and</li>
<li>the VRB-to-PRB mapping is equal. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/srsran/phy/upper/<a class="el" href="rb__allocation_8h_source.html">rb_allocation.h</a></li>
<li>lib/phy/upper/<b>rb_allocation.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
