<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>srsRAN Docs: moodycamel::ConcurrentQueue&lt; T, Traits &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">srsRAN Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>moodycamel</b></li><li class="navelem"><a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d7/d3c/classmoodycamel_1_1ConcurrentQueue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">moodycamel::ConcurrentQueue&lt; T, Traits &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for moodycamel::ConcurrentQueue&lt; T, Traits &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/dc2/classmoodycamel_1_1ConcurrentQueue__inherit__graph.png" border="0" usemap="#amoodycamel_1_1ConcurrentQueue_3_01T_00_01Traits_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="amoodycamel_1_1ConcurrentQueue_3_01T_00_01Traits_01_4_inherit__map" id="amoodycamel_1_1ConcurrentQueue_3_01T_00_01Traits_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="5,5,280,469"/>
<area shape="rect" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html" title=" " alt="" coords="5,547,280,1025"/>
<area shape="poly" title=" " alt="" coords="145,483,145,546,140,546,140,483"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for moodycamel::ConcurrentQueue&lt; T, Traits &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="../../d7/d71/classmoodycamel_1_1ConcurrentQueue__coll__graph.png" border="0" usemap="#amoodycamel_1_1ConcurrentQueue_3_01T_00_01Traits_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="amoodycamel_1_1ConcurrentQueue_3_01T_00_01Traits_01_4_coll__map" id="amoodycamel_1_1ConcurrentQueue_3_01T_00_01Traits_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="61,265,281,565"/>
<area shape="rect" title=" " alt="" coords="5,5,136,71"/>
<area shape="poly" title=" " alt="" coords="69,71,64,149,66,195,75,241,77,249,72,251,69,242,61,196,59,149,63,71"/>
<area shape="rect" title=" " alt="" coords="239,5,305,71"/>
<area shape="poly" title=" " alt="" coords="273,71,264,150,245,242,243,250,238,249,240,241,259,149,267,71"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a741ef2316bcd1e8cbdeafdc36ad90d83" id="r_a741ef2316bcd1e8cbdeafdc36ad90d83"><td class="memItemLeft" align="right" valign="top"><a id="a741ef2316bcd1e8cbdeafdc36ad90d83" name="a741ef2316bcd1e8cbdeafdc36ad90d83"></a>
typedef <a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">::moodycamel::ProducerToken</a>&#160;</td><td class="memItemRight" valign="bottom"><b>producer_token_t</b></td></tr>
<tr class="separator:a741ef2316bcd1e8cbdeafdc36ad90d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd2c9d220d40f51177cfad5754aa7b5" id="r_acbd2c9d220d40f51177cfad5754aa7b5"><td class="memItemLeft" align="right" valign="top"><a id="acbd2c9d220d40f51177cfad5754aa7b5" name="acbd2c9d220d40f51177cfad5754aa7b5"></a>
typedef <a class="el" href="../../de/deb/structmoodycamel_1_1ConsumerToken.html">::moodycamel::ConsumerToken</a>&#160;</td><td class="memItemRight" valign="bottom"><b>consumer_token_t</b></td></tr>
<tr class="separator:acbd2c9d220d40f51177cfad5754aa7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68d536c896de4e839dd95225e7deea3" id="r_ad68d536c896de4e839dd95225e7deea3"><td class="memItemLeft" align="right" valign="top"><a id="ad68d536c896de4e839dd95225e7deea3" name="ad68d536c896de4e839dd95225e7deea3"></a>
typedef Traits::index_t&#160;</td><td class="memItemRight" valign="bottom"><b>index_t</b></td></tr>
<tr class="separator:ad68d536c896de4e839dd95225e7deea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b73313ed107d313b55c8a77be19b28" id="r_ac0b73313ed107d313b55c8a77be19b28"><td class="memItemLeft" align="right" valign="top"><a id="ac0b73313ed107d313b55c8a77be19b28" name="ac0b73313ed107d313b55c8a77be19b28"></a>
typedef Traits::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_t</b></td></tr>
<tr class="separator:ac0b73313ed107d313b55c8a77be19b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8dd7a33cf3174548a2b5f758331c5e48" id="r_a8dd7a33cf3174548a2b5f758331c5e48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dd7a33cf3174548a2b5f758331c5e48">ConcurrentQueue</a> (size_t capacity=32 *BLOCK_SIZE)</td></tr>
<tr class="separator:a8dd7a33cf3174548a2b5f758331c5e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad327feb7a7e861051d1dfd61e2ffa1df" id="r_ad327feb7a7e861051d1dfd61e2ffa1df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad327feb7a7e861051d1dfd61e2ffa1df">ConcurrentQueue</a> (size_t minCapacity, size_t maxExplicitProducers, size_t maxImplicitProducers)</td></tr>
<tr class="separator:ad327feb7a7e861051d1dfd61e2ffa1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4b08c6b6db7bf0df041619d133171c" id="r_a1b4b08c6b6db7bf0df041619d133171c"><td class="memItemLeft" align="right" valign="top"><a id="a1b4b08c6b6db7bf0df041619d133171c" name="a1b4b08c6b6db7bf0df041619d133171c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ConcurrentQueue</b> (<a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a> const &amp;) MOODYCAMEL_DELETE_FUNCTION</td></tr>
<tr class="separator:a1b4b08c6b6db7bf0df041619d133171c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378eb0bbe9ed755db54f93bd316d6c51" id="r_a378eb0bbe9ed755db54f93bd316d6c51"><td class="memItemLeft" align="right" valign="top"><a id="a378eb0bbe9ed755db54f93bd316d6c51" name="a378eb0bbe9ed755db54f93bd316d6c51"></a>
<a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a> const &amp;) MOODYCAMEL_DELETE_FUNCTION</td></tr>
<tr class="separator:a378eb0bbe9ed755db54f93bd316d6c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae908c026d0eb0591ca6f8f5518f7ffdf" id="r_ae908c026d0eb0591ca6f8f5518f7ffdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae908c026d0eb0591ca6f8f5518f7ffdf">ConcurrentQueue</a> (<a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a> &amp;&amp;other) MOODYCAMEL_NOEXCEPT</td></tr>
<tr class="separator:ae908c026d0eb0591ca6f8f5518f7ffdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce8e204950aa2f7668c0cb4af2cdfd8" id="r_abce8e204950aa2f7668c0cb4af2cdfd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abce8e204950aa2f7668c0cb4af2cdfd8">operator=</a> (<a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a> &amp;&amp;other) MOODYCAMEL_NOEXCEPT</td></tr>
<tr class="separator:abce8e204950aa2f7668c0cb4af2cdfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1c42c76a8218896a4d76efed142b2c" id="r_a7c1c42c76a8218896a4d76efed142b2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c1c42c76a8218896a4d76efed142b2c">swap</a> (<a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a> &amp;other) MOODYCAMEL_NOEXCEPT</td></tr>
<tr class="separator:a7c1c42c76a8218896a4d76efed142b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaa7271014aa901829e3ed1b1005d65" id="r_aceaa7271014aa901829e3ed1b1005d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aceaa7271014aa901829e3ed1b1005d65">enqueue</a> (T const &amp;item)</td></tr>
<tr class="separator:aceaa7271014aa901829e3ed1b1005d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a36bd689aeaffd635416a4279566198" id="r_a4a36bd689aeaffd635416a4279566198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a36bd689aeaffd635416a4279566198">enqueue</a> (T &amp;&amp;item)</td></tr>
<tr class="separator:a4a36bd689aeaffd635416a4279566198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5882e6e7a053e27427709f11094dae" id="r_a0b5882e6e7a053e27427709f11094dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b5882e6e7a053e27427709f11094dae">enqueue</a> (<a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;token, T const &amp;item)</td></tr>
<tr class="separator:a0b5882e6e7a053e27427709f11094dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e27b67c2aa7b4fc2eb0777fa6bd7cbc" id="r_a0e27b67c2aa7b4fc2eb0777fa6bd7cbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e27b67c2aa7b4fc2eb0777fa6bd7cbc">enqueue</a> (<a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;token, T &amp;&amp;item)</td></tr>
<tr class="separator:a0e27b67c2aa7b4fc2eb0777fa6bd7cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b0aa33a19538a7c97d839fbf0d8459" id="r_a57b0aa33a19538a7c97d839fbf0d8459"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a57b0aa33a19538a7c97d839fbf0d8459"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57b0aa33a19538a7c97d839fbf0d8459">enqueue_bulk</a> (It itemFirst, size_t count)</td></tr>
<tr class="separator:a57b0aa33a19538a7c97d839fbf0d8459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4b16a77535cc57fa3c76fb5ee3fba" id="r_a61a4b16a77535cc57fa3c76fb5ee3fba"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a61a4b16a77535cc57fa3c76fb5ee3fba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a61a4b16a77535cc57fa3c76fb5ee3fba">enqueue_bulk</a> (<a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;token, It itemFirst, size_t count)</td></tr>
<tr class="separator:a61a4b16a77535cc57fa3c76fb5ee3fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab76643a98e1094cecdd213fbb6e75d" id="r_aaab76643a98e1094cecdd213fbb6e75d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaab76643a98e1094cecdd213fbb6e75d">try_enqueue</a> (T const &amp;item)</td></tr>
<tr class="separator:aaab76643a98e1094cecdd213fbb6e75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63a4f51a8b8b6c59ea883ed97fff7a2" id="r_af63a4f51a8b8b6c59ea883ed97fff7a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af63a4f51a8b8b6c59ea883ed97fff7a2">try_enqueue</a> (T &amp;&amp;item)</td></tr>
<tr class="separator:af63a4f51a8b8b6c59ea883ed97fff7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04237577ca981e18e23190773cf1644" id="r_ad04237577ca981e18e23190773cf1644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad04237577ca981e18e23190773cf1644">try_enqueue</a> (<a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;token, T const &amp;item)</td></tr>
<tr class="separator:ad04237577ca981e18e23190773cf1644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049a33d4127c66a614b717cf20bba330" id="r_a049a33d4127c66a614b717cf20bba330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a049a33d4127c66a614b717cf20bba330">try_enqueue</a> (<a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;token, T &amp;&amp;item)</td></tr>
<tr class="separator:a049a33d4127c66a614b717cf20bba330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbe38c03c23ea980d1bc1f9445d26c2" id="r_aecbe38c03c23ea980d1bc1f9445d26c2"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:aecbe38c03c23ea980d1bc1f9445d26c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aecbe38c03c23ea980d1bc1f9445d26c2">try_enqueue_bulk</a> (It itemFirst, size_t count)</td></tr>
<tr class="separator:aecbe38c03c23ea980d1bc1f9445d26c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359380c0d6952e61f3ef4811808eb573" id="r_a359380c0d6952e61f3ef4811808eb573"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a359380c0d6952e61f3ef4811808eb573"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a359380c0d6952e61f3ef4811808eb573">try_enqueue_bulk</a> (<a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;token, It itemFirst, size_t count)</td></tr>
<tr class="separator:a359380c0d6952e61f3ef4811808eb573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1895c8a6120aef578fe01db53879517b" id="r_a1895c8a6120aef578fe01db53879517b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1895c8a6120aef578fe01db53879517b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1895c8a6120aef578fe01db53879517b">try_dequeue</a> (U &amp;item)</td></tr>
<tr class="separator:a1895c8a6120aef578fe01db53879517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f25d247543755bdc1b477f2678455f" id="r_ad9f25d247543755bdc1b477f2678455f"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ad9f25d247543755bdc1b477f2678455f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9f25d247543755bdc1b477f2678455f">try_dequeue_non_interleaved</a> (U &amp;item)</td></tr>
<tr class="separator:ad9f25d247543755bdc1b477f2678455f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d5a2377539808015044acbb34216d1" id="r_a67d5a2377539808015044acbb34216d1"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a67d5a2377539808015044acbb34216d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a67d5a2377539808015044acbb34216d1">try_dequeue</a> (<a class="el" href="../../de/deb/structmoodycamel_1_1ConsumerToken.html">consumer_token_t</a> &amp;token, U &amp;item)</td></tr>
<tr class="separator:a67d5a2377539808015044acbb34216d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816450a4b774c374ef8ee0234e7c4518" id="r_a816450a4b774c374ef8ee0234e7c4518"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a816450a4b774c374ef8ee0234e7c4518"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a816450a4b774c374ef8ee0234e7c4518">try_dequeue_bulk</a> (It itemFirst, size_t max)</td></tr>
<tr class="separator:a816450a4b774c374ef8ee0234e7c4518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e6b02051baed9cc1b3fb5e46743c03" id="r_a57e6b02051baed9cc1b3fb5e46743c03"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a57e6b02051baed9cc1b3fb5e46743c03"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57e6b02051baed9cc1b3fb5e46743c03">try_dequeue_bulk</a> (<a class="el" href="../../de/deb/structmoodycamel_1_1ConsumerToken.html">consumer_token_t</a> &amp;token, It itemFirst, size_t max)</td></tr>
<tr class="separator:a57e6b02051baed9cc1b3fb5e46743c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609358c281fb44c88088f229c47e424d" id="r_a609358c281fb44c88088f229c47e424d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a609358c281fb44c88088f229c47e424d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a609358c281fb44c88088f229c47e424d">try_dequeue_from_producer</a> (<a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;producer, U &amp;item)</td></tr>
<tr class="separator:a609358c281fb44c88088f229c47e424d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfc50210d50dba266431ff82b908da7" id="r_a1cfc50210d50dba266431ff82b908da7"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a1cfc50210d50dba266431ff82b908da7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1cfc50210d50dba266431ff82b908da7">try_dequeue_bulk_from_producer</a> (<a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;producer, It itemFirst, size_t max)</td></tr>
<tr class="separator:a1cfc50210d50dba266431ff82b908da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecab179b995f119c89da71f62b2d21a5" id="r_aecab179b995f119c89da71f62b2d21a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecab179b995f119c89da71f62b2d21a5">size_approx</a> () const</td></tr>
<tr class="separator:aecab179b995f119c89da71f62b2d21a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a926d7d31e785e36c61810d066ba4fba3" id="r_a926d7d31e785e36c61810d066ba4fba3"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a926d7d31e785e36c61810d066ba4fba3">is_lock_free</a> ()</td></tr>
<tr class="separator:a926d7d31e785e36c61810d066ba4fba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae555aae96010307e7991b1028b41cfb8" id="r_ae555aae96010307e7991b1028b41cfb8"><td class="memItemLeft" align="right" valign="top"><a id="ae555aae96010307e7991b1028b41cfb8" name="ae555aae96010307e7991b1028b41cfb8"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>BLOCK_SIZE</b> = static_cast&lt;size_t&gt;(Traits::BLOCK_SIZE)</td></tr>
<tr class="separator:ae555aae96010307e7991b1028b41cfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadd55fc6ac80c277225977fe9bdecee" id="r_aaadd55fc6ac80c277225977fe9bdecee"><td class="memItemLeft" align="right" valign="top"><a id="aaadd55fc6ac80c277225977fe9bdecee" name="aaadd55fc6ac80c277225977fe9bdecee"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD</b> = static_cast&lt;size_t&gt;(Traits::EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD)</td></tr>
<tr class="separator:aaadd55fc6ac80c277225977fe9bdecee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29231222f904afacd0c9ed55d67cd09" id="r_ae29231222f904afacd0c9ed55d67cd09"><td class="memItemLeft" align="right" valign="top"><a id="ae29231222f904afacd0c9ed55d67cd09" name="ae29231222f904afacd0c9ed55d67cd09"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>EXPLICIT_INITIAL_INDEX_SIZE</b> = static_cast&lt;size_t&gt;(Traits::EXPLICIT_INITIAL_INDEX_SIZE)</td></tr>
<tr class="separator:ae29231222f904afacd0c9ed55d67cd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a25b761a75bd2c3cd1f58037f9da89f" id="r_a9a25b761a75bd2c3cd1f58037f9da89f"><td class="memItemLeft" align="right" valign="top"><a id="a9a25b761a75bd2c3cd1f58037f9da89f" name="a9a25b761a75bd2c3cd1f58037f9da89f"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>IMPLICIT_INITIAL_INDEX_SIZE</b> = static_cast&lt;size_t&gt;(Traits::IMPLICIT_INITIAL_INDEX_SIZE)</td></tr>
<tr class="separator:a9a25b761a75bd2c3cd1f58037f9da89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f4615c06da9bca3be093123c7cc160" id="r_a52f4615c06da9bca3be093123c7cc160"><td class="memItemLeft" align="right" valign="top"><a id="a52f4615c06da9bca3be093123c7cc160" name="a52f4615c06da9bca3be093123c7cc160"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>INITIAL_IMPLICIT_PRODUCER_HASH_SIZE</b> = static_cast&lt;size_t&gt;(Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE)</td></tr>
<tr class="separator:a52f4615c06da9bca3be093123c7cc160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8593fb32003144c034323c8fe353c359" id="r_a8593fb32003144c034323c8fe353c359"><td class="memItemLeft" align="right" valign="top"><a id="a8593fb32003144c034323c8fe353c359" name="a8593fb32003144c034323c8fe353c359"></a>
static const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE</b> = static_cast&lt;std::uint32_t&gt;(Traits::EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE)</td></tr>
<tr class="separator:a8593fb32003144c034323c8fe353c359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2302943ed9b7579ec9b9f6863c57f10a" id="r_a2302943ed9b7579ec9b9f6863c57f10a"><td class="memItemLeft" align="right" valign="top"><a id="a2302943ed9b7579ec9b9f6863c57f10a" name="a2302943ed9b7579ec9b9f6863c57f10a"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_SUBQUEUE_SIZE</b> = (<a class="el" href="../../d8/d7d/structmoodycamel_1_1details_1_1const__numeric__max.html">details::const_numeric_max</a>&lt;size_t&gt;::value - static_cast&lt;size_t&gt;(Traits::MAX_SUBQUEUE_SIZE) &lt; BLOCK_SIZE) ? <a class="el" href="../../d8/d7d/structmoodycamel_1_1details_1_1const__numeric__max.html">details::const_numeric_max</a>&lt;size_t&gt;::value : ((static_cast&lt;size_t&gt;(Traits::MAX_SUBQUEUE_SIZE) + (BLOCK_SIZE - 1)) / BLOCK_SIZE * BLOCK_SIZE)</td></tr>
<tr class="separator:a2302943ed9b7579ec9b9f6863c57f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:acfb3304f9d64003d203b0d2dbc3fbc41" id="r_acfb3304f9d64003d203b0d2dbc3fbc41"><td class="memItemLeft" align="right" valign="top"><a id="acfb3304f9d64003d203b0d2dbc3fbc41" name="acfb3304f9d64003d203b0d2dbc3fbc41"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>ProducerToken</b></td></tr>
<tr class="separator:acfb3304f9d64003d203b0d2dbc3fbc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81aed503980c50c35b8447926e2581ec" id="r_a81aed503980c50c35b8447926e2581ec"><td class="memItemLeft" align="right" valign="top"><a id="a81aed503980c50c35b8447926e2581ec" name="a81aed503980c50c35b8447926e2581ec"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>ConsumerToken</b></td></tr>
<tr class="separator:a81aed503980c50c35b8447926e2581ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bebbfc18b6ad306d5837467e9c05323" id="r_a7bebbfc18b6ad306d5837467e9c05323"><td class="memItemLeft" align="right" valign="top"><a id="a7bebbfc18b6ad306d5837467e9c05323" name="a7bebbfc18b6ad306d5837467e9c05323"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>ExplicitProducer</b></td></tr>
<tr class="separator:a7bebbfc18b6ad306d5837467e9c05323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79e82aa1a04eb71ff8297700ff94d58" id="r_ab79e82aa1a04eb71ff8297700ff94d58"><td class="memItemLeft" align="right" valign="top"><a id="ab79e82aa1a04eb71ff8297700ff94d58" name="ab79e82aa1a04eb71ff8297700ff94d58"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>ImplicitProducer</b></td></tr>
<tr class="separator:ab79e82aa1a04eb71ff8297700ff94d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680d9a9301a3c7bb2380209214ace21e" id="r_a680d9a9301a3c7bb2380209214ace21e"><td class="memItemLeft" align="right" valign="top"><a id="a680d9a9301a3c7bb2380209214ace21e" name="a680d9a9301a3c7bb2380209214ace21e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ConcurrentQueueTests</b></td></tr>
<tr class="separator:a680d9a9301a3c7bb2380209214ace21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65cc3887b8b356dff18ac235c21d6fa" id="r_ad65cc3887b8b356dff18ac235c21d6fa"><td class="memTemplParams" colspan="2"><a id="ad65cc3887b8b356dff18ac235c21d6fa" name="ad65cc3887b8b356dff18ac235c21d6fa"></a>
template&lt;typename XT , typename XTraits &gt; </td></tr>
<tr class="memitem:ad65cc3887b8b356dff18ac235c21d6fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>moodycamel::swap</b> (typename <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a>&lt; XT, XTraits &gt;::ImplicitProducerKVP &amp;, typename <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a>&lt; XT, XTraits &gt;::ImplicitProducerKVP &amp;) MOODYCAMEL_NOEXCEPT</td></tr>
<tr class="separator:ad65cc3887b8b356dff18ac235c21d6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8dd7a33cf3174548a2b5f758331c5e48" name="a8dd7a33cf3174548a2b5f758331c5e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd7a33cf3174548a2b5f758331c5e48">&#9670;&#160;</a></span>ConcurrentQueue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::ConcurrentQueue </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em><span class="paramdefsep"> = </span><span class="paramdefval">32&#160;*&#160;BLOCK_SIZE</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  814</span>        : producerListTail(<span class="keyword">nullptr</span>),</div>
<div class="line"><span class="lineno">  815</span>        producerCount(0),</div>
<div class="line"><span class="lineno">  816</span>        initialBlockPoolIndex(0),</div>
<div class="line"><span class="lineno">  817</span>        nextExplicitConsumerId(0),</div>
<div class="line"><span class="lineno">  818</span>        globalExplicitConsumerOffset(0)</div>
<div class="line"><span class="lineno">  819</span>    {</div>
<div class="line"><span class="lineno">  820</span>        implicitProducerHashResizeInProgress.clear(std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  821</span>        populate_initial_implicit_producer_hash();</div>
<div class="line"><span class="lineno">  822</span>        populate_initial_block_list(capacity / BLOCK_SIZE + ((capacity &amp; (BLOCK_SIZE - 1)) == 0 ? 0 : 1));</div>
<div class="line"><span class="lineno">  823</span> </div>
<div class="line"><span class="lineno">  824</span><span class="preprocessor">#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG</span></div>
<div class="line"><span class="lineno">  825</span>        <span class="comment">// Track all the producers using a fully-resolved typed list for</span></div>
<div class="line"><span class="lineno">  826</span>        <span class="comment">// each kind; this makes it possible to debug them starting from</span></div>
<div class="line"><span class="lineno">  827</span>        <span class="comment">// the root queue object (otherwise wacky casts are needed that</span></div>
<div class="line"><span class="lineno">  828</span>        <span class="comment">// don&#39;t compile in the debugger&#39;s expression evaluator).</span></div>
<div class="line"><span class="lineno">  829</span>        explicitProducers.store(<span class="keyword">nullptr</span>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  830</span>        implicitProducers.store(<span class="keyword">nullptr</span>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  831</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  832</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad327feb7a7e861051d1dfd61e2ffa1df" name="ad327feb7a7e861051d1dfd61e2ffa1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad327feb7a7e861051d1dfd61e2ffa1df">&#9670;&#160;</a></span>ConcurrentQueue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::ConcurrentQueue </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>minCapacity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxExplicitProducers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxImplicitProducers</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  838</span>        : producerListTail(<span class="keyword">nullptr</span>),</div>
<div class="line"><span class="lineno">  839</span>        producerCount(0),</div>
<div class="line"><span class="lineno">  840</span>        initialBlockPoolIndex(0),</div>
<div class="line"><span class="lineno">  841</span>        nextExplicitConsumerId(0),</div>
<div class="line"><span class="lineno">  842</span>        globalExplicitConsumerOffset(0)</div>
<div class="line"><span class="lineno">  843</span>    {</div>
<div class="line"><span class="lineno">  844</span>        implicitProducerHashResizeInProgress.clear(std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  845</span>        populate_initial_implicit_producer_hash();</div>
<div class="line"><span class="lineno">  846</span>        <span class="keywordtype">size_t</span> blocks = (((minCapacity + BLOCK_SIZE - 1) / BLOCK_SIZE) - 1) * (maxExplicitProducers + 1) + 2 * (maxExplicitProducers + maxImplicitProducers);</div>
<div class="line"><span class="lineno">  847</span>        populate_initial_block_list(blocks);</div>
<div class="line"><span class="lineno">  848</span> </div>
<div class="line"><span class="lineno">  849</span><span class="preprocessor">#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG</span></div>
<div class="line"><span class="lineno">  850</span>        explicitProducers.store(<span class="keyword">nullptr</span>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  851</span>        implicitProducers.store(<span class="keyword">nullptr</span>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  852</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  853</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="add203e2137970f317f16cf347471b2f7" name="add203e2137970f317f16cf347471b2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add203e2137970f317f16cf347471b2f7">&#9670;&#160;</a></span>~ConcurrentQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::~<a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  859</span>    {</div>
<div class="line"><span class="lineno">  860</span>        <span class="comment">// Destroy producers</span></div>
<div class="line"><span class="lineno">  861</span>        <span class="keyword">auto</span> ptr = producerListTail.load(std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  862</span>        <span class="keywordflow">while</span> (ptr != <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  863</span>            <span class="keyword">auto</span> next = ptr-&gt;next_prod();</div>
<div class="line"><span class="lineno">  864</span>            <span class="keywordflow">if</span> (ptr-&gt;token != <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  865</span>                ptr-&gt;token-&gt;producer = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  866</span>            }</div>
<div class="line"><span class="lineno">  867</span>            destroy(ptr);</div>
<div class="line"><span class="lineno">  868</span>            ptr = next;</div>
<div class="line"><span class="lineno">  869</span>        }</div>
<div class="line"><span class="lineno">  870</span> </div>
<div class="line"><span class="lineno">  871</span>        <span class="comment">// Destroy implicit producer hash tables</span></div>
<div class="line"><span class="lineno">  872</span>        MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE != 0) {</div>
<div class="line"><span class="lineno">  873</span>            <span class="keyword">auto</span> hash = implicitProducerHash.load(std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  874</span>            <span class="keywordflow">while</span> (hash != <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  875</span>                <span class="keyword">auto</span> prev = hash-&gt;prev;</div>
<div class="line"><span class="lineno">  876</span>                <span class="keywordflow">if</span> (prev != <span class="keyword">nullptr</span>) {      <span class="comment">// The last hash is part of this object and was not allocated dynamically</span></div>
<div class="line"><span class="lineno">  877</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i != hash-&gt;capacity; ++i) {</div>
<div class="line"><span class="lineno">  878</span>                        hash-&gt;entries[i].~ImplicitProducerKVP();</div>
<div class="line"><span class="lineno">  879</span>                    }</div>
<div class="line"><span class="lineno">  880</span>                    hash-&gt;~ImplicitProducerHash();</div>
<div class="line"><span class="lineno">  881</span>                    (Traits::free)(hash);</div>
<div class="line"><span class="lineno">  882</span>                }</div>
<div class="line"><span class="lineno">  883</span>                hash = prev;</div>
<div class="line"><span class="lineno">  884</span>            }</div>
<div class="line"><span class="lineno">  885</span>        }</div>
<div class="line"><span class="lineno">  886</span> </div>
<div class="line"><span class="lineno">  887</span>        <span class="comment">// Destroy global free list</span></div>
<div class="line"><span class="lineno">  888</span>        <span class="keyword">auto</span> block = freeList.head_unsafe();</div>
<div class="line"><span class="lineno">  889</span>        <span class="keywordflow">while</span> (block != <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  890</span>            <span class="keyword">auto</span> next = block-&gt;freeListNext.load(std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  891</span>            <span class="keywordflow">if</span> (block-&gt;dynamicallyAllocated) {</div>
<div class="line"><span class="lineno">  892</span>                destroy(block);</div>
<div class="line"><span class="lineno">  893</span>            }</div>
<div class="line"><span class="lineno">  894</span>            block = next;</div>
<div class="line"><span class="lineno">  895</span>        }</div>
<div class="line"><span class="lineno">  896</span> </div>
<div class="line"><span class="lineno">  897</span>        <span class="comment">// Destroy initial free list</span></div>
<div class="line"><span class="lineno">  898</span>        destroy_array(initialBlockPool, initialBlockPoolSize);</div>
<div class="line"><span class="lineno">  899</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae908c026d0eb0591ca6f8f5518f7ffdf" name="ae908c026d0eb0591ca6f8f5518f7ffdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae908c026d0eb0591ca6f8f5518f7ffdf">&#9670;&#160;</a></span>ConcurrentQueue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::ConcurrentQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a>&lt; T, Traits &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  912</span>        : producerListTail(other.producerListTail.load(std::memory_order_relaxed)),</div>
<div class="line"><span class="lineno">  913</span>        producerCount(other.producerCount.load(std::memory_order_relaxed)),</div>
<div class="line"><span class="lineno">  914</span>        initialBlockPoolIndex(other.initialBlockPoolIndex.load(std::memory_order_relaxed)),</div>
<div class="line"><span class="lineno">  915</span>        initialBlockPool(other.initialBlockPool),</div>
<div class="line"><span class="lineno">  916</span>        initialBlockPoolSize(other.initialBlockPoolSize),</div>
<div class="line"><span class="lineno">  917</span>        freeList(std::move(other.freeList)),</div>
<div class="line"><span class="lineno">  918</span>        nextExplicitConsumerId(other.nextExplicitConsumerId.load(std::memory_order_relaxed)),</div>
<div class="line"><span class="lineno">  919</span>        globalExplicitConsumerOffset(other.globalExplicitConsumerOffset.load(std::memory_order_relaxed))</div>
<div class="line"><span class="lineno">  920</span>    {</div>
<div class="line"><span class="lineno">  921</span>        <span class="comment">// Move the other one into this, and leave the other one as an empty queue</span></div>
<div class="line"><span class="lineno">  922</span>        implicitProducerHashResizeInProgress.clear(std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  923</span>        populate_initial_implicit_producer_hash();</div>
<div class="line"><span class="lineno">  924</span>        swap_implicit_producer_hashes(other);</div>
<div class="line"><span class="lineno">  925</span> </div>
<div class="line"><span class="lineno">  926</span>        other.producerListTail.store(<span class="keyword">nullptr</span>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  927</span>        other.producerCount.store(0, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  928</span>        other.nextExplicitConsumerId.store(0, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  929</span>        other.globalExplicitConsumerOffset.store(0, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  930</span> </div>
<div class="line"><span class="lineno">  931</span><span class="preprocessor">#ifdef MOODYCAMEL_QUEUE_INTERNAL_DEBUG</span></div>
<div class="line"><span class="lineno">  932</span>        explicitProducers.store(other.explicitProducers.load(std::memory_order_relaxed), std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  933</span>        other.explicitProducers.store(<span class="keyword">nullptr</span>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  934</span>        implicitProducers.store(other.implicitProducers.load(std::memory_order_relaxed), std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  935</span>        other.implicitProducers.store(<span class="keyword">nullptr</span>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  936</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  937</span> </div>
<div class="line"><span class="lineno">  938</span>        other.initialBlockPoolIndex.store(0, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  939</span>        other.initialBlockPoolSize = 0;</div>
<div class="line"><span class="lineno">  940</span>        other.initialBlockPool = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  941</span> </div>
<div class="line"><span class="lineno">  942</span>        reown_producers();</div>
<div class="line"><span class="lineno">  943</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e27b67c2aa7b4fc2eb0777fa6bd7cbc" name="a0e27b67c2aa7b4fc2eb0777fa6bd7cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e27b67c2aa7b4fc2eb0777fa6bd7cbc">&#9670;&#160;</a></span>enqueue() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1026</span>    {</div>
<div class="line"><span class="lineno"> 1027</span>        <span class="keywordflow">return</span> inner_enqueue&lt;CanAlloc&gt;(token, std::move(item));</div>
<div class="line"><span class="lineno"> 1028</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b5882e6e7a053e27427709f11094dae" name="a0b5882e6e7a053e27427709f11094dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5882e6e7a053e27427709f11094dae">&#9670;&#160;</a></span>enqueue() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1017</span>    {</div>
<div class="line"><span class="lineno"> 1018</span>        <span class="keywordflow">return</span> inner_enqueue&lt;CanAlloc&gt;(token, item);</div>
<div class="line"><span class="lineno"> 1019</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a36bd689aeaffd635416a4279566198" name="a4a36bd689aeaffd635416a4279566198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a36bd689aeaffd635416a4279566198">&#9670;&#160;</a></span>enqueue() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1007</span>    {</div>
<div class="line"><span class="lineno"> 1008</span>        MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;</div>
<div class="line"><span class="lineno"> 1009</span>        else return inner_enqueue&lt;CanAlloc&gt;(std::move(item));</div>
<div class="line"><span class="lineno"> 1010</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aceaa7271014aa901829e3ed1b1005d65" name="aceaa7271014aa901829e3ed1b1005d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaa7271014aa901829e3ed1b1005d65">&#9670;&#160;</a></span>enqueue() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  996</span>    {</div>
<div class="line"><span class="lineno">  997</span>        MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;</div>
<div class="line"><span class="lineno">  998</span>        else return inner_enqueue&lt;CanAlloc&gt;(item);</div>
<div class="line"><span class="lineno">  999</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a57b0aa33a19538a7c97d839fbf0d8459" name="a57b0aa33a19538a7c97d839fbf0d8459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b0aa33a19538a7c97d839fbf0d8459">&#9670;&#160;</a></span>enqueue_bulk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::enqueue_bulk </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itemFirst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1038</span>    {</div>
<div class="line"><span class="lineno"> 1039</span>        MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;</div>
<div class="line"><span class="lineno"> 1040</span>        else return inner_enqueue_bulk&lt;CanAlloc&gt;(itemFirst, count);</div>
<div class="line"><span class="lineno"> 1041</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a61a4b16a77535cc57fa3c76fb5ee3fba" name="a61a4b16a77535cc57fa3c76fb5ee3fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a4b16a77535cc57fa3c76fb5ee3fba">&#9670;&#160;</a></span>enqueue_bulk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::enqueue_bulk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itemFirst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1051</span>    {</div>
<div class="line"><span class="lineno"> 1052</span>        <span class="keywordflow">return</span> inner_enqueue_bulk&lt;CanAlloc&gt;(token, itemFirst, count);</div>
<div class="line"><span class="lineno"> 1053</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a926d7d31e785e36c61810d066ba4fba3" name="a926d7d31e785e36c61810d066ba4fba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926d7d31e785e36c61810d066ba4fba3">&#9670;&#160;</a></span>is_lock_free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::is_lock_free </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1339</span>    {</div>
<div class="line"><span class="lineno"> 1340</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1341</span>            details::static_is_lock_free&lt;bool&gt;::value == 2 &amp;&amp;</div>
<div class="line"><span class="lineno"> 1342</span>            details::static_is_lock_free&lt;size_t&gt;::value == 2 &amp;&amp;</div>
<div class="line"><span class="lineno"> 1343</span>            details::static_is_lock_free&lt;std::uint32_t&gt;::value == 2 &amp;&amp;</div>
<div class="line"><span class="lineno"> 1344</span>            details::static_is_lock_free&lt;index_t&gt;::value == 2 &amp;&amp;</div>
<div class="line"><span class="lineno"> 1345</span>            details::static_is_lock_free&lt;void*&gt;::value == 2 &amp;&amp;</div>
<div class="line"><span class="lineno"> 1346</span>            details::static_is_lock_free&lt;typename details::thread_id_converter&lt;details::thread_id_t&gt;::thread_id_numeric_size_t&gt;::value == 2;</div>
<div class="line"><span class="lineno"> 1347</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abce8e204950aa2f7668c0cb4af2cdfd8" name="abce8e204950aa2f7668c0cb4af2cdfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce8e204950aa2f7668c0cb4af2cdfd8">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a> &amp; <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a>&lt; T, Traits &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  946</span>    {</div>
<div class="line"><span class="lineno">  947</span>        <span class="keywordflow">return</span> swap_internal(other);</div>
<div class="line"><span class="lineno">  948</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aecab179b995f119c89da71f62b2d21a5" name="aecab179b995f119c89da71f62b2d21a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecab179b995f119c89da71f62b2d21a5">&#9670;&#160;</a></span>size_approx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::size_approx </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1326</span>    {</div>
<div class="line"><span class="lineno"> 1327</span>        <span class="keywordtype">size_t</span> size = 0;</div>
<div class="line"><span class="lineno"> 1328</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> ptr = producerListTail.load(std::memory_order_acquire); ptr != <span class="keyword">nullptr</span>; ptr = ptr-&gt;next_prod()) {</div>
<div class="line"><span class="lineno"> 1329</span>            size += ptr-&gt;size_approx();</div>
<div class="line"><span class="lineno"> 1330</span>        }</div>
<div class="line"><span class="lineno"> 1331</span>        <span class="keywordflow">return</span> size;</div>
<div class="line"><span class="lineno"> 1332</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c1c42c76a8218896a4d76efed142b2c" name="a7c1c42c76a8218896a4d76efed142b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1c42c76a8218896a4d76efed142b2c">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">ConcurrentQueue</a>&lt; T, Traits &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  956</span>    {</div>
<div class="line"><span class="lineno">  957</span>        swap_internal(other);</div>
<div class="line"><span class="lineno">  958</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a67d5a2377539808015044acbb34216d1" name="a67d5a2377539808015044acbb34216d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d5a2377539808015044acbb34216d1">&#9670;&#160;</a></span>try_dequeue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/deb/structmoodycamel_1_1ConsumerToken.html">consumer_token_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1184</span>    {</div>
<div class="line"><span class="lineno"> 1185</span>        <span class="comment">// The idea is roughly as follows:</span></div>
<div class="line"><span class="lineno"> 1186</span>        <span class="comment">// Every 256 items from one producer, make everyone rotate (increase the global offset) -&gt; this means the highest efficiency consumer dictates the rotation speed of everyone else, more or less</span></div>
<div class="line"><span class="lineno"> 1187</span>        <span class="comment">// If you see that the global offset has changed, you must reset your consumption counter and move to your designated place</span></div>
<div class="line"><span class="lineno"> 1188</span>        <span class="comment">// If there&#39;s no items where you&#39;re supposed to be, keep moving until you find a producer with some items</span></div>
<div class="line"><span class="lineno"> 1189</span>        <span class="comment">// If the global offset has not changed but you&#39;ve run out of items to consume, move over from your current position until you find an producer with something in it</span></div>
<div class="line"><span class="lineno"> 1190</span> </div>
<div class="line"><span class="lineno"> 1191</span>        <span class="keywordflow">if</span> (token.desiredProducer == <span class="keyword">nullptr</span> || token.lastKnownGlobalOffset != globalExplicitConsumerOffset.load(std::memory_order_relaxed)) {</div>
<div class="line"><span class="lineno"> 1192</span>            <span class="keywordflow">if</span> (!update_current_producer_after_rotation(token)) {</div>
<div class="line"><span class="lineno"> 1193</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1194</span>            }</div>
<div class="line"><span class="lineno"> 1195</span>        }</div>
<div class="line"><span class="lineno"> 1196</span> </div>
<div class="line"><span class="lineno"> 1197</span>        <span class="comment">// If there was at least one non-empty queue but it appears empty at the time</span></div>
<div class="line"><span class="lineno"> 1198</span>        <span class="comment">// we try to dequeue from it, we need to make sure every queue&#39;s been tried</span></div>
<div class="line"><span class="lineno"> 1199</span>        <span class="keywordflow">if</span> (<span class="keyword">static_cast&lt;</span>ProducerBase*<span class="keyword">&gt;</span>(token.currentProducer)-&gt;dequeue(item)) {</div>
<div class="line"><span class="lineno"> 1200</span>            <span class="keywordflow">if</span> (++token.itemsConsumedFromCurrent == EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE) {</div>
<div class="line"><span class="lineno"> 1201</span>                globalExplicitConsumerOffset.fetch_add(1, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno"> 1202</span>            }</div>
<div class="line"><span class="lineno"> 1203</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1204</span>        }</div>
<div class="line"><span class="lineno"> 1205</span> </div>
<div class="line"><span class="lineno"> 1206</span>        <span class="keyword">auto</span> tail = producerListTail.load(std::memory_order_acquire);</div>
<div class="line"><span class="lineno"> 1207</span>        <span class="keyword">auto</span> ptr = <span class="keyword">static_cast&lt;</span>ProducerBase*<span class="keyword">&gt;</span>(token.currentProducer)-&gt;next_prod();</div>
<div class="line"><span class="lineno"> 1208</span>        <span class="keywordflow">if</span> (ptr == <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno"> 1209</span>            ptr = tail;</div>
<div class="line"><span class="lineno"> 1210</span>        }</div>
<div class="line"><span class="lineno"> 1211</span>        <span class="keywordflow">while</span> (ptr != <span class="keyword">static_cast&lt;</span>ProducerBase*<span class="keyword">&gt;</span>(token.currentProducer)) {</div>
<div class="line"><span class="lineno"> 1212</span>            <span class="keywordflow">if</span> (ptr-&gt;dequeue(item)) {</div>
<div class="line"><span class="lineno"> 1213</span>                token.currentProducer = ptr;</div>
<div class="line"><span class="lineno"> 1214</span>                token.itemsConsumedFromCurrent = 1;</div>
<div class="line"><span class="lineno"> 1215</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1216</span>            }</div>
<div class="line"><span class="lineno"> 1217</span>            ptr = ptr-&gt;next_prod();</div>
<div class="line"><span class="lineno"> 1218</span>            <span class="keywordflow">if</span> (ptr == <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno"> 1219</span>                ptr = tail;</div>
<div class="line"><span class="lineno"> 1220</span>            }</div>
<div class="line"><span class="lineno"> 1221</span>        }</div>
<div class="line"><span class="lineno"> 1222</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1223</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1895c8a6120aef578fe01db53879517b" name="a1895c8a6120aef578fe01db53879517b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1895c8a6120aef578fe01db53879517b">&#9670;&#160;</a></span>try_dequeue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_dequeue </td>
          <td>(</td>
          <td class="paramtype">U &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1126</span>    {</div>
<div class="line"><span class="lineno"> 1127</span>        <span class="comment">// Instead of simply trying each producer in turn (which could cause needless contention on the first</span></div>
<div class="line"><span class="lineno"> 1128</span>        <span class="comment">// producer), we score them heuristically.</span></div>
<div class="line"><span class="lineno"> 1129</span>        <span class="keywordtype">size_t</span> nonEmptyCount = 0;</div>
<div class="line"><span class="lineno"> 1130</span>        ProducerBase* best = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 1131</span>        <span class="keywordtype">size_t</span> bestSize = 0;</div>
<div class="line"><span class="lineno"> 1132</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> ptr = producerListTail.load(std::memory_order_acquire); nonEmptyCount &lt; 3 &amp;&amp; ptr != <span class="keyword">nullptr</span>; ptr = ptr-&gt;next_prod()) {</div>
<div class="line"><span class="lineno"> 1133</span>            <span class="keyword">auto</span> size = ptr-&gt;size_approx();</div>
<div class="line"><span class="lineno"> 1134</span>            <span class="keywordflow">if</span> (size &gt; 0) {</div>
<div class="line"><span class="lineno"> 1135</span>                <span class="keywordflow">if</span> (size &gt; bestSize) {</div>
<div class="line"><span class="lineno"> 1136</span>                    bestSize = size;</div>
<div class="line"><span class="lineno"> 1137</span>                    best = ptr;</div>
<div class="line"><span class="lineno"> 1138</span>                }</div>
<div class="line"><span class="lineno"> 1139</span>                ++nonEmptyCount;</div>
<div class="line"><span class="lineno"> 1140</span>            }</div>
<div class="line"><span class="lineno"> 1141</span>        }</div>
<div class="line"><span class="lineno"> 1142</span> </div>
<div class="line"><span class="lineno"> 1143</span>        <span class="comment">// If there was at least one non-empty queue but it appears empty at the time</span></div>
<div class="line"><span class="lineno"> 1144</span>        <span class="comment">// we try to dequeue from it, we need to make sure every queue&#39;s been tried</span></div>
<div class="line"><span class="lineno"> 1145</span>        <span class="keywordflow">if</span> (nonEmptyCount &gt; 0) {</div>
<div class="line"><span class="lineno"> 1146</span>            <span class="keywordflow">if</span> ((details::likely)(best-&gt;dequeue(item))) {</div>
<div class="line"><span class="lineno"> 1147</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1148</span>            }</div>
<div class="line"><span class="lineno"> 1149</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span> ptr = producerListTail.load(std::memory_order_acquire); ptr != <span class="keyword">nullptr</span>; ptr = ptr-&gt;next_prod()) {</div>
<div class="line"><span class="lineno"> 1150</span>                <span class="keywordflow">if</span> (ptr != best &amp;&amp; ptr-&gt;dequeue(item)) {</div>
<div class="line"><span class="lineno"> 1151</span>                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1152</span>                }</div>
<div class="line"><span class="lineno"> 1153</span>            }</div>
<div class="line"><span class="lineno"> 1154</span>        }</div>
<div class="line"><span class="lineno"> 1155</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1156</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a57e6b02051baed9cc1b3fb5e46743c03" name="a57e6b02051baed9cc1b3fb5e46743c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e6b02051baed9cc1b3fb5e46743c03">&#9670;&#160;</a></span>try_dequeue_bulk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_dequeue_bulk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/deb/structmoodycamel_1_1ConsumerToken.html">consumer_token_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itemFirst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1250</span>    {</div>
<div class="line"><span class="lineno"> 1251</span>        <span class="keywordflow">if</span> (token.desiredProducer == <span class="keyword">nullptr</span> || token.lastKnownGlobalOffset != globalExplicitConsumerOffset.load(std::memory_order_relaxed)) {</div>
<div class="line"><span class="lineno"> 1252</span>            <span class="keywordflow">if</span> (!update_current_producer_after_rotation(token)) {</div>
<div class="line"><span class="lineno"> 1253</span>                <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno"> 1254</span>            }</div>
<div class="line"><span class="lineno"> 1255</span>        }</div>
<div class="line"><span class="lineno"> 1256</span> </div>
<div class="line"><span class="lineno"> 1257</span>        <span class="keywordtype">size_t</span> count = <span class="keyword">static_cast&lt;</span>ProducerBase*<span class="keyword">&gt;</span>(token.currentProducer)-&gt;dequeue_bulk(itemFirst, max);</div>
<div class="line"><span class="lineno"> 1258</span>        <span class="keywordflow">if</span> (count == max) {</div>
<div class="line"><span class="lineno"> 1259</span>            <span class="keywordflow">if</span> ((token.itemsConsumedFromCurrent += <span class="keyword">static_cast&lt;</span>std::uint32_t<span class="keyword">&gt;</span>(max)) &gt;= EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE) {</div>
<div class="line"><span class="lineno"> 1260</span>                globalExplicitConsumerOffset.fetch_add(1, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno"> 1261</span>            }</div>
<div class="line"><span class="lineno"> 1262</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a2918c0347dde854fce1aaebb70a16c33">max</a>;</div>
<div class="line"><span class="lineno"> 1263</span>        }</div>
<div class="line"><span class="lineno"> 1264</span>        token.itemsConsumedFromCurrent += <span class="keyword">static_cast&lt;</span>std::uint32_t<span class="keyword">&gt;</span>(count);</div>
<div class="line"><span class="lineno"> 1265</span>        <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a2918c0347dde854fce1aaebb70a16c33">max</a> -= count;</div>
<div class="line"><span class="lineno"> 1266</span> </div>
<div class="line"><span class="lineno"> 1267</span>        <span class="keyword">auto</span> tail = producerListTail.load(std::memory_order_acquire);</div>
<div class="line"><span class="lineno"> 1268</span>        <span class="keyword">auto</span> ptr = <span class="keyword">static_cast&lt;</span>ProducerBase*<span class="keyword">&gt;</span>(token.currentProducer)-&gt;next_prod();</div>
<div class="line"><span class="lineno"> 1269</span>        <span class="keywordflow">if</span> (ptr == <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno"> 1270</span>            ptr = tail;</div>
<div class="line"><span class="lineno"> 1271</span>        }</div>
<div class="line"><span class="lineno"> 1272</span>        <span class="keywordflow">while</span> (ptr != <span class="keyword">static_cast&lt;</span>ProducerBase*<span class="keyword">&gt;</span>(token.currentProducer)) {</div>
<div class="line"><span class="lineno"> 1273</span>            <span class="keyword">auto</span> dequeued = ptr-&gt;dequeue_bulk(itemFirst, max);</div>
<div class="line"><span class="lineno"> 1274</span>            count += dequeued;</div>
<div class="line"><span class="lineno"> 1275</span>            <span class="keywordflow">if</span> (dequeued != 0) {</div>
<div class="line"><span class="lineno"> 1276</span>                token.currentProducer = ptr;</div>
<div class="line"><span class="lineno"> 1277</span>                token.itemsConsumedFromCurrent = <span class="keyword">static_cast&lt;</span>std::uint32_t<span class="keyword">&gt;</span>(dequeued);</div>
<div class="line"><span class="lineno"> 1278</span>            }</div>
<div class="line"><span class="lineno"> 1279</span>            <span class="keywordflow">if</span> (dequeued == max) {</div>
<div class="line"><span class="lineno"> 1280</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1281</span>            }</div>
<div class="line"><span class="lineno"> 1282</span>            <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a2918c0347dde854fce1aaebb70a16c33">max</a> -= dequeued;</div>
<div class="line"><span class="lineno"> 1283</span>            ptr = ptr-&gt;next_prod();</div>
<div class="line"><span class="lineno"> 1284</span>            <span class="keywordflow">if</span> (ptr == <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno"> 1285</span>                ptr = tail;</div>
<div class="line"><span class="lineno"> 1286</span>            }</div>
<div class="line"><span class="lineno"> 1287</span>        }</div>
<div class="line"><span class="lineno"> 1288</span>        <span class="keywordflow">return</span> count;</div>
<div class="line"><span class="lineno"> 1289</span>    }</div>
<div class="ttc" id="anamespacesrsran_html_a2918c0347dde854fce1aaebb70a16c33"><div class="ttname"><a href="../../d9/def/namespacesrsran.html#a2918c0347dde854fce1aaebb70a16c33">srsran::max</a></div><div class="ttdeci">slot_point max(slot_point lhs, slot_point rhs)</div><div class="ttdoc">Get maximum of two slot points.</div><div class="ttdef"><b>Definition</b> slot_point.h:266</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a816450a4b774c374ef8ee0234e7c4518" name="a816450a4b774c374ef8ee0234e7c4518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816450a4b774c374ef8ee0234e7c4518">&#9670;&#160;</a></span>try_dequeue_bulk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_dequeue_bulk </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itemFirst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1232</span>    {</div>
<div class="line"><span class="lineno"> 1233</span>        <span class="keywordtype">size_t</span> count = 0;</div>
<div class="line"><span class="lineno"> 1234</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> ptr = producerListTail.load(std::memory_order_acquire); ptr != <span class="keyword">nullptr</span>; ptr = ptr-&gt;next_prod()) {</div>
<div class="line"><span class="lineno"> 1235</span>            count += ptr-&gt;dequeue_bulk(itemFirst, max - count);</div>
<div class="line"><span class="lineno"> 1236</span>            <span class="keywordflow">if</span> (count == max) {</div>
<div class="line"><span class="lineno"> 1237</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1238</span>            }</div>
<div class="line"><span class="lineno"> 1239</span>        }</div>
<div class="line"><span class="lineno"> 1240</span>        <span class="keywordflow">return</span> count;</div>
<div class="line"><span class="lineno"> 1241</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1cfc50210d50dba266431ff82b908da7" name="a1cfc50210d50dba266431ff82b908da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfc50210d50dba266431ff82b908da7">&#9670;&#160;</a></span>try_dequeue_bulk_from_producer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_dequeue_bulk_from_producer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itemFirst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1314</span>    {</div>
<div class="line"><span class="lineno"> 1315</span>        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>ExplicitProducer*<span class="keyword">&gt;</span>(producer.producer)-&gt;dequeue_bulk(itemFirst, max);</div>
<div class="line"><span class="lineno"> 1316</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a609358c281fb44c88088f229c47e424d" name="a609358c281fb44c88088f229c47e424d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609358c281fb44c88088f229c47e424d">&#9670;&#160;</a></span>try_dequeue_from_producer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_dequeue_from_producer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1301</span>    {</div>
<div class="line"><span class="lineno"> 1302</span>        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>ExplicitProducer*<span class="keyword">&gt;</span>(producer.producer)-&gt;dequeue(item);</div>
<div class="line"><span class="lineno"> 1303</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9f25d247543755bdc1b477f2678455f" name="ad9f25d247543755bdc1b477f2678455f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f25d247543755bdc1b477f2678455f">&#9670;&#160;</a></span>try_dequeue_non_interleaved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_dequeue_non_interleaved </td>
          <td>(</td>
          <td class="paramtype">U &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1169</span>    {</div>
<div class="line"><span class="lineno"> 1170</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> ptr = producerListTail.load(std::memory_order_acquire); ptr != <span class="keyword">nullptr</span>; ptr = ptr-&gt;next_prod()) {</div>
<div class="line"><span class="lineno"> 1171</span>            <span class="keywordflow">if</span> (ptr-&gt;dequeue(item)) {</div>
<div class="line"><span class="lineno"> 1172</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1173</span>            }</div>
<div class="line"><span class="lineno"> 1174</span>        }</div>
<div class="line"><span class="lineno"> 1175</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1176</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a049a33d4127c66a614b717cf20bba330" name="a049a33d4127c66a614b717cf20bba330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049a33d4127c66a614b717cf20bba330">&#9670;&#160;</a></span>try_enqueue() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1089</span>    {</div>
<div class="line"><span class="lineno"> 1090</span>        <span class="keywordflow">return</span> inner_enqueue&lt;CannotAlloc&gt;(token, std::move(item));</div>
<div class="line"><span class="lineno"> 1091</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad04237577ca981e18e23190773cf1644" name="ad04237577ca981e18e23190773cf1644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04237577ca981e18e23190773cf1644">&#9670;&#160;</a></span>try_enqueue() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1081</span>    {</div>
<div class="line"><span class="lineno"> 1082</span>        <span class="keywordflow">return</span> inner_enqueue&lt;CannotAlloc&gt;(token, item);</div>
<div class="line"><span class="lineno"> 1083</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af63a4f51a8b8b6c59ea883ed97fff7a2" name="af63a4f51a8b8b6c59ea883ed97fff7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63a4f51a8b8b6c59ea883ed97fff7a2">&#9670;&#160;</a></span>try_enqueue() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_enqueue </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1072</span>    {</div>
<div class="line"><span class="lineno"> 1073</span>        MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;</div>
<div class="line"><span class="lineno"> 1074</span>        else return inner_enqueue&lt;CannotAlloc&gt;(std::move(item));</div>
<div class="line"><span class="lineno"> 1075</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaab76643a98e1094cecdd213fbb6e75d" name="aaab76643a98e1094cecdd213fbb6e75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab76643a98e1094cecdd213fbb6e75d">&#9670;&#160;</a></span>try_enqueue() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_enqueue </td>
          <td>(</td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1061</span>    {</div>
<div class="line"><span class="lineno"> 1062</span>        MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;</div>
<div class="line"><span class="lineno"> 1063</span>        else return inner_enqueue&lt;CannotAlloc&gt;(item);</div>
<div class="line"><span class="lineno"> 1064</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aecbe38c03c23ea980d1bc1f9445d26c2" name="aecbe38c03c23ea980d1bc1f9445d26c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbe38c03c23ea980d1bc1f9445d26c2">&#9670;&#160;</a></span>try_enqueue_bulk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_enqueue_bulk </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itemFirst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1102</span>    {</div>
<div class="line"><span class="lineno"> 1103</span>        MOODYCAMEL_CONSTEXPR_IF (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) return false;</div>
<div class="line"><span class="lineno"> 1104</span>        else return inner_enqueue_bulk&lt;CannotAlloc&gt;(itemFirst, count);</div>
<div class="line"><span class="lineno"> 1105</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a359380c0d6952e61f3ef4811808eb573" name="a359380c0d6952e61f3ef4811808eb573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359380c0d6952e61f3ef4811808eb573">&#9670;&#160;</a></span>try_enqueue_bulk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = ConcurrentQueueDefaultTraits&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d8/dc8/classmoodycamel_1_1ConcurrentQueue.html">moodycamel::ConcurrentQueue</a>&lt; T, Traits &gt;::try_enqueue_bulk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dbb/structmoodycamel_1_1ProducerToken.html">producer_token_t</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>itemFirst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1114</span>    {</div>
<div class="line"><span class="lineno"> 1115</span>        <span class="keywordflow">return</span> inner_enqueue_bulk&lt;CannotAlloc&gt;(token, itemFirst, count);</div>
<div class="line"><span class="lineno"> 1116</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>external/cameron314/<a class="el" href="../../da/da5/concurrentqueue_8h_source.html">concurrentqueue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
