<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>srsRAN Docs: srsran::rlc_sdu_queue_lockfree Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">srsRAN Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/def/namespacesrsran.html">srsran</a></li><li class="navelem"><a class="el" href="../../da/d33/classsrsran_1_1rlc__sdu__queue__lockfree.html">rlc_sdu_queue_lockfree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../dc/d82/classsrsran_1_1rlc__sdu__queue__lockfree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">srsran::rlc_sdu_queue_lockfree Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Lockfree RLC SDU queue.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../dd/dfa/rlc__sdu__queue__lockfree_8h_source.html">rlc_sdu_queue_lockfree.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for srsran::rlc_sdu_queue_lockfree:</div>
<div class="dyncontent">
<div class="center"><img src="../../dd/d46/classsrsran_1_1rlc__sdu__queue__lockfree__coll__graph.png" border="0" usemap="#asrsran_1_1rlc__sdu__queue__lockfree_coll__map" alt="Collaboration graph"/></div>
<map name="asrsran_1_1rlc__sdu__queue__lockfree_coll__map" id="asrsran_1_1rlc__sdu__queue__lockfree_coll__map">
<area shape="rect" title="Lockfree RLC SDU queue." alt="" coords="5,5,197,225"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adb2630d9a4ef331848d6ef3b35c79540" id="r_adb2630d9a4ef331848d6ef3b35c79540"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb2630d9a4ef331848d6ef3b35c79540">rlc_sdu_queue_lockfree</a> (uint16_t capacity_, <a class="el" href="../../d3/df9/classsrsran_1_1prefixed__logger.html">rlc_bearer_logger</a> &amp;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">logger_</a>)</td></tr>
<tr class="separator:adb2630d9a4ef331848d6ef3b35c79540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a653b33da96f2caea9471794877464c" id="r_a1a653b33da96f2caea9471794877464c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a653b33da96f2caea9471794877464c">write</a> (<a class="el" href="../../d8/d76/structsrsran_1_1rlc__sdu.html">rlc_sdu</a> sdu)</td></tr>
<tr class="memdesc:a1a653b33da96f2caea9471794877464c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an RLC SDU (with optional PDCP SN) to the queue, if possible.  <br /></td></tr>
<tr class="separator:a1a653b33da96f2caea9471794877464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5918fa48177cf34b10fef220c8fc719f" id="r_a5918fa48177cf34b10fef220c8fc719f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5918fa48177cf34b10fef220c8fc719f">try_discard</a> (<a class="el" href="../../d3/d87/classuint32__t.html">uint32_t</a> pdcp_sn)</td></tr>
<tr class="memdesc:a5918fa48177cf34b10fef220c8fc719f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks an RLC SDU as "discarded", if possible.  <br /></td></tr>
<tr class="separator:a5918fa48177cf34b10fef220c8fc719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2d6733746aaf17fd87a0743ba52501" id="r_a5b2d6733746aaf17fd87a0743ba52501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b2d6733746aaf17fd87a0743ba52501">read</a> (<a class="el" href="../../d8/d76/structsrsran_1_1rlc__sdu.html">rlc_sdu</a> &amp;sdu)</td></tr>
<tr class="memdesc:a5b2d6733746aaf17fd87a0743ba52501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an RLC SDU (with optional PDCP SN) from the queue, if possible.  <br /></td></tr>
<tr class="separator:a5b2d6733746aaf17fd87a0743ba52501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4aca80a693e78a7030d130e1116c09" id="r_a4c4aca80a693e78a7030d130e1116c09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d87/classuint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c4aca80a693e78a7030d130e1116c09">size_sdus</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="memdesc:a4c4aca80a693e78a7030d130e1116c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the number of buffered SDUs that are not marked as discarded.  <br /></td></tr>
<tr class="separator:a4c4aca80a693e78a7030d130e1116c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d800cfef5a9542f480da984fc3e2d0" id="r_ab2d800cfef5a9542f480da984fc3e2d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d87/classuint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2d800cfef5a9542f480da984fc3e2d0">size_bytes</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="memdesc:ab2d800cfef5a9542f480da984fc3e2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the number of buffered SDU bytes that are not marked as discarded.  <br /></td></tr>
<tr class="separator:ab2d800cfef5a9542f480da984fc3e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba1e310d8d662703f2922303c627a7a" id="r_a7ba1e310d8d662703f2922303c627a7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ba1e310d8d662703f2922303c627a7a">is_empty</a> ()</td></tr>
<tr class="memdesc:a7ba1e310d8d662703f2922303c627a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the internal queue is empty.  <br /></td></tr>
<tr class="separator:a7ba1e310d8d662703f2922303c627a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ac4760854df275260a793d0c71cf99" id="r_a68ac4760854df275260a793d0c71cf99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68ac4760854df275260a793d0c71cf99">is_full</a> ()</td></tr>
<tr class="memdesc:a68ac4760854df275260a793d0c71cf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the internal queue is full.  <br /></td></tr>
<tr class="separator:a68ac4760854df275260a793d0c71cf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lockfree RLC SDU queue. </p>
<p>This class is used as FIFO buffer for RLC SDUs from upper layers that shall be transmitted by the RLC Tx entity. It implements SPSC (single producer single consumer) semantics, i.e. allows concurrent access by one upper-layer thread and one lower-layer thread. Internally, this class wraps a lock-free SPSC queue to store the actual SDUs and involves additional bookkeeping to support discard of SDUs and to track the amount of buffered SDUs and bytes.</p>
<p>From the perspective of the upper-layer thread this class provides methods to write RLC SDUs (with or without PDCP SN) and to discard SDUs by their PDCP SN. SDUs without PDCP SN cannot be discarded. SDUs that are marked as discarded remain in the internal queue until they are popped (and dropped) via <code>read</code>. Writing to the queue fails if the internal queue is either full or the queue already contains an SDU (whether valid or marked as discarded) with the same value for [PDCP_SN mod capacity].</p>
<p>From the perspective of the lower-layer thread it provides methods to read RLC SDUs and to query the total number of buffered SDUs and bytes. SDUs are read in the same order as they were written into the queue. There is no reordering by PDCP SN. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adb2630d9a4ef331848d6ef3b35c79540" name="adb2630d9a4ef331848d6ef3b35c79540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2630d9a4ef331848d6ef3b35c79540">&#9670;&#160;</a></span>rlc_sdu_queue_lockfree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">srsran::rlc_sdu_queue_lockfree::rlc_sdu_queue_lockfree </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>capacity_</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/df9/classsrsran_1_1prefixed__logger.html">rlc_bearer_logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger_</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   50</span>                                                                                  : logger(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">logger_</a>), capacity(capacity_)</div>
<div class="line"><span class="lineno">   51</span>  {</div>
<div class="line"><span class="lineno">   52</span>    sdu_states = std::make_unique&lt;std::atomic&lt;uint32_t&gt;[]&gt;(capacity);</div>
<div class="line"><span class="lineno">   53</span>    sdu_sizes  = std::make_unique&lt;std::atomic&lt;size_t&gt;[]&gt;(capacity);</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; capacity; i++) {</div>
<div class="line"><span class="lineno">   56</span>      sdu_states[i].store(STATE_FREE, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">   57</span>    }</div>
<div class="line"><span class="lineno">   58</span> </div>
<div class="line"><span class="lineno">   59</span>    queue = std::make_unique&lt;</div>
<div class="line"><span class="lineno">   60</span>        <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">concurrent_queue&lt;rlc_sdu, concurrent_queue_policy::lockfree_spsc, concurrent_queue_wait_policy::non_blocking&gt;</a>&gt;(</div>
<div class="line"><span class="lineno">   61</span>        capacity);</div>
<div class="line"><span class="lineno">   62</span>  }</div>
<div class="ttc" id="anamespacesrsran_html_a58e7c9f2c51a9ad6a0899b46d5315723"><div class="ttname"><a href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">srsran::mask_msb_ones</a></div><div class="ttdeci">constexpr Integer mask_msb_ones(size_t N)</div><div class="ttdoc">Returns an unsigned integer with the N most significant bits (MSB) set to one, and the remaining bits...</div><div class="ttdef"><b>Definition</b> bounded_bitset.h:65</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7ba1e310d8d662703f2922303c627a7a" name="a7ba1e310d8d662703f2922303c627a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba1e310d8d662703f2922303c627a7a">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::rlc_sdu_queue_lockfree::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the internal queue is empty. </p>
<p>This function may be called by any thread.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the internal queue is empty, otherwise false. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  219</span>{ <span class="keywordflow">return</span> queue-&gt;empty(); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a68ac4760854df275260a793d0c71cf99" name="a68ac4760854df275260a793d0c71cf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ac4760854df275260a793d0c71cf99">&#9670;&#160;</a></span>is_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::rlc_sdu_queue_lockfree::is_full </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the internal queue is full. </p>
<p>This function may be called by any thread.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the internal queue is full, otherwise false. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  226</span>{ <span class="keywordflow">return</span> queue-&gt;size() &gt;= capacity; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b2d6733746aaf17fd87a0743ba52501" name="a5b2d6733746aaf17fd87a0743ba52501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2d6733746aaf17fd87a0743ba52501">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::rlc_sdu_queue_lockfree::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d76/structsrsran_1_1rlc__sdu.html">rlc_sdu</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sdu</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads an RLC SDU (with optional PDCP SN) from the queue, if possible. </p>
<p>This function may be called by the lower-layer thread.</p>
<p>The read fails (returns false) in the following cases:</p><ul>
<li>The internal queue only contains SDUs that are marked as discarded.</li>
<li>The internal queue is empty.</li>
</ul>
<p>Each call of this function pops and drops SDUs that are marked as discarded from the internal queue in a loop until a valid SDU is popped (return true) or the queue is empty (returns false).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdu</td><td>Reference to a <code><a class="el" href="../../d8/d76/structsrsran_1_1rlc__sdu.html">rlc_sdu</a></code> object that will be filled with the read RLC SDU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an RLC SDU was successfully read from the queue, otherwise false. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  173</span>  {</div>
<div class="line"><span class="lineno">  174</span>    <span class="keywordtype">bool</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">sdu_is_valid</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  175</span>    <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno">  176</span>      <span class="comment">// first try to pop front (SDU can still get discarded from upper layers)</span></div>
<div class="line"><span class="lineno">  177</span>      <span class="keywordtype">bool</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">popped</a> = queue-&gt;try_pop(sdu);</div>
<div class="line"><span class="lineno">  178</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">popped</a>) {</div>
<div class="line"><span class="lineno">  179</span>        <span class="comment">// queue is empty</span></div>
<div class="line"><span class="lineno">  180</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  181</span>      }</div>
<div class="line"><span class="lineno">  182</span> </div>
<div class="line"><span class="lineno">  183</span>      <span class="keywordflow">if</span> (sdu.pdcp_sn.has_value()) {</div>
<div class="line"><span class="lineno">  184</span>        <span class="comment">// Check if the SDU is still valid (i.e. the PDCP SN was not already discarded) and release the slot</span></div>
<div class="line"><span class="lineno">  185</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d3/d87/classuint32__t.html">uint32_t</a> pdcp_sn = sdu.pdcp_sn.value();</div>
<div class="line"><span class="lineno">  186</span>        <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">sdu_is_valid</a>           = check_and_release(pdcp_sn); <span class="comment">// this also updates totals</span></div>
<div class="line"><span class="lineno">  187</span>      } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  188</span>        <span class="comment">// SDUs without PDCP SN are alway valid as they can&#39;t be discarded</span></div>
<div class="line"><span class="lineno">  189</span>        <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">sdu_is_valid</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  190</span> </div>
<div class="line"><span class="lineno">  191</span>        <span class="comment">// update totals</span></div>
<div class="line"><span class="lineno">  192</span>        n_sdus.fetch_sub(1, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  193</span>        n_bytes.fetch_sub(sdu.buf.length(), std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  194</span>      }</div>
<div class="line"><span class="lineno">  195</span>      <span class="comment">// try again if SDU is not valid</span></div>
<div class="line"><span class="lineno">  196</span>    } <span class="keywordflow">while</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">sdu_is_valid</a>);</div>
<div class="line"><span class="lineno">  197</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  198</span>  }</div>
<div class="ttc" id="aclassuint32__t_html"><div class="ttname"><a href="../../d3/d87/classuint32__t.html">uint32_t</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2d800cfef5a9542f480da984fc3e2d0" name="ab2d800cfef5a9542f480da984fc3e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d800cfef5a9542f480da984fc3e2d0">&#9670;&#160;</a></span>size_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d87/classuint32__t.html">uint32_t</a> srsran::rlc_sdu_queue_lockfree::size_bytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the number of buffered SDU bytes that are not marked as discarded. </p>
<p>This function may be called by any thread.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of buffered SDU bytes that are not marked as discarded. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  212</span>{ <span class="keywordflow">return</span> n_bytes.load(std::memory_order_relaxed); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c4aca80a693e78a7030d130e1116c09" name="a4c4aca80a693e78a7030d130e1116c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4aca80a693e78a7030d130e1116c09">&#9670;&#160;</a></span>size_sdus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d87/classuint32__t.html">uint32_t</a> srsran::rlc_sdu_queue_lockfree::size_sdus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the number of buffered SDUs that are not marked as discarded. </p>
<p>This function may be called by any thread.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of buffered SDUs that are not marked as discarded. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  205</span>{ <span class="keywordflow">return</span> n_sdus.load(std::memory_order_relaxed); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5918fa48177cf34b10fef220c8fc719f" name="a5918fa48177cf34b10fef220c8fc719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5918fa48177cf34b10fef220c8fc719f">&#9670;&#160;</a></span>try_discard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::rlc_sdu_queue_lockfree::try_discard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d87/classuint32__t.html">uint32_t</a></td>          <td class="paramname"><span class="paramname"><em>pdcp_sn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks an RLC SDU as "discarded", if possible. </p>
<p>This function may be called by the upper-layer thread.</p>
<p>The function fails (returns false) in the following cases:</p><ul>
<li>The SDU with the PDCP SN is already marked as discarded.</li>
<li>The SDU with the PDCP SN is not in the queue.</li>
</ul>
<p>In case of success, the number of SDUs/bytes will be updated immediately. However, the actual SDU remains in the internal queue until it is popped and finally discarded via <code>read</code>. Meanwhile, no further SDU with the same value of [PDCP_SN mod capacity] can be added to the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdcp_sn</td><td>The PDCP SN of the SDU that shall be discarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the RLC SDU was successfully discarded, otherwise false. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  128</span>  {</div>
<div class="line"><span class="lineno">  129</span>    <a class="code hl_class" href="../../d3/d87/classuint32__t.html">uint32_t</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">expected_state</a> = pdcp_sn;</div>
<div class="line"><span class="lineno">  130</span>    <a class="code hl_class" href="../../d3/d87/classuint32__t.html">uint32_t</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">desired_state</a>  = STATE_DISCARDED;</div>
<div class="line"><span class="lineno">  131</span>    <span class="comment">// set slot state as &quot;discarded&quot; only if it holds the PDCP SN; otherwise load the existing state</span></div>
<div class="line"><span class="lineno">  132</span>    <span class="comment">// - on success: memory_order_acquire ensures sdu_size is up to date</span></div>
<div class="line"><span class="lineno">  133</span>    <span class="comment">// - on failure: memory_order_relaxed, don&#39;t care about value of sdu_size</span></div>
<div class="line"><span class="lineno">  134</span>    <span class="keywordtype">bool</span> success = sdu_states[pdcp_sn % capacity].compare_exchange_strong(</div>
<div class="line"><span class="lineno">  135</span>        <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">expected_state</a>, <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">desired_state</a>, std::memory_order_acquire, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  136</span>    <a class="code hl_class" href="../../d3/d87/classuint32__t.html">uint32_t</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">sdu_size</a> = sdu_sizes[pdcp_sn % capacity].load(std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  137</span> </div>
<div class="line"><span class="lineno">  138</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> success) {</div>
<div class="line"><span class="lineno">  139</span>      <span class="keywordflow">switch</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">expected_state</a>) {</div>
<div class="line"><span class="lineno">  140</span>        <span class="keywordflow">case</span> STATE_DISCARDED:</div>
<div class="line"><span class="lineno">  141</span>          logger.log_debug(<span class="stringliteral">&quot;SDU queue cannot discard pdcp_sn={}. Slot is already discarded&quot;</span>, pdcp_sn);</div>
<div class="line"><span class="lineno">  142</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  143</span>        <span class="keywordflow">case</span> STATE_FREE:</div>
<div class="line"><span class="lineno">  144</span>          logger.log_debug(<span class="stringliteral">&quot;SDU queue cannot discard pdcp_sn={}. Slot is already free&quot;</span>, pdcp_sn);</div>
<div class="line"><span class="lineno">  145</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  146</span>        <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  147</span>          logger.log_debug(<span class="stringliteral">&quot;SDU queue cannot discard pdcp_sn={}. Slot holds pdcp_sn={}&quot;</span>, pdcp_sn, <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">expected_state</a>);</div>
<div class="line"><span class="lineno">  148</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  149</span>      }</div>
<div class="line"><span class="lineno">  150</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  151</span>    }</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span>    <span class="comment">// update totals</span></div>
<div class="line"><span class="lineno">  154</span>    n_sdus.fetch_sub(1, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  155</span>    n_bytes.fetch_sub(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">sdu_size</a>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  156</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  157</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a653b33da96f2caea9471794877464c" name="a1a653b33da96f2caea9471794877464c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a653b33da96f2caea9471794877464c">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::rlc_sdu_queue_lockfree::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d76/structsrsran_1_1rlc__sdu.html">rlc_sdu</a></td>          <td class="paramname"><span class="paramname"><em>sdu</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an RLC SDU (with optional PDCP SN) to the queue, if possible. </p>
<p>This function may be called by the upper-layer thread.</p>
<p>The write fails (returns false) in the following cases:</p><ul>
<li>The internal queue is full.</li>
<li>Another SDU with same value of [PDCP_SN mod capacity] exists (either valid or discarded) in the queue.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdu</td><td>The RLC SDU that shall be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the RLC SDU was successfully written to the queue, otherwise false. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   75</span>  {</div>
<div class="line"><span class="lineno">   76</span>    <span class="comment">// if the SDU has a PDCP SN, first check the slot is available</span></div>
<div class="line"><span class="lineno">   77</span>    optional&lt;uint32_t&gt; pdcp_sn  = sdu.pdcp_sn;</div>
<div class="line"><span class="lineno">   78</span>    <span class="keyword">const</span> <span class="keywordtype">size_t</span>       <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">sdu_size</a> = sdu.buf.length();</div>
<div class="line"><span class="lineno">   79</span>    <span class="keywordflow">if</span> (pdcp_sn.has_value()) {</div>
<div class="line"><span class="lineno">   80</span>      <span class="keyword">const</span> <a class="code hl_class" href="../../d3/d87/classuint32__t.html">uint32_t</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">pdcp_sn_value</a> = sdu.pdcp_sn.value();</div>
<div class="line"><span class="lineno">   81</span>      <span class="comment">// load slot state (memory_order_acquire ensures sdu_size is written after this)</span></div>
<div class="line"><span class="lineno">   82</span>      <a class="code hl_class" href="../../d3/d87/classuint32__t.html">uint32_t</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">slot_state</a> = sdu_states[<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">pdcp_sn_value</a> % capacity].load(std::memory_order_acquire);</div>
<div class="line"><span class="lineno">   83</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">slot_state</a> != STATE_FREE) {</div>
<div class="line"><span class="lineno">   84</span>        logger.log_debug(<span class="stringliteral">&quot;SDU queue failed to enqueue pdcp_sn={}. Slot holds pdcp_sn={}&quot;</span>, <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">pdcp_sn_value</a>, <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">slot_state</a>);</div>
<div class="line"><span class="lineno">   85</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   86</span>      }</div>
<div class="line"><span class="lineno">   87</span> </div>
<div class="line"><span class="lineno">   88</span>      <span class="comment">// slot is free, we can safely store the SDU size</span></div>
<div class="line"><span class="lineno">   89</span>      sdu_sizes[<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">pdcp_sn_value</a> % capacity].store(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">sdu_size</a>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">   90</span> </div>
<div class="line"><span class="lineno">   91</span>      <span class="comment">// allocate slot by writing the PDCP SN into it (memory_order_relaxed, don&#39;t care about order because of &quot;release&quot;</span></div>
<div class="line"><span class="lineno">   92</span>      <span class="comment">// semantics of the push to queue)</span></div>
<div class="line"><span class="lineno">   93</span>      sdu_states[<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">pdcp_sn_value</a> % capacity].store(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">pdcp_sn_value</a>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">   94</span>    }</div>
<div class="line"><span class="lineno">   95</span> </div>
<div class="line"><span class="lineno">   96</span>    <span class="comment">// push SDU to queue</span></div>
<div class="line"><span class="lineno">   97</span>    <span class="keywordtype">bool</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">pushed</a> = queue-&gt;try_push(std::move(sdu));</div>
<div class="line"><span class="lineno">   98</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">pushed</a>) {</div>
<div class="line"><span class="lineno">   99</span>      logger.log_debug(<span class="stringliteral">&quot;SDU queue failed to enqueue pdcp_sn={}. Queue is full&quot;</span>, pdcp_sn);</div>
<div class="line"><span class="lineno">  100</span>      <span class="comment">// if the SDU has a PDCP SN, release the slot (memory_order_relaxed, don&#39;t care about value of sdu_size)</span></div>
<div class="line"><span class="lineno">  101</span>      <span class="keywordflow">if</span> (pdcp_sn.has_value()) {</div>
<div class="line"><span class="lineno">  102</span>        sdu_states[pdcp_sn.value() % capacity].store(STATE_FREE, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  103</span>      }</div>
<div class="line"><span class="lineno">  104</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  105</span>    }</div>
<div class="line"><span class="lineno">  106</span> </div>
<div class="line"><span class="lineno">  107</span>    <span class="comment">// update totals</span></div>
<div class="line"><span class="lineno">  108</span>    n_sdus.fetch_add(1, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  109</span>    n_bytes.fetch_add(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">sdu_size</a>, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  110</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  111</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/rlc/<a class="el" href="../../dd/dfa/rlc__sdu__queue__lockfree_8h_source.html">rlc_sdu_queue_lockfree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
