<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>srsRAN Docs: srsran::byte_buffer Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">srsRAN Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/def/namespacesrsran.html">srsran</a></li><li class="navelem"><a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d9/da2/classsrsran_1_1byte__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">srsran::byte_buffer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks. This container is not contiguous in memory. Default copy ctor and assignment is disabled in this container. The user should instead std::move to transfer ownership, .<a class="el" href="#a1f08be439b9c2c174b4b2827c18feda6" title="Performs a shallow copy. Head segment reference counter is incremented.">copy()</a> for shallow copies with shared ownership and .<a class="el" href="#aa79a5e270dbb5dd01b83c034853b9fb3" title="Performs a deep copy (byte by bytes) of this byte_buffer.">deep_copy()</a> for byte-wise copies.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d0/dfd/byte__buffer_8h_source.html">byte_buffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for srsran::byte_buffer:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/dc6/classsrsran_1_1byte__buffer__inherit__graph.png" border="0" usemap="#asrsran_1_1byte__buffer_inherit__map" alt="Inheritance graph"/></div>
<map name="asrsran_1_1byte__buffer_inherit__map" id="asrsran_1_1byte__buffer_inherit__map">
<area shape="rect" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks...." alt="" coords="139,5,275,271"/>
<area shape="rect" href="../../dd/d25/classasn1_1_1unbounded__octstring.html" title=" " alt="" coords="5,723,195,1063"/>
<area shape="poly" title=" " alt="" coords="134,247,116,283,103,321,82,423,74,528,74,629,80,722,74,723,69,630,68,527,77,422,97,319,111,281,129,244"/>
<area shape="rect" href="../../dd/d25/classasn1_1_1unbounded__octstring.html" title=" " alt="" coords="231,723,420,1063"/>
<area shape="poly" title=" " alt="" coords="284,245,302,281,316,319,338,422,348,527,350,629,347,722,341,722,345,629,343,527,332,422,311,321,297,283,279,247"/>
<area shape="rect" href="../../dd/d25/classasn1_1_1unbounded__octstring.html" title=" " alt="" coords="112,320,301,660"/>
<area shape="poly" title=" " alt="" coords="209,284,209,319,204,319,204,284"/>
<area shape="poly" title=" " alt="" coords="156,674,153,685,143,723,138,722,148,683,151,673"/>
<area shape="poly" title=" " alt="" coords="249,673,256,698,263,722,258,723,251,699,244,674"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for srsran::byte_buffer:</div>
<div class="dyncontent">
<div class="center"><img src="../../da/dcd/classsrsran_1_1byte__buffer__coll__graph.png" border="0" usemap="#asrsran_1_1byte__buffer_coll__map" alt="Collaboration graph"/></div>
<map name="asrsran_1_1byte__buffer_coll__map" id="asrsran_1_1byte__buffer_coll__map">
<area shape="rect" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks...." alt="" coords="5,5,141,271"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a78ecde31e45c3c0e655c27cb9a75f2fd" id="r_a78ecde31e45c3c0e655c27cb9a75f2fd"><td class="memItemLeft" align="right" valign="top"><a id="a78ecde31e45c3c0e655c27cb9a75f2fd" name="a78ecde31e45c3c0e655c27cb9a75f2fd"></a>
<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a></td></tr>
<tr class="separator:a78ecde31e45c3c0e655c27cb9a75f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653243020132cbb858c0c6c02838f8a4" id="r_a653243020132cbb858c0c6c02838f8a4"><td class="memItemLeft" align="right" valign="top"><a id="a653243020132cbb858c0c6c02838f8a4" name="a653243020132cbb858c0c6c02838f8a4"></a>
<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">detail::byte_buffer_segment_list_byte_iterator</a></td></tr>
<tr class="separator:a653243020132cbb858c0c6c02838f8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489fa0a1de906542bdbdb8ad65cbc2bf" id="r_a489fa0a1de906542bdbdb8ad65cbc2bf"><td class="memItemLeft" align="right" valign="top"><a id="a489fa0a1de906542bdbdb8ad65cbc2bf" name="a489fa0a1de906542bdbdb8ad65cbc2bf"></a>
<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">detail::byte_buffer_segment_list_byte_const_iterator</a></td></tr>
<tr class="separator:a489fa0a1de906542bdbdb8ad65cbc2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d95648e141616eb82e4db1be807148c" id="r_a9d95648e141616eb82e4db1be807148c"><td class="memItemLeft" align="right" valign="top"><a id="a9d95648e141616eb82e4db1be807148c" name="a9d95648e141616eb82e4db1be807148c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>byte_buffer</b> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">noexcept</a>=<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">default</a></td></tr>
<tr class="memdesc:a9d95648e141616eb82e4db1be807148c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. <br /></td></tr>
<tr class="separator:a9d95648e141616eb82e4db1be807148c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de51a4dc546559b66af861d51e29fc3" id="r_a6de51a4dc546559b66af861d51e29fc3"><td class="memItemLeft" align="right" valign="top"><a id="a6de51a4dc546559b66af861d51e29fc3" name="a6de51a4dc546559b66af861d51e29fc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>byte_buffer</b> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;) <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">noexcept</a>=<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">default</a></td></tr>
<tr class="memdesc:a6de51a4dc546559b66af861d51e29fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit copy ctor. User should use <a class="el" href="#a1f08be439b9c2c174b4b2827c18feda6" title="Performs a shallow copy. Head segment reference counter is incremented.">copy()</a> method for copy assignments. <br /></td></tr>
<tr class="separator:a6de51a4dc546559b66af861d51e29fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68178f768cd233f55b4e6ebba378bf1e" id="r_a68178f768cd233f55b4e6ebba378bf1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68178f768cd233f55b4e6ebba378bf1e">byte_buffer</a> (<a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; <a class="el" href="../../de/dd1/classbytes.html">bytes</a>)</td></tr>
<tr class="memdesc:a68178f768cd233f55b4e6ebba378bf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> with content provided by a span of bytes.  <br /></td></tr>
<tr class="separator:a68178f768cd233f55b4e6ebba378bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23243c3899f5fb66157c4b8151136dbd" id="r_a23243c3899f5fb66157c4b8151136dbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23243c3899f5fb66157c4b8151136dbd">byte_buffer</a> (std::initializer_list&lt; <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">lst</a>)</td></tr>
<tr class="memdesc:a23243c3899f5fb66157c4b8151136dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> with data intialized via a initializer list.  <br /></td></tr>
<tr class="separator:a23243c3899f5fb66157c4b8151136dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bffb2221d9e273d2227d182403a2016" id="r_a3bffb2221d9e273d2227d182403a2016"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> It &gt; </td></tr>
<tr class="memitem:a3bffb2221d9e273d2227d182403a2016"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bffb2221d9e273d2227d182403a2016">byte_buffer</a> (It <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">other_begin</a>, It <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">other_end</a>)</td></tr>
<tr class="memdesc:a3bffb2221d9e273d2227d182403a2016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> with data assigned from a range of bytes.  <br /></td></tr>
<tr class="separator:a3bffb2221d9e273d2227d182403a2016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bd84dfe3119fbeb1c63e4028361aed" id="r_a82bd84dfe3119fbeb1c63e4028361aed"><td class="memItemLeft" align="right" valign="top"><a id="a82bd84dfe3119fbeb1c63e4028361aed" name="a82bd84dfe3119fbeb1c63e4028361aed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>byte_buffer</b> (<a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&amp;<a class="el" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">noexcept</a>=<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">default</a></td></tr>
<tr class="memdesc:a82bd84dfe3119fbeb1c63e4028361aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a82bd84dfe3119fbeb1c63e4028361aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af519f1b008b53df31f03005e4a590ae6" id="r_af519f1b008b53df31f03005e4a590ae6"><td class="memItemLeft" align="right" valign="top"><a id="af519f1b008b53df31f03005e4a590ae6" name="af519f1b008b53df31f03005e4a590ae6"></a>
<a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;) <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">noexcept</a>=<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">delete</a></td></tr>
<tr class="memdesc:af519f1b008b53df31f03005e4a590ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment is disabled. Use std::move, .<a class="el" href="#a1f08be439b9c2c174b4b2827c18feda6" title="Performs a shallow copy. Head segment reference counter is incremented.">copy()</a> or .<a class="el" href="#aa79a5e270dbb5dd01b83c034853b9fb3" title="Performs a deep copy (byte by bytes) of this byte_buffer.">deep_copy()</a> instead. <br /></td></tr>
<tr class="separator:af519f1b008b53df31f03005e4a590ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a40af12ed4cd3da56159f069131df8" id="r_a10a40af12ed4cd3da56159f069131df8"><td class="memItemLeft" align="right" valign="top"><a id="a10a40af12ed4cd3da56159f069131df8" name="a10a40af12ed4cd3da56159f069131df8"></a>
<a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&amp;<a class="el" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">noexcept</a>=<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">default</a></td></tr>
<tr class="memdesc:a10a40af12ed4cd3da56159f069131df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment of <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. It avoids unnecessary reference counting increment. <br /></td></tr>
<tr class="separator:a10a40af12ed4cd3da56159f069131df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2ffb4df18c0d3ddc15a68b75664b43" id="r_a4d2ffb4df18c0d3ddc15a68b75664b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d2ffb4df18c0d3ddc15a68b75664b43">operator=</a> (<a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; <a class="el" href="../../de/dd1/classbytes.html">bytes</a>) <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">noexcept</a></td></tr>
<tr class="memdesc:a4d2ffb4df18c0d3ddc15a68b75664b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of span of bytes.  <br /></td></tr>
<tr class="separator:a4d2ffb4df18c0d3ddc15a68b75664b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79a5e270dbb5dd01b83c034853b9fb3" id="r_aa79a5e270dbb5dd01b83c034853b9fb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa79a5e270dbb5dd01b83c034853b9fb3">deep_copy</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="memdesc:aa79a5e270dbb5dd01b83c034853b9fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep copy (byte by bytes) of this <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>.  <br /></td></tr>
<tr class="separator:aa79a5e270dbb5dd01b83c034853b9fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f08be439b9c2c174b4b2827c18feda6" id="r_a1f08be439b9c2c174b4b2827c18feda6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f08be439b9c2c174b4b2827c18feda6">copy</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="memdesc:a1f08be439b9c2c174b4b2827c18feda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a shallow copy. Head segment reference counter is incremented.  <br /></td></tr>
<tr class="separator:a1f08be439b9c2c174b4b2827c18feda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190484f4224c88acb2f1b3334b28421b" id="r_a190484f4224c88acb2f1b3334b28421b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> Iterator &gt; </td></tr>
<tr class="memitem:a190484f4224c88acb2f1b3334b28421b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd1/compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a190484f4224c88acb2f1b3334b28421b">append</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a190484f4224c88acb2f1b3334b28421b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append bytes of a iterator range.  <br /></td></tr>
<tr class="separator:a190484f4224c88acb2f1b3334b28421b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c9b29ce6019b29798495213d68096c" id="r_ad7c9b29ce6019b29798495213d68096c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd1/compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7c9b29ce6019b29798495213d68096c">append</a> (<a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; <a class="el" href="../../de/dd1/classbytes.html">bytes</a>)</td></tr>
<tr class="memdesc:ad7c9b29ce6019b29798495213d68096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends bytes to the byte buffer. This function may retrieve new segments from a memory pool.  <br /></td></tr>
<tr class="separator:ad7c9b29ce6019b29798495213d68096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244844e979a2bf6e2bdb96574c65584b" id="r_a244844e979a2bf6e2bdb96574c65584b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd1/compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a244844e979a2bf6e2bdb96574c65584b">append</a> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> std::initializer_list&lt; <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; &amp;<a class="el" href="../../de/dd1/classbytes.html">bytes</a>)</td></tr>
<tr class="memdesc:a244844e979a2bf6e2bdb96574c65584b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends an initializer list of bytes.  <br /></td></tr>
<tr class="separator:a244844e979a2bf6e2bdb96574c65584b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cbb3c32365a49af9d01ae53360a43c" id="r_af6cbb3c32365a49af9d01ae53360a43c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd1/compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6cbb3c32365a49af9d01ae53360a43c">append</a> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;<a class="el" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:af6cbb3c32365a49af9d01ae53360a43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends bytes from another <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments.  <br /></td></tr>
<tr class="separator:af6cbb3c32365a49af9d01ae53360a43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef452363346e8bf3176c8d2d31a5171" id="r_a4ef452363346e8bf3176c8d2d31a5171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd1/compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ef452363346e8bf3176c8d2d31a5171">append</a> (<a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&amp;<a class="el" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:a4ef452363346e8bf3176c8d2d31a5171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends bytes from another rvalue <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments.  <br /></td></tr>
<tr class="separator:a4ef452363346e8bf3176c8d2d31a5171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74d9a2442b1103a2ac0852afd7f3e1a" id="r_ae74d9a2442b1103a2ac0852afd7f3e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd1/compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> <a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae74d9a2442b1103a2ac0852afd7f3e1a">append</a> (<a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">byte</a>)</td></tr>
<tr class="memdesc:ae74d9a2442b1103a2ac0852afd7f3e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends bytes to the byte buffer. This function may allocate new segments.  <br /></td></tr>
<tr class="separator:ae74d9a2442b1103a2ac0852afd7f3e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4563ca3bb9e2b8634e96ec87911c838" id="r_af4563ca3bb9e2b8634e96ec87911c838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4563ca3bb9e2b8634e96ec87911c838">append</a> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d72/classsrsran_1_1byte__buffer__view.html">byte_buffer_view</a> &amp;view)</td></tr>
<tr class="memdesc:af4563ca3bb9e2b8634e96ec87911c838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a view of bytes into current byte buffer.  <br /></td></tr>
<tr class="separator:af4563ca3bb9e2b8634e96ec87911c838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a8d0f483eeaaa7c31d576782070647" id="r_a60a8d0f483eeaaa7c31d576782070647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60a8d0f483eeaaa7c31d576782070647">append</a> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../db/d64/classsrsran_1_1byte__buffer__slice.html">byte_buffer_slice</a> &amp;view)</td></tr>
<tr class="memdesc:a60a8d0f483eeaaa7c31d576782070647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends an owning view of bytes into current byte buffer.  <br /></td></tr>
<tr class="separator:a60a8d0f483eeaaa7c31d576782070647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8478410e24f9b23cafda0cbabdbf403" id="r_ae8478410e24f9b23cafda0cbabdbf403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8478410e24f9b23cafda0cbabdbf403">prepend</a> (<a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; <a class="el" href="../../de/dd1/classbytes.html">bytes</a>)</td></tr>
<tr class="memdesc:ae8478410e24f9b23cafda0cbabdbf403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends bytes to <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments.  <br /></td></tr>
<tr class="separator:ae8478410e24f9b23cafda0cbabdbf403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acac0fd07a5577ba3a430b636c74741" id="r_a6acac0fd07a5577ba3a430b636c74741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6acac0fd07a5577ba3a430b636c74741">prepend</a> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;<a class="el" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:a6acac0fd07a5577ba3a430b636c74741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend data of byte buffer to this byte buffer.  <br /></td></tr>
<tr class="separator:a6acac0fd07a5577ba3a430b636c74741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababbb591f47600a9a0ffbf5a91b19e87" id="r_ababbb591f47600a9a0ffbf5a91b19e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ababbb591f47600a9a0ffbf5a91b19e87">prepend</a> (<a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&amp;<a class="el" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:ababbb591f47600a9a0ffbf5a91b19e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend data of r-value byte buffer to this byte buffer. The segments of the provided byte buffer can get "stolen" if the byte buffer is the last reference to the segments.  <br /></td></tr>
<tr class="separator:ababbb591f47600a9a0ffbf5a91b19e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dbd27b3715bfe6abc890fbfd170245" id="r_ad8dbd27b3715bfe6abc890fbfd170245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d72/classsrsran_1_1byte__buffer__view.html">byte_buffer_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8dbd27b3715bfe6abc890fbfd170245">reserve_prepend</a> (size_t nof_bytes)</td></tr>
<tr class="separator:ad8dbd27b3715bfe6abc890fbfd170245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8882b6403ea3f246d63c64dd122f10" id="r_a7c8882b6403ea3f246d63c64dd122f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c8882b6403ea3f246d63c64dd122f10">clear</a> ()</td></tr>
<tr class="memdesc:a7c8882b6403ea3f246d63c64dd122f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear byte buffer.  <br /></td></tr>
<tr class="separator:a7c8882b6403ea3f246d63c64dd122f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832175c27ef0d111b127c1a0bc421ec3" id="r_a832175c27ef0d111b127c1a0bc421ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a832175c27ef0d111b127c1a0bc421ec3">trim_head</a> (size_t nof_bytes)</td></tr>
<tr class="memdesc:a832175c27ef0d111b127c1a0bc421ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes "nof_bytes" from the head of the <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>.  <br /></td></tr>
<tr class="separator:a832175c27ef0d111b127c1a0bc421ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94ff05447760ce113c0ee12f92cb503" id="r_ad94ff05447760ce113c0ee12f92cb503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad94ff05447760ce113c0ee12f92cb503">trim_tail</a> (size_t nof_bytes)</td></tr>
<tr class="memdesc:ad94ff05447760ce113c0ee12f92cb503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove "nof_bytes" bytes at the end of the <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. If the length is greater than the length of the last segment, the function will fail and return -1 without modifying the <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>.  <br /></td></tr>
<tr class="separator:ad94ff05447760ce113c0ee12f92cb503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d77b44f1d800f8b2f92bb76e80512f3" id="r_a4d77b44f1d800f8b2f92bb76e80512f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d77b44f1d800f8b2f92bb76e80512f3">empty</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="memdesc:a4d77b44f1d800f8b2f92bb76e80512f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> is empty.  <br /></td></tr>
<tr class="separator:a4d77b44f1d800f8b2f92bb76e80512f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7168fb8841a83a60b60a2ae06b59662d" id="r_a7168fb8841a83a60b60a2ae06b59662d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7168fb8841a83a60b60a2ae06b59662d">length</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="memdesc:a7168fb8841a83a60b60a2ae06b59662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> length.  <br /></td></tr>
<tr class="separator:a7168fb8841a83a60b60a2ae06b59662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf855416c7e41a6c3d8c4941d4783c99" id="r_abf855416c7e41a6c3d8c4941d4783c99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf855416c7e41a6c3d8c4941d4783c99">back</a> ()</td></tr>
<tr class="separator:abf855416c7e41a6c3d8c4941d4783c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9378faa8c62fbb48e4d262f4571305c7" id="r_a9378faa8c62fbb48e4d262f4571305c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9378faa8c62fbb48e4d262f4571305c7">back</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="separator:a9378faa8c62fbb48e4d262f4571305c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bd6d35edc057057878c260bb770ac6" id="r_ae8bd6d35edc057057878c260bb770ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8bd6d35edc057057878c260bb770ac6">operator[]</a> (size_t i) <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="separator:ae8bd6d35edc057057878c260bb770ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ad328b7f3a1993fa922079a3325572" id="r_a67ad328b7f3a1993fa922079a3325572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ad328b7f3a1993fa922079a3325572">operator[]</a> (size_t i)</td></tr>
<tr class="separator:a67ad328b7f3a1993fa922079a3325572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6158880f84f9e70bcad65ec41d3947d" id="r_aa6158880f84f9e70bcad65ec41d3947d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6158880f84f9e70bcad65ec41d3947d">begin</a> ()</td></tr>
<tr class="separator:aa6158880f84f9e70bcad65ec41d3947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d229af09452739a4134b3c5cc6c10bb" id="r_a3d229af09452739a4134b3c5cc6c10bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d229af09452739a4134b3c5cc6c10bb">cbegin</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="separator:a3d229af09452739a4134b3c5cc6c10bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89725b9abf675e324b80cd97f2c59939" id="r_a89725b9abf675e324b80cd97f2c59939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89725b9abf675e324b80cd97f2c59939">begin</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="separator:a89725b9abf675e324b80cd97f2c59939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b09f39ae09c1675dcc1f24cfafac00" id="r_a01b09f39ae09c1675dcc1f24cfafac00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01b09f39ae09c1675dcc1f24cfafac00">end</a> ()</td></tr>
<tr class="separator:a01b09f39ae09c1675dcc1f24cfafac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93337b886e3228c314441a3d9bc64664" id="r_a93337b886e3228c314441a3d9bc64664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93337b886e3228c314441a3d9bc64664">end</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="separator:a93337b886e3228c314441a3d9bc64664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0488305e1061fbd56b03863cd4cb06a" id="r_ad0488305e1061fbd56b03863cd4cb06a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0488305e1061fbd56b03863cd4cb06a">cend</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="separator:ad0488305e1061fbd56b03863cd4cb06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35457b6e2f22016d8f8736ed4dd405e" id="r_af35457b6e2f22016d8f8736ed4dd405e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af35457b6e2f22016d8f8736ed4dd405e">is_contiguous</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="memdesc:af35457b6e2f22016d8f8736ed4dd405e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if byte buffer is contiguous in memory, i.e. it has only one segment.  <br /></td></tr>
<tr class="separator:af35457b6e2f22016d8f8736ed4dd405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68551742e508e22eb0729f9701a6a87" id="r_ad68551742e508e22eb0729f9701a6a87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad68551742e508e22eb0729f9701a6a87">linearize</a> ()</td></tr>
<tr class="memdesc:ad68551742e508e22eb0729f9701a6a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the bytes stored in different segments of the <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> into first segment.  <br /></td></tr>
<tr class="separator:ad68551742e508e22eb0729f9701a6a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854af8571f283c815b9b429393c5b0dd" id="r_a854af8571f283c815b9b429393c5b0dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a854af8571f283c815b9b429393c5b0dd">resize</a> (size_t <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_sz</a>)</td></tr>
<tr class="memdesc:a854af8571f283c815b9b429393c5b0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> length. Note: It doesn't initialize newly created bytes.  <br /></td></tr>
<tr class="separator:a854af8571f283c815b9b429393c5b0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b324249f8e1d4366bbe869fe464444" id="r_a43b324249f8e1d4366bbe869fe464444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/def/namespacesrsran.html#a2c874a03d72343d6bd7fd30e8b9b2ff1">byte_buffer_segment_span_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43b324249f8e1d4366bbe869fe464444">segments</a> ()</td></tr>
<tr class="memdesc:a43b324249f8e1d4366bbe869fe464444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-owning list of segments that compose the <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>.  <br /></td></tr>
<tr class="separator:a43b324249f8e1d4366bbe869fe464444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b346068b8b1fe33af98fd085301a7" id="r_aea8b346068b8b1fe33af98fd085301a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d08/classsrsran_1_1detail_1_1byte__buffer__segment__list__span__range__impl.html">const_byte_buffer_segment_span_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea8b346068b8b1fe33af98fd085301a7">segments</a> () <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a></td></tr>
<tr class="separator:aea8b346068b8b1fe33af98fd085301a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a02c6cbc753f5908a4e21237c5001c939" id="r_a02c6cbc753f5908a4e21237c5001c939"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">R</a> &gt; </td></tr>
<tr class="memitem:a02c6cbc753f5908a4e21237c5001c939"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02c6cbc753f5908a4e21237c5001c939">operator==</a> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">lhs</a>, <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">R</a> &amp;r)</td></tr>
<tr class="memdesc:a02c6cbc753f5908a4e21237c5001c939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between byte buffer view and another range.  <br /></td></tr>
<tr class="separator:a02c6cbc753f5908a4e21237c5001c939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322a5da9c84a7238d19d91a0a2f8094f" id="r_a322a5da9c84a7238d19d91a0a2f8094f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> T , std::enable_if_t&lt; std::is_convertible&lt; T, <a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; &gt;::value, <a class="el" href="../../d1/da0/classint.html">int</a> &gt;  = 0&gt; </td></tr>
<tr class="memitem:a322a5da9c84a7238d19d91a0a2f8094f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a322a5da9c84a7238d19d91a0a2f8094f">operator==</a> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> T &amp;r, <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">rhs</a>)</td></tr>
<tr class="separator:a322a5da9c84a7238d19d91a0a2f8094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc458560f59e4ddd2f7a3913f7986c24" id="r_abc458560f59e4ddd2f7a3913f7986c24"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> T &gt; </td></tr>
<tr class="memitem:abc458560f59e4ddd2f7a3913f7986c24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc458560f59e4ddd2f7a3913f7986c24">operator!=</a> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">lhs</a>, <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> T &amp;r)</td></tr>
<tr class="separator:abc458560f59e4ddd2f7a3913f7986c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab399a14c39e6fa6b9fc84328273100b3" id="r_ab399a14c39e6fa6b9fc84328273100b3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> T , std::enable_if_t&lt; std::is_convertible&lt; T, <a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; &gt;::value, <a class="el" href="../../d1/da0/classint.html">int</a> &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab399a14c39e6fa6b9fc84328273100b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/db9/classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab399a14c39e6fa6b9fc84328273100b3">operator!=</a> (<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> T &amp;r, <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">rhs</a>)</td></tr>
<tr class="separator:ab399a14c39e6fa6b9fc84328273100b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks. This container is not contiguous in memory. Default copy ctor and assignment is disabled in this container. The user should instead std::move to transfer ownership, .<a class="el" href="#a1f08be439b9c2c174b4b2827c18feda6" title="Performs a shallow copy. Head segment reference counter is incremented.">copy()</a> for shallow copies with shared ownership and .<a class="el" href="#aa79a5e270dbb5dd01b83c034853b9fb3" title="Performs a deep copy (byte by bytes) of this byte_buffer.">deep_copy()</a> for byte-wise copies. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a68178f768cd233f55b4e6ebba378bf1e" name="a68178f768cd233f55b4e6ebba378bf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68178f768cd233f55b4e6ebba378bf1e">&#9670;&#160;</a></span>byte_buffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">srsran::byte_buffer::byte_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> with content provided by a span of bytes. </p>
<div class="fragment"><div class="line"><span class="lineno">  185</span>  {</div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(<a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>)) {</div>
<div class="line"><span class="lineno">  187</span>      <a class="code hl_function" href="#a7c8882b6403ea3f246d63c64dd122f10">clear</a>();</div>
<div class="line"><span class="lineno">  188</span>    }</div>
<div class="line"><span class="lineno">  189</span>  }</div>
<div class="ttc" id="aclassbytes_html"><div class="ttname"><a href="../../de/dd1/classbytes.html">bytes</a></div><div class="ttdef"><b>Definition</b> format.h:3310</div></div>
<div class="ttc" id="aclasssrsran_1_1byte__buffer_html_a190484f4224c88acb2f1b3334b28421b"><div class="ttname"><a href="#a190484f4224c88acb2f1b3334b28421b">srsran::byte_buffer::append</a></div><div class="ttdeci">SRSRAN_NODISCARD bool append(Iterator begin, Iterator end)</div><div class="ttdoc">Append bytes of a iterator range.</div><div class="ttdef"><b>Definition</b> byte_buffer.h:242</div></div>
<div class="ttc" id="aclasssrsran_1_1byte__buffer_html_a7c8882b6403ea3f246d63c64dd122f10"><div class="ttname"><a href="#a7c8882b6403ea3f246d63c64dd122f10">srsran::byte_buffer::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Clear byte buffer.</div><div class="ttdef"><b>Definition</b> byte_buffer.h:316</div></div>
<div class="ttc" id="anamespacesrsran_html_a58e7c9f2c51a9ad6a0899b46d5315723"><div class="ttname"><a href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">srsran::mask_msb_ones</a></div><div class="ttdeci">constexpr Integer mask_msb_ones(size_t N)</div><div class="ttdoc">Returns an unsigned integer with the N most significant bits (MSB) set to one, and the remaining bits...</div><div class="ttdef"><b>Definition</b> bounded_bitset.h:65</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a23243c3899f5fb66157c4b8151136dbd" name="a23243c3899f5fb66157c4b8151136dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23243c3899f5fb66157c4b8151136dbd">&#9670;&#160;</a></span>byte_buffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">srsran::byte_buffer::byte_buffer </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lst</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> with data intialized via a initializer list. </p>
<div class="fragment"><div class="line"><span class="lineno">  192</span>: <a class="code hl_function" href="#a9d95648e141616eb82e4db1be807148c">byte_buffer</a>(span&lt;const uint8_t&gt;{<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">lst</a>.begin(), <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">lst</a>.size()}) {}</div>
<div class="ttc" id="aclasssrsran_1_1byte__buffer_html_a9d95648e141616eb82e4db1be807148c"><div class="ttname"><a href="#a9d95648e141616eb82e4db1be807148c">srsran::byte_buffer::byte_buffer</a></div><div class="ttdeci">byte_buffer() noexcept=default</div><div class="ttdoc">Creates an empty byte_buffer.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3bffb2221d9e273d2227d182403a2016" name="a3bffb2221d9e273d2227d182403a2016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bffb2221d9e273d2227d182403a2016">&#9670;&#160;</a></span>byte_buffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">srsran::byte_buffer::byte_buffer </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>other_begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>other_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> with data assigned from a range of bytes. </p>
<div class="fragment"><div class="line"><span class="lineno">  197</span>  {</div>
<div class="line"><span class="lineno">  198</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">other_begin</a>, <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">other_end</a>)) {</div>
<div class="line"><span class="lineno">  199</span>      <a class="code hl_function" href="#a7c8882b6403ea3f246d63c64dd122f10">clear</a>();</div>
<div class="line"><span class="lineno">  200</span>    }</div>
<div class="line"><span class="lineno">  201</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4ef452363346e8bf3176c8d2d31a5171" name="a4ef452363346e8bf3176c8d2d31a5171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef452363346e8bf3176c8d2d31a5171">&#9670;&#160;</a></span>append() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> byte_buffer::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends bytes from another rvalue <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments. </p>
<div class="fragment"><div class="line"><span class="lineno">  203</span>{</div>
<div class="line"><span class="lineno">  204</span>  srsran_assert(&amp;<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a> != <span class="keyword">this</span>, <span class="stringliteral">&quot;Self-append not supported&quot;</span>);</div>
<div class="line"><span class="lineno">  205</span>  <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.empty()) {</div>
<div class="line"><span class="lineno">  206</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  207</span>  }</div>
<div class="line"><span class="lineno">  208</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="#a4d77b44f1d800f8b2f92bb76e80512f3">empty</a>()) {</div>
<div class="line"><span class="lineno">  209</span>    *<span class="keyword">this</span> = std::move(<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>);</div>
<div class="line"><span class="lineno">  210</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  211</span>  }</div>
<div class="line"><span class="lineno">  212</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr.unique()) {</div>
<div class="line"><span class="lineno">  213</span>    <span class="comment">// Use lvalue append.</span></div>
<div class="line"><span class="lineno">  214</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>);</div>
<div class="line"><span class="lineno">  215</span>  }</div>
<div class="line"><span class="lineno">  216</span>  <span class="comment">// This is the last reference to &quot;after&quot;. Shallow copy, except control segment.</span></div>
<div class="line"><span class="lineno">  217</span>  node_t* node = create_segment(0);</div>
<div class="line"><span class="lineno">  218</span>  <span class="keywordflow">if</span> (node == <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  219</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  220</span>  }</div>
<div class="line"><span class="lineno">  221</span>  node-&gt;append(<a class="code hl_class" href="../../de/d4c/classsrsran_1_1span.html">span&lt;uint8_t&gt;</a>{<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.head-&gt;<a class="code hl_function" href="../../de/d4c/classsrsran_1_1span.html#a451a209648781b54503ae671408e16b8">data</a>(),</div>
<div class="line"><span class="lineno">  222</span>                             <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block-&gt;length()});</div>
<div class="line"><span class="lineno">  223</span>  ctrl_blk_ptr-&gt;pkt_len += <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;pkt_len;</div>
<div class="line"><span class="lineno">  224</span>  node_t* <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">last_tail</a>           = ctrl_blk_ptr-&gt;segments.tail;</div>
<div class="line"><span class="lineno">  225</span>  <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">last_tail</a>-&gt;next             = <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.head;</div>
<div class="line"><span class="lineno">  226</span>  ctrl_blk_ptr-&gt;segments.tail = <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.tail;</div>
<div class="line"><span class="lineno">  227</span>  node-&gt;next                  = <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block-&gt;next;</div>
<div class="line"><span class="lineno">  228</span>  <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block == <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.tail) {</div>
<div class="line"><span class="lineno">  229</span>    ctrl_blk_ptr-&gt;segments.tail = node;</div>
<div class="line"><span class="lineno">  230</span>  }</div>
<div class="line"><span class="lineno">  231</span>  <span class="keywordflow">for</span> (node_t* <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">last_tail</a>; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next != <span class="keyword">nullptr</span>; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next) {</div>
<div class="line"><span class="lineno">  232</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next == <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block) {</div>
<div class="line"><span class="lineno">  233</span>      <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next = node;</div>
<div class="line"><span class="lineno">  234</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  235</span>    }</div>
<div class="line"><span class="lineno">  236</span>  }</div>
<div class="line"><span class="lineno">  237</span>  <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.head       = <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block;</div>
<div class="line"><span class="lineno">  238</span>  <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.tail       = <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block;</div>
<div class="line"><span class="lineno">  239</span>  <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.head-&gt;next = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  240</span>  <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr.reset();</div>
<div class="line"><span class="lineno">  241</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  242</span>}</div>
<div class="ttc" id="aclasssrsran_1_1byte__buffer_html_a4d77b44f1d800f8b2f92bb76e80512f3"><div class="ttname"><a href="#a4d77b44f1d800f8b2f92bb76e80512f3">srsran::byte_buffer::empty</a></div><div class="ttdeci">bool empty() const</div><div class="ttdoc">Checks whether byte_buffer is empty.</div><div class="ttdef"><b>Definition</b> byte_buffer.h:327</div></div>
<div class="ttc" id="aclasssrsran_1_1span_html"><div class="ttname"><a href="../../de/d4c/classsrsran_1_1span.html">srsran::span</a></div><div class="ttdef"><b>Definition</b> span.h:98</div></div>
<div class="ttc" id="aclasssrsran_1_1span_html_a451a209648781b54503ae671408e16b8"><div class="ttname"><a href="../../de/d4c/classsrsran_1_1span.html#a451a209648781b54503ae671408e16b8">srsran::span::data</a></div><div class="ttdeci">constexpr pointer data() const noexcept</div><div class="ttdoc">Returns a pointer to the beginning of the sequence.</div><div class="ttdef"><b>Definition</b> span.h:201</div></div>
<div class="ttc" id="anamespacesrsran_html_aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf"><div class="ttname"><a href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">srsran::pmi_codebook_type::other</a></div><div class="ttdeci">@ other</div><div class="ttdoc">Any other configuration.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af6cbb3c32365a49af9d01ae53360a43c" name="af6cbb3c32365a49af9d01ae53360a43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cbb3c32365a49af9d01ae53360a43c">&#9670;&#160;</a></span>append() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> byte_buffer::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends bytes from another <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments. </p>
<div class="fragment"><div class="line"><span class="lineno">  178</span>{</div>
<div class="line"><span class="lineno">  179</span>  srsran_assert(&amp;<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a> != <span class="keyword">this</span>, <span class="stringliteral">&quot;Self-append not supported&quot;</span>);</div>
<div class="line"><span class="lineno">  180</span>  <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.empty()) {</div>
<div class="line"><span class="lineno">  181</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  182</span>  }</div>
<div class="line"><span class="lineno">  183</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> has_ctrl_block() <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">and</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> append_segment(<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.head-&gt;headroom())) {</div>
<div class="line"><span class="lineno">  184</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  185</span>  }</div>
<div class="line"><span class="lineno">  186</span>  <span class="keywordflow">for</span> (node_t* <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.head; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> != <span class="keyword">nullptr</span>; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next) {</div>
<div class="line"><span class="lineno">  187</span>    <span class="keyword">auto</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">other_it</a> = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;begin();</div>
<div class="line"><span class="lineno">  188</span>    <span class="keywordflow">while</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">other_it</a> != <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;end()) {</div>
<div class="line"><span class="lineno">  189</span>      <span class="keywordflow">if</span> (ctrl_blk_ptr-&gt;segments.tail-&gt;tailroom() == 0 <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">and</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> append_segment(0)) {</div>
<div class="line"><span class="lineno">  190</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  191</span>      }</div>
<div class="line"><span class="lineno">  192</span>      <span class="keyword">auto</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_append</a> =</div>
<div class="line"><span class="lineno">  193</span>          std::min(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;end() - <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">other_it</a>, (iterator::difference_type)ctrl_blk_ptr-&gt;segments.tail-&gt;tailroom());</div>
<div class="line"><span class="lineno">  194</span>      ctrl_blk_ptr-&gt;segments.tail-&gt;append(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">other_it</a>, <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">other_it</a> + <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_append</a>);</div>
<div class="line"><span class="lineno">  195</span>      <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">other_it</a> += <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_append</a>;</div>
<div class="line"><span class="lineno">  196</span>    }</div>
<div class="line"><span class="lineno">  197</span>    ctrl_blk_ptr-&gt;pkt_len += <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;length();</div>
<div class="line"><span class="lineno">  198</span>  }</div>
<div class="line"><span class="lineno">  199</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  200</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a60a8d0f483eeaaa7c31d576782070647" name="a60a8d0f483eeaaa7c31d576782070647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a8d0f483eeaaa7c31d576782070647">&#9670;&#160;</a></span>append() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::byte_buffer::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../db/d64/classsrsran_1_1byte__buffer__slice.html">byte_buffer_slice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends an owning view of bytes into current byte buffer. </p>
<div class="fragment"><div class="line"><span class="lineno">  557</span>{</div>
<div class="line"><span class="lineno">  558</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(slice.view());</div>
<div class="line"><span class="lineno">  559</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af4563ca3bb9e2b8634e96ec87911c838" name="af4563ca3bb9e2b8634e96ec87911c838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4563ca3bb9e2b8634e96ec87911c838">&#9670;&#160;</a></span>append() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::byte_buffer::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d72/classsrsran_1_1byte__buffer__view.html">byte_buffer_view</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a view of bytes into current byte buffer. </p>
<div class="fragment"><div class="line"><span class="lineno">  286</span>  {</div>
<div class="line"><span class="lineno">  287</span>    <span class="comment">// append segment by segment.</span></div>
<div class="line"><span class="lineno">  288</span>    <span class="keyword">auto</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">view_segs</a> = view.segments();</div>
<div class="line"><span class="lineno">  289</span>    <span class="keywordflow">for</span> (span&lt;const uint8_t&gt; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> : <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">view_segs</a>) {</div>
<div class="line"><span class="lineno">  290</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>)) {</div>
<div class="line"><span class="lineno">  291</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  292</span>      }</div>
<div class="line"><span class="lineno">  293</span>    }</div>
<div class="line"><span class="lineno">  294</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  295</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a244844e979a2bf6e2bdb96574c65584b" name="a244844e979a2bf6e2bdb96574c65584b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244844e979a2bf6e2bdb96574c65584b">&#9670;&#160;</a></span>append() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dd1/compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> <a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::byte_buffer::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> std::initializer_list&lt; <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends an initializer list of bytes. </p>
<div class="fragment"><div class="line"><span class="lineno">  261</span>  {</div>
<div class="line"><span class="lineno">  262</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(span&lt;const uint8_t&gt;{<a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.begin(), <a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.size()});</div>
<div class="line"><span class="lineno">  263</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a190484f4224c88acb2f1b3334b28421b" name="a190484f4224c88acb2f1b3334b28421b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190484f4224c88acb2f1b3334b28421b">&#9670;&#160;</a></span>append() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dd1/compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> <a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::byte_buffer::append </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append bytes of a iterator range. </p>
<div class="fragment"><div class="line"><span class="lineno">  243</span>  {</div>
<div class="line"><span class="lineno">  244</span>    <span class="keyword">static_assert</span>(std::is_same&lt;std::decay_t&lt;<span class="keyword">decltype</span>(*begin)&gt;, <a class="code hl_class" href="../../d4/dff/classuint8__t.html">uint8_t</a>&gt;::value <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">or</a></div>
<div class="line"><span class="lineno">  245</span>                      std::is_same&lt;std::decay_t&lt;<span class="keyword">decltype</span>(*begin)&gt;, <span class="keyword">const</span> <a class="code hl_class" href="../../d4/dff/classuint8__t.html">uint8_t</a>&gt;::value,</div>
<div class="line"><span class="lineno">  246</span>                  <span class="stringliteral">&quot;Iterator value type is not uint8_t&quot;</span>);</div>
<div class="line"><span class="lineno">  247</span>    <span class="comment">// TODO: use segment-wise copy if it is a span.</span></div>
<div class="line"><span class="lineno">  248</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = begin; it != end; ++it) {</div>
<div class="line"><span class="lineno">  249</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(*it)) {</div>
<div class="line"><span class="lineno">  250</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  251</span>      }</div>
<div class="line"><span class="lineno">  252</span>    }</div>
<div class="line"><span class="lineno">  253</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  254</span>  }</div>
<div class="ttc" id="aclassuint8__t_html"><div class="ttname"><a href="../../d4/dff/classuint8__t.html">uint8_t</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7c9b29ce6019b29798495213d68096c" name="ad7c9b29ce6019b29798495213d68096c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c9b29ce6019b29798495213d68096c">&#9670;&#160;</a></span>append() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> byte_buffer::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends bytes to the byte buffer. This function may retrieve new segments from a memory pool. </p>
<div class="fragment"><div class="line"><span class="lineno">  153</span>{</div>
<div class="line"><span class="lineno">  154</span>  <span class="keywordflow">if</span> (<a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.empty()) {</div>
<div class="line"><span class="lineno">  155</span>    <span class="comment">// no bytes to append.</span></div>
<div class="line"><span class="lineno">  156</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  157</span>  }</div>
<div class="line"><span class="lineno">  158</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> has_ctrl_block() <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">and</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> append_segment(DEFAULT_FIRST_SEGMENT_HEADROOM)) {</div>
<div class="line"><span class="lineno">  159</span>    <span class="comment">// failed to allocate head segment.</span></div>
<div class="line"><span class="lineno">  160</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  161</span>  }</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>  <span class="comment">// segment-wise copy.</span></div>
<div class="line"><span class="lineno">  164</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> count = 0; count &lt; <a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.size();) {</div>
<div class="line"><span class="lineno">  165</span>    <span class="keywordflow">if</span> (ctrl_blk_ptr-&gt;segments.tail-&gt;tailroom() == 0 <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">and</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> append_segment(0)) {</div>
<div class="line"><span class="lineno">  166</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  167</span>    }</div>
<div class="line"><span class="lineno">  168</span>    <span class="keywordtype">size_t</span>              <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_write</a> = std::min(ctrl_blk_ptr-&gt;segments.tail-&gt;tailroom(), <a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.size() - count);</div>
<div class="line"><span class="lineno">  169</span>    <a class="code hl_class" href="../../de/d4c/classsrsran_1_1span.html">span&lt;const uint8_t&gt;</a> subspan  = <a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.subspan(count, <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_write</a>);</div>
<div class="line"><span class="lineno">  170</span>    ctrl_blk_ptr-&gt;segments.tail-&gt;append(subspan);</div>
<div class="line"><span class="lineno">  171</span>    count += <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_write</a>;</div>
<div class="line"><span class="lineno">  172</span>    ctrl_blk_ptr-&gt;pkt_len += <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_write</a>;</div>
<div class="line"><span class="lineno">  173</span>  }</div>
<div class="line"><span class="lineno">  174</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  175</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae74d9a2442b1103a2ac0852afd7f3e1a" name="ae74d9a2442b1103a2ac0852afd7f3e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74d9a2442b1103a2ac0852afd7f3e1a">&#9670;&#160;</a></span>append() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dd1/compiler_8h.html#a84270d7b45f0280051bd27685657e03e">SRSRAN_NODISCARD</a> <a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::byte_buffer::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a></td>          <td class="paramname"><span class="paramname"><em>byte</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends bytes to the byte buffer. This function may allocate new segments. </p>
<div class="fragment"><div class="line"><span class="lineno">  273</span>  {</div>
<div class="line"><span class="lineno">  274</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="#a4d77b44f1d800f8b2f92bb76e80512f3">empty</a>() <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">or</a> ctrl_blk_ptr-&gt;segments.tail-&gt;tailroom() == 0) {</div>
<div class="line"><span class="lineno">  275</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> append_segment(DEFAULT_FIRST_SEGMENT_HEADROOM)) {</div>
<div class="line"><span class="lineno">  276</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  277</span>      }</div>
<div class="line"><span class="lineno">  278</span>    }</div>
<div class="line"><span class="lineno">  279</span>    ctrl_blk_ptr-&gt;segments.tail-&gt;append(<span class="keywordtype">byte</span>);</div>
<div class="line"><span class="lineno">  280</span>    ctrl_blk_ptr-&gt;pkt_len++;</div>
<div class="line"><span class="lineno">  281</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  282</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abf855416c7e41a6c3d8c4941d4783c99" name="abf855416c7e41a6c3d8c4941d4783c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf855416c7e41a6c3d8c4941d4783c99">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &amp; srsran::byte_buffer::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  332</span>{ <span class="keywordflow">return</span> ctrl_blk_ptr-&gt;segments.tail-&gt;back(); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9378faa8c62fbb48e4d262f4571305c7" name="a9378faa8c62fbb48e4d262f4571305c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9378faa8c62fbb48e4d262f4571305c7">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &amp; srsran::byte_buffer::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  333</span>{ <span class="keywordflow">return</span> ctrl_blk_ptr-&gt;segments.tail-&gt;back(); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6158880f84f9e70bcad65ec41d3947d" name="aa6158880f84f9e70bcad65ec41d3947d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6158880f84f9e70bcad65ec41d3947d">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">iterator</a> srsran::byte_buffer::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  338</span>{ <span class="keywordflow">return</span> iterator{ctrl_blk_ptr != <span class="keyword">nullptr</span> ? ctrl_blk_ptr-&gt;segments.head : <span class="keyword">nullptr</span>, 0}; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a89725b9abf675e324b80cd97f2c59939" name="a89725b9abf675e324b80cd97f2c59939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89725b9abf675e324b80cd97f2c59939">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a> srsran::byte_buffer::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  344</span>  {</div>
<div class="line"><span class="lineno">  345</span>    <span class="keywordflow">return</span> const_iterator{ctrl_blk_ptr != <span class="keyword">nullptr</span> ? ctrl_blk_ptr-&gt;segments.head : <span class="keyword">nullptr</span>, 0};</div>
<div class="line"><span class="lineno">  346</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d229af09452739a4134b3c5cc6c10bb" name="a3d229af09452739a4134b3c5cc6c10bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d229af09452739a4134b3c5cc6c10bb">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a> srsran::byte_buffer::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  340</span>  {</div>
<div class="line"><span class="lineno">  341</span>    <span class="keywordflow">return</span> const_iterator{ctrl_blk_ptr != <span class="keyword">nullptr</span> ? ctrl_blk_ptr-&gt;segments.head : <span class="keyword">nullptr</span>, 0};</div>
<div class="line"><span class="lineno">  342</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0488305e1061fbd56b03863cd4cb06a" name="ad0488305e1061fbd56b03863cd4cb06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0488305e1061fbd56b03863cd4cb06a">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a> srsran::byte_buffer::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  349</span>{ <span class="keywordflow">return</span> const_iterator{<span class="keyword">nullptr</span>, 0}; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c8882b6403ea3f246d63c64dd122f10" name="a7c8882b6403ea3f246d63c64dd122f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8882b6403ea3f246d63c64dd122f10">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">void</a> srsran::byte_buffer::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear byte buffer. </p>
<div class="fragment"><div class="line"><span class="lineno">  316</span>{ ctrl_blk_ptr.reset(); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f08be439b9c2c174b4b2827c18feda6" name="a1f08be439b9c2c174b4b2827c18feda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f08be439b9c2c174b4b2827c18feda6">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> srsran::byte_buffer::copy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a shallow copy. Head segment reference counter is incremented. </p>
<div class="fragment"><div class="line"><span class="lineno">  238</span>{ <span class="keywordflow">return</span> <a class="code hl_function" href="#a9d95648e141616eb82e4db1be807148c">byte_buffer</a>{*<span class="keyword">this</span>}; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa79a5e270dbb5dd01b83c034853b9fb3" name="aa79a5e270dbb5dd01b83c034853b9fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79a5e270dbb5dd01b83c034853b9fb3">&#9670;&#160;</a></span>deep_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> srsran::byte_buffer::deep_copy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep copy (byte by bytes) of this <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. </p>
<div class="fragment"><div class="line"><span class="lineno">  224</span>  {</div>
<div class="line"><span class="lineno">  225</span>    <a class="code hl_function" href="#a9d95648e141616eb82e4db1be807148c">byte_buffer</a> buf;</div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordflow">if</span> (ctrl_blk_ptr != <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  227</span>      <span class="keywordflow">for</span> (node_t* <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = ctrl_blk_ptr-&gt;segments.head; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> != <span class="keyword">nullptr</span>; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next) {</div>
<div class="line"><span class="lineno">  228</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> buf.append(span&lt;uint8_t&gt;{seg-&gt;data(), seg-&gt;length()})) {</div>
<div class="line"><span class="lineno">  229</span>          buf.clear();</div>
<div class="line"><span class="lineno">  230</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  231</span>        }</div>
<div class="line"><span class="lineno">  232</span>      }</div>
<div class="line"><span class="lineno">  233</span>    }</div>
<div class="line"><span class="lineno">  234</span>    <span class="keywordflow">return</span> buf;</div>
<div class="line"><span class="lineno">  235</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d77b44f1d800f8b2f92bb76e80512f3" name="a4d77b44f1d800f8b2f92bb76e80512f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d77b44f1d800f8b2f92bb76e80512f3">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::byte_buffer::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> is empty. </p>
<div class="fragment"><div class="line"><span class="lineno">  327</span>{ <span class="keywordflow">return</span> <a class="code hl_function" href="#a7168fb8841a83a60b60a2ae06b59662d">length</a>() == 0; }</div>
<div class="ttc" id="aclasssrsran_1_1byte__buffer_html_a7168fb8841a83a60b60a2ae06b59662d"><div class="ttname"><a href="#a7168fb8841a83a60b60a2ae06b59662d">srsran::byte_buffer::length</a></div><div class="ttdeci">size_t length() const</div><div class="ttdoc">Checks byte_buffer length.</div><div class="ttdef"><b>Definition</b> byte_buffer.h:330</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a01b09f39ae09c1675dcc1f24cfafac00" name="a01b09f39ae09c1675dcc1f24cfafac00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b09f39ae09c1675dcc1f24cfafac00">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">iterator</a> srsran::byte_buffer::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  347</span>{ <span class="keywordflow">return</span> iterator{<span class="keyword">nullptr</span>, 0}; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a93337b886e3228c314441a3d9bc64664" name="a93337b886e3228c314441a3d9bc64664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93337b886e3228c314441a3d9bc64664">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d1e/classsrsran_1_1detail_1_1byte__buffer__segment__byte__iterator__impl.html">const_iterator</a> srsran::byte_buffer::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  348</span>{ <span class="keywordflow">return</span> const_iterator{<span class="keyword">nullptr</span>, 0}; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af35457b6e2f22016d8f8736ed4dd405e" name="af35457b6e2f22016d8f8736ed4dd405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35457b6e2f22016d8f8736ed4dd405e">&#9670;&#160;</a></span>is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> srsran::byte_buffer::is_contiguous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if byte buffer is contiguous in memory, i.e. it has only one segment. </p>
<div class="fragment"><div class="line"><span class="lineno">  352</span>{ <span class="keywordflow">return</span> <a class="code hl_function" href="#a4d77b44f1d800f8b2f92bb76e80512f3">empty</a>() <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">or</a> ctrl_blk_ptr-&gt;<a class="code hl_function" href="#a43b324249f8e1d4366bbe869fe464444">segments</a>.head == ctrl_blk_ptr-&gt;<a class="code hl_function" href="#a43b324249f8e1d4366bbe869fe464444">segments</a>.tail; }</div>
<div class="ttc" id="aclasssrsran_1_1byte__buffer_html_a43b324249f8e1d4366bbe869fe464444"><div class="ttname"><a href="#a43b324249f8e1d4366bbe869fe464444">srsran::byte_buffer::segments</a></div><div class="ttdeci">byte_buffer_segment_span_range segments()</div><div class="ttdoc">Returns a non-owning list of segments that compose the byte_buffer.</div><div class="ttdef"><b>Definition</b> byte_buffer.h:361</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7168fb8841a83a60b60a2ae06b59662d" name="a7168fb8841a83a60b60a2ae06b59662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7168fb8841a83a60b60a2ae06b59662d">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t srsran::byte_buffer::length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> length. </p>
<div class="fragment"><div class="line"><span class="lineno">  330</span>{ <span class="keywordflow">return</span> ctrl_blk_ptr != <span class="keyword">nullptr</span> ? ctrl_blk_ptr-&gt;pkt_len : 0; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad68551742e508e22eb0729f9701a6a87" name="ad68551742e508e22eb0729f9701a6a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68551742e508e22eb0729f9701a6a87">&#9670;&#160;</a></span>linearize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> byte_buffer::linearize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the bytes stored in different segments of the <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> into first segment. </p>
<div class="fragment"><div class="line"><span class="lineno">  478</span>{</div>
<div class="line"><span class="lineno">  479</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="#af35457b6e2f22016d8f8736ed4dd405e">is_contiguous</a>()) {</div>
<div class="line"><span class="lineno">  480</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  481</span>  }</div>
<div class="line"><span class="lineno">  482</span>  <span class="keywordtype">size_t</span> sz = <a class="code hl_function" href="#a7168fb8841a83a60b60a2ae06b59662d">length</a>();</div>
<div class="line"><span class="lineno">  483</span>  <span class="keywordflow">if</span> (sz &gt; ctrl_blk_ptr-&gt;segments.head-&gt;capacity() - ctrl_blk_ptr-&gt;segments.head-&gt;headroom()) {</div>
<div class="line"><span class="lineno">  484</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  485</span>  }</div>
<div class="line"><span class="lineno">  486</span>  <span class="keywordflow">for</span> (node_t* <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = ctrl_blk_ptr-&gt;segments.head-&gt;next; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> != <span class="keyword">nullptr</span>;) {</div>
<div class="line"><span class="lineno">  487</span>    node_t* next = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next;</div>
<div class="line"><span class="lineno">  488</span>    ctrl_blk_ptr-&gt;segments.head-&gt;append(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;begin(), <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;end());</div>
<div class="line"><span class="lineno">  489</span>    ctrl_blk_ptr-&gt;destroy_node(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>);</div>
<div class="line"><span class="lineno">  490</span>    <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = next;</div>
<div class="line"><span class="lineno">  491</span>  }</div>
<div class="line"><span class="lineno">  492</span>  ctrl_blk_ptr-&gt;segments.head-&gt;next = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  493</span>  ctrl_blk_ptr-&gt;segments.tail       = ctrl_blk_ptr-&gt;segments.head;</div>
<div class="line"><span class="lineno">  494</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  495</span>}</div>
<div class="ttc" id="aclasssrsran_1_1byte__buffer_html_af35457b6e2f22016d8f8736ed4dd405e"><div class="ttname"><a href="#af35457b6e2f22016d8f8736ed4dd405e">srsran::byte_buffer::is_contiguous</a></div><div class="ttdeci">bool is_contiguous() const</div><div class="ttdoc">Test if byte buffer is contiguous in memory, i.e. it has only one segment.</div><div class="ttdef"><b>Definition</b> byte_buffer.h:352</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d2ffb4df18c0d3ddc15a68b75664b43" name="a4d2ffb4df18c0d3ddc15a68b75664b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2ffb4df18c0d3ddc15a68b75664b43">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp; srsran::byte_buffer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of span of bytes. </p>
<div class="fragment"><div class="line"><span class="lineno">  214</span>  {</div>
<div class="line"><span class="lineno">  215</span>    <a class="code hl_function" href="#a7c8882b6403ea3f246d63c64dd122f10">clear</a>();</div>
<div class="line"><span class="lineno">  216</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(<a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>)) {</div>
<div class="line"><span class="lineno">  217</span>      <a class="code hl_function" href="#a7c8882b6403ea3f246d63c64dd122f10">clear</a>();</div>
<div class="line"><span class="lineno">  218</span>    }</div>
<div class="line"><span class="lineno">  219</span>    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  220</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a67ad328b7f3a1993fa922079a3325572" name="a67ad328b7f3a1993fa922079a3325572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ad328b7f3a1993fa922079a3325572">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &amp; srsran::byte_buffer::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  336</span>{ <span class="keywordflow">return</span> *(begin() + i); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8bd6d35edc057057878c260bb770ac6" name="ae8bd6d35edc057057878c260bb770ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bd6d35edc057057878c260bb770ac6">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &amp; srsran::byte_buffer::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  335</span>{ <span class="keywordflow">return</span> *(begin() + i); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ababbb591f47600a9a0ffbf5a91b19e87" name="ababbb591f47600a9a0ffbf5a91b19e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababbb591f47600a9a0ffbf5a91b19e87">&#9670;&#160;</a></span>prepend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> byte_buffer::prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepend data of r-value byte buffer to this byte buffer. The segments of the provided byte buffer can get "stolen" if the byte buffer is the last reference to the segments. </p>
<div class="fragment"><div class="line"><span class="lineno">  373</span>{</div>
<div class="line"><span class="lineno">  374</span>  srsran_assert(&amp;<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a> != <span class="keyword">this</span>, <span class="stringliteral">&quot;Self-append not supported&quot;</span>);</div>
<div class="line"><span class="lineno">  375</span>  <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.empty()) {</div>
<div class="line"><span class="lineno">  376</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  377</span>  }</div>
<div class="line"><span class="lineno">  378</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="#a4d77b44f1d800f8b2f92bb76e80512f3">empty</a>()) {</div>
<div class="line"><span class="lineno">  379</span>    <span class="comment">// the byte buffer is empty. Prepending is the same as appending.</span></div>
<div class="line"><span class="lineno">  380</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(std::move(<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>));</div>
<div class="line"><span class="lineno">  381</span>  }</div>
<div class="line"><span class="lineno">  382</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr.unique()) {</div>
<div class="line"><span class="lineno">  383</span>    <span class="comment">// Deep copy of segments.</span></div>
<div class="line"><span class="lineno">  384</span>    <a class="code hl_function" href="#ae8478410e24f9b23cafda0cbabdbf403">prepend</a>(<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>);</div>
<div class="line"><span class="lineno">  385</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  386</span>  }</div>
<div class="line"><span class="lineno">  387</span> </div>
<div class="line"><span class="lineno">  388</span>  <span class="comment">// This is the last reference to &quot;other&quot;. Shallow copy, except control segment.</span></div>
<div class="line"><span class="lineno">  389</span>  node_t* node = create_segment(0);</div>
<div class="line"><span class="lineno">  390</span>  <span class="keywordflow">if</span> (node == <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  391</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  392</span>  }</div>
<div class="line"><span class="lineno">  393</span>  node-&gt;append(<a class="code hl_class" href="../../de/d4c/classsrsran_1_1span.html">span&lt;uint8_t&gt;</a>{<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block-&gt;<a class="code hl_function" href="../../de/d4c/classsrsran_1_1span.html#a451a209648781b54503ae671408e16b8">data</a>(),</div>
<div class="line"><span class="lineno">  394</span>                             <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block-&gt;length()});</div>
<div class="line"><span class="lineno">  395</span>  ctrl_blk_ptr-&gt;pkt_len += <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;pkt_len;</div>
<div class="line"><span class="lineno">  396</span>  <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.tail-&gt;next = ctrl_blk_ptr-&gt;segments.head;</div>
<div class="line"><span class="lineno">  397</span>  node-&gt;next                              = <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block-&gt;next;</div>
<div class="line"><span class="lineno">  398</span>  <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block == <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.head) {</div>
<div class="line"><span class="lineno">  399</span>    ctrl_blk_ptr-&gt;segments.head = node;</div>
<div class="line"><span class="lineno">  400</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  401</span>    <span class="keywordflow">for</span> (node_t* <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.head; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next != <span class="keyword">nullptr</span>; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next) {</div>
<div class="line"><span class="lineno">  402</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next == <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block) {</div>
<div class="line"><span class="lineno">  403</span>        <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next = node;</div>
<div class="line"><span class="lineno">  404</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  405</span>      }</div>
<div class="line"><span class="lineno">  406</span>    }</div>
<div class="line"><span class="lineno">  407</span>  }</div>
<div class="line"><span class="lineno">  408</span>  <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.head       = <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block;</div>
<div class="line"><span class="lineno">  409</span>  <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.tail       = <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segment_in_cb_memory_block;</div>
<div class="line"><span class="lineno">  410</span>  <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr-&gt;segments.head-&gt;next = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  411</span>  <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.ctrl_blk_ptr.reset();</div>
<div class="line"><span class="lineno">  412</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  413</span>}</div>
<div class="ttc" id="aclasssrsran_1_1byte__buffer_html_ae8478410e24f9b23cafda0cbabdbf403"><div class="ttname"><a href="#ae8478410e24f9b23cafda0cbabdbf403">srsran::byte_buffer::prepend</a></div><div class="ttdeci">bool prepend(span&lt; const uint8_t &gt; bytes)</div><div class="ttdoc">Prepends bytes to byte_buffer. This function may allocate new segments.</div><div class="ttdef"><b>Definition</b> byte_buffer.cpp:328</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6acac0fd07a5577ba3a430b636c74741" name="a6acac0fd07a5577ba3a430b636c74741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acac0fd07a5577ba3a430b636c74741">&#9670;&#160;</a></span>prepend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> byte_buffer::prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepend data of byte buffer to this byte buffer. </p>
<div class="fragment"><div class="line"><span class="lineno">  350</span>{</div>
<div class="line"><span class="lineno">  351</span>  srsran_assert(&amp;<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a> != <span class="keyword">this</span>, <span class="stringliteral">&quot;Self-append not supported&quot;</span>);</div>
<div class="line"><span class="lineno">  352</span>  <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.empty()) {</div>
<div class="line"><span class="lineno">  353</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  354</span>  }</div>
<div class="line"><span class="lineno">  355</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="#a4d77b44f1d800f8b2f92bb76e80512f3">empty</a>()) {</div>
<div class="line"><span class="lineno">  356</span>    <span class="comment">// the byte buffer is empty. Prepending is the same as appending.</span></div>
<div class="line"><span class="lineno">  357</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(<a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>);</div>
<div class="line"><span class="lineno">  358</span>  }</div>
<div class="line"><span class="lineno">  359</span>  <span class="keywordflow">for</span> (<a class="code hl_class" href="../../de/d4c/classsrsran_1_1span.html">span&lt;const uint8_t&gt;</a> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> : <a class="code hl_enumvalue" href="../../d9/def/namespacesrsran.html#aaf684a2cfa98b7f333de7041525a5b29a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.<a class="code hl_function" href="#a43b324249f8e1d4366bbe869fe464444">segments</a>()) {</div>
<div class="line"><span class="lineno">  360</span>    node_t* node = create_segment(0);</div>
<div class="line"><span class="lineno">  361</span>    <span class="keywordflow">if</span> (node == <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  362</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  363</span>    }</div>
<div class="line"><span class="lineno">  364</span>    node-&gt;append(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>);</div>
<div class="line"><span class="lineno">  365</span>    node-&gt;next                  = ctrl_blk_ptr-&gt;segments.head;</div>
<div class="line"><span class="lineno">  366</span>    ctrl_blk_ptr-&gt;segments.head = node;</div>
<div class="line"><span class="lineno">  367</span>    ctrl_blk_ptr-&gt;pkt_len += <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>.size();</div>
<div class="line"><span class="lineno">  368</span>  }</div>
<div class="line"><span class="lineno">  369</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  370</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8478410e24f9b23cafda0cbabdbf403" name="ae8478410e24f9b23cafda0cbabdbf403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8478410e24f9b23cafda0cbabdbf403">&#9670;&#160;</a></span>prepend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> byte_buffer::prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepends bytes to <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments. </p>
<div class="fragment"><div class="line"><span class="lineno">  329</span>{</div>
<div class="line"><span class="lineno">  330</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="#a4d77b44f1d800f8b2f92bb76e80512f3">empty</a>()) {</div>
<div class="line"><span class="lineno">  331</span>    <span class="comment">// the byte buffer is empty. Prepending is the same as appending.</span></div>
<div class="line"><span class="lineno">  332</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="#a190484f4224c88acb2f1b3334b28421b">append</a>(<a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>);</div>
<div class="line"><span class="lineno">  333</span>  }</div>
<div class="line"><span class="lineno">  334</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> count = 0; count &lt; <a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.size();) {</div>
<div class="line"><span class="lineno">  335</span>    <span class="keywordflow">if</span> (ctrl_blk_ptr-&gt;segments.head-&gt;headroom() == 0) {</div>
<div class="line"><span class="lineno">  336</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> prepend_segment(<a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.size() - count)) {</div>
<div class="line"><span class="lineno">  337</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  338</span>      }</div>
<div class="line"><span class="lineno">  339</span>    }</div>
<div class="line"><span class="lineno">  340</span>    <span class="keywordtype">size_t</span>              <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_write</a> = std::min(ctrl_blk_ptr-&gt;segments.head-&gt;headroom(), <a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.size() - count);</div>
<div class="line"><span class="lineno">  341</span>    <a class="code hl_class" href="../../de/d4c/classsrsran_1_1span.html">span&lt;const uint8_t&gt;</a> subspan  = <a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.subspan(<a class="code hl_class" href="../../de/dd1/classbytes.html">bytes</a>.size() - <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_write</a> - count, <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_write</a>);</div>
<div class="line"><span class="lineno">  342</span>    ctrl_blk_ptr-&gt;segments.head-&gt;prepend(subspan);</div>
<div class="line"><span class="lineno">  343</span>    ctrl_blk_ptr-&gt;pkt_len += <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_write</a>;</div>
<div class="line"><span class="lineno">  344</span>    count += <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_write</a>;</div>
<div class="line"><span class="lineno">  345</span>  }</div>
<div class="line"><span class="lineno">  346</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  347</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8dbd27b3715bfe6abc890fbfd170245" name="ad8dbd27b3715bfe6abc890fbfd170245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8dbd27b3715bfe6abc890fbfd170245">&#9670;&#160;</a></span>reserve_prepend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d72/classsrsran_1_1byte__buffer__view.html">byte_buffer_view</a> byte_buffer::reserve_prepend </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nof_bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepends space in <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. This function may allocate new segments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nof_bytes</td><td>Number of bytes to reserve at header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range of bytes that were reserved. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  416</span>{</div>
<div class="line"><span class="lineno">  417</span>  <span class="keywordtype">size_t</span> rem_bytes = nof_bytes;</div>
<div class="line"><span class="lineno">  418</span>  <span class="keywordflow">while</span> (rem_bytes &gt; 0) {</div>
<div class="line"><span class="lineno">  419</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="#a4d77b44f1d800f8b2f92bb76e80512f3">empty</a>() <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">or</a> ctrl_blk_ptr-&gt;segments.head-&gt;headroom() == 0) {</div>
<div class="line"><span class="lineno">  420</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> prepend_segment(rem_bytes)) {</div>
<div class="line"><span class="lineno">  421</span>        <span class="keywordflow">return</span> {};</div>
<div class="line"><span class="lineno">  422</span>      }</div>
<div class="line"><span class="lineno">  423</span>    }</div>
<div class="line"><span class="lineno">  424</span>    <span class="keywordtype">size_t</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_reserve</a> = std::min(ctrl_blk_ptr-&gt;segments.head-&gt;headroom(), rem_bytes);</div>
<div class="line"><span class="lineno">  425</span>    ctrl_blk_ptr-&gt;segments.head-&gt;reserve_prepend(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_reserve</a>);</div>
<div class="line"><span class="lineno">  426</span>    rem_bytes -= <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_reserve</a>;</div>
<div class="line"><span class="lineno">  427</span>  }</div>
<div class="line"><span class="lineno">  428</span>  ctrl_blk_ptr-&gt;pkt_len += nof_bytes;</div>
<div class="line"><span class="lineno">  429</span>  <span class="keywordflow">return</span> <a class="code hl_class" href="../../d0/d72/classsrsran_1_1byte__buffer__view.html">byte_buffer_view</a>{begin(), begin() + nof_bytes};</div>
<div class="line"><span class="lineno">  430</span>}</div>
<div class="ttc" id="aclasssrsran_1_1byte__buffer__view_html"><div class="ttname"><a href="../../d0/d72/classsrsran_1_1byte__buffer__view.html">srsran::byte_buffer_view</a></div><div class="ttdoc">Non-owning view to a byte sequence. The underlying byte sequence is not contiguous in memory....</div><div class="ttdef"><b>Definition</b> byte_buffer.h:46</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a854af8571f283c815b9b429393c5b0dd" name="a854af8571f283c815b9b429393c5b0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854af8571f283c815b9b429393c5b0dd">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> byte_buffer::resize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>new_sz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a> length. Note: It doesn't initialize newly created bytes. </p>
<div class="fragment"><div class="line"><span class="lineno">  498</span>{</div>
<div class="line"><span class="lineno">  499</span>  <span class="keywordtype">size_t</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">prev_len</a> = <a class="code hl_function" href="#a7168fb8841a83a60b60a2ae06b59662d">length</a>();</div>
<div class="line"><span class="lineno">  500</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_sz</a> == <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">prev_len</a>) {</div>
<div class="line"><span class="lineno">  501</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  502</span>  }</div>
<div class="line"><span class="lineno">  503</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_sz</a> &gt; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">prev_len</a>) {</div>
<div class="line"><span class="lineno">  504</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_add</a> = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_sz</a> - <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">prev_len</a>; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_add</a> &gt; 0;) {</div>
<div class="line"><span class="lineno">  505</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="#a4d77b44f1d800f8b2f92bb76e80512f3">empty</a>() <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">or</a> ctrl_blk_ptr-&gt;segments.tail-&gt;tailroom() == 0) {</div>
<div class="line"><span class="lineno">  506</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">not</a> append_segment(0)) {</div>
<div class="line"><span class="lineno">  507</span>          <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  508</span>        }</div>
<div class="line"><span class="lineno">  509</span>      }</div>
<div class="line"><span class="lineno">  510</span>      <span class="keywordtype">size_t</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">added</a> = std::min(ctrl_blk_ptr-&gt;segments.tail-&gt;tailroom(), <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_add</a>);</div>
<div class="line"><span class="lineno">  511</span>      ctrl_blk_ptr-&gt;segments.tail-&gt;resize(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">added</a>);</div>
<div class="line"><span class="lineno">  512</span>      <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_add</a> -= <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">added</a>;</div>
<div class="line"><span class="lineno">  513</span>    }</div>
<div class="line"><span class="lineno">  514</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  515</span>    <span class="keywordtype">size_t</span> count = 0;</div>
<div class="line"><span class="lineno">  516</span>    <span class="keywordflow">for</span> (node_t* <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = ctrl_blk_ptr-&gt;segments.head; count &lt; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_sz</a>; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next) {</div>
<div class="line"><span class="lineno">  517</span>      <span class="keywordtype">size_t</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_seg_len</a> = std::min(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;length(), <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_sz</a> - count);</div>
<div class="line"><span class="lineno">  518</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_seg_len</a> != <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;length()) {</div>
<div class="line"><span class="lineno">  519</span>        <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;resize(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_seg_len</a>);</div>
<div class="line"><span class="lineno">  520</span>      }</div>
<div class="line"><span class="lineno">  521</span>      count += <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_seg_len</a>;</div>
<div class="line"><span class="lineno">  522</span>      <span class="keywordflow">if</span> (count == <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_sz</a>) {</div>
<div class="line"><span class="lineno">  523</span>        <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next                   = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  524</span>        ctrl_blk_ptr-&gt;segments.tail = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>;</div>
<div class="line"><span class="lineno">  525</span>      }</div>
<div class="line"><span class="lineno">  526</span>    }</div>
<div class="line"><span class="lineno">  527</span>  }</div>
<div class="line"><span class="lineno">  528</span>  ctrl_blk_ptr-&gt;pkt_len = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_sz</a>;</div>
<div class="line"><span class="lineno">  529</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  530</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a43b324249f8e1d4366bbe869fe464444" name="a43b324249f8e1d4366bbe869fe464444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b324249f8e1d4366bbe869fe464444">&#9670;&#160;</a></span>segments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/def/namespacesrsran.html#a2c874a03d72343d6bd7fd30e8b9b2ff1">byte_buffer_segment_span_range</a> srsran::byte_buffer::segments </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-owning list of segments that compose the <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. </p>
<div class="fragment"><div class="line"><span class="lineno">  362</span>  {</div>
<div class="line"><span class="lineno">  363</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="../../d9/def/namespacesrsran.html#a2c874a03d72343d6bd7fd30e8b9b2ff1">byte_buffer_segment_span_range</a>(ctrl_blk_ptr != <span class="keyword">nullptr</span> ? ctrl_blk_ptr-&gt;segments.head : <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">nullptr</a>, 0, <a class="code hl_function" href="#a7168fb8841a83a60b60a2ae06b59662d">length</a>());</div>
<div class="line"><span class="lineno">  364</span>  }</div>
<div class="ttc" id="anamespacesrsran_html_a2c874a03d72343d6bd7fd30e8b9b2ff1"><div class="ttname"><a href="../../d9/def/namespacesrsran.html#a2c874a03d72343d6bd7fd30e8b9b2ff1">srsran::byte_buffer_segment_span_range</a></div><div class="ttdeci">detail::byte_buffer_segment_list_span_range_impl&lt; detail::byte_buffer_segment_list::node_t &gt; byte_buffer_segment_span_range</div><div class="ttdoc">Range of byte spans belonging to a byte_buffer_segment_list.</div><div class="ttdef"><b>Definition</b> byte_buffer_segment_list.h:355</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aea8b346068b8b1fe33af98fd085301a7" name="aea8b346068b8b1fe33af98fd085301a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8b346068b8b1fe33af98fd085301a7">&#9670;&#160;</a></span>segments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d08/classsrsran_1_1detail_1_1byte__buffer__segment__list__span__range__impl.html">const_byte_buffer_segment_span_range</a> srsran::byte_buffer::segments </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  366</span>  {</div>
<div class="line"><span class="lineno">  367</span>    <span class="keywordflow">return</span> const_byte_buffer_segment_span_range(</div>
<div class="line"><span class="lineno">  368</span>        ctrl_blk_ptr != <span class="keyword">nullptr</span> ? ctrl_blk_ptr-&gt;segments.head : <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">nullptr</a>, 0, <a class="code hl_function" href="#a7168fb8841a83a60b60a2ae06b59662d">length</a>());</div>
<div class="line"><span class="lineno">  369</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a832175c27ef0d111b127c1a0bc421ec3" name="a832175c27ef0d111b127c1a0bc421ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832175c27ef0d111b127c1a0bc421ec3">&#9670;&#160;</a></span>trim_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">void</a> byte_buffer::trim_head </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nof_bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes "nof_bytes" from the head of the <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. </p>
<div class="fragment"><div class="line"><span class="lineno">  433</span>{</div>
<div class="line"><span class="lineno">  434</span>  srsran_assert(<a class="code hl_function" href="#a7168fb8841a83a60b60a2ae06b59662d">length</a>() &gt;= nof_bytes, <span class="stringliteral">&quot;Trying to trim more bytes than those available&quot;</span>);</div>
<div class="line"><span class="lineno">  435</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">trimmed</a> = 0; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">trimmed</a> != nof_bytes;) {</div>
<div class="line"><span class="lineno">  436</span>    <span class="keywordtype">size_t</span> <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_trim</a> = std::min(nof_bytes - <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">trimmed</a>, ctrl_blk_ptr-&gt;segments.head-&gt;length());</div>
<div class="line"><span class="lineno">  437</span>    ctrl_blk_ptr-&gt;segments.head-&gt;trim_head(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_trim</a>);</div>
<div class="line"><span class="lineno">  438</span>    ctrl_blk_ptr-&gt;pkt_len -= <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_trim</a>;</div>
<div class="line"><span class="lineno">  439</span>    <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">trimmed</a> += <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">to_trim</a>;</div>
<div class="line"><span class="lineno">  440</span>    <span class="keywordflow">if</span> (ctrl_blk_ptr-&gt;segments.head-&gt;length() == 0) {</div>
<div class="line"><span class="lineno">  441</span>      <span class="comment">// Remove the first segment.</span></div>
<div class="line"><span class="lineno">  442</span>      ctrl_blk_ptr-&gt;segments.head = ctrl_blk_ptr-&gt;segments.head-&gt;next;</div>
<div class="line"><span class="lineno">  443</span>    }</div>
<div class="line"><span class="lineno">  444</span>  }</div>
<div class="line"><span class="lineno">  445</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad94ff05447760ce113c0ee12f92cb503" name="ad94ff05447760ce113c0ee12f92cb503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94ff05447760ce113c0ee12f92cb503">&#9670;&#160;</a></span>trim_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">void</a> byte_buffer::trim_tail </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nof_bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove "nof_bytes" bytes at the end of the <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. If the length is greater than the length of the last segment, the function will fail and return -1 without modifying the <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html" title="Byte sequence, which represents its data in memory via an intrusive linked list of memory chunks....">byte_buffer</a>. </p>
<div class="fragment"><div class="line"><span class="lineno">  448</span>{</div>
<div class="line"><span class="lineno">  449</span>  srsran_assert(<a class="code hl_function" href="#a7168fb8841a83a60b60a2ae06b59662d">length</a>() &gt;= nof_bytes, <span class="stringliteral">&quot;Trimming too many bytes from byte_buffer&quot;</span>);</div>
<div class="line"><span class="lineno">  450</span>  <span class="keywordflow">if</span> (nof_bytes == 0) {</div>
<div class="line"><span class="lineno">  451</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  452</span>  }</div>
<div class="line"><span class="lineno">  453</span> </div>
<div class="line"><span class="lineno">  454</span>  <span class="keywordflow">if</span> (ctrl_blk_ptr-&gt;segments.tail-&gt;length() &gt;= nof_bytes) {</div>
<div class="line"><span class="lineno">  455</span>    <span class="comment">// Simplest scenario where the last segment is larger than the number of bytes to trim.</span></div>
<div class="line"><span class="lineno">  456</span>    ctrl_blk_ptr-&gt;segments.tail-&gt;trim_tail(nof_bytes);</div>
<div class="line"><span class="lineno">  457</span>    ctrl_blk_ptr-&gt;pkt_len -= nof_bytes;</div>
<div class="line"><span class="lineno">  458</span>    <span class="keywordflow">if</span> (ctrl_blk_ptr-&gt;segments.tail-&gt;length() == 0) {</div>
<div class="line"><span class="lineno">  459</span>      pop_last_segment();</div>
<div class="line"><span class="lineno">  460</span>    }</div>
<div class="line"><span class="lineno">  461</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  462</span>  }</div>
<div class="line"><span class="lineno">  463</span>  <span class="keywordtype">size_t</span>  <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_len</a> = <a class="code hl_function" href="#a7168fb8841a83a60b60a2ae06b59662d">length</a>() - nof_bytes;</div>
<div class="line"><span class="lineno">  464</span>  node_t* <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>     = ctrl_blk_ptr-&gt;segments.head;</div>
<div class="line"><span class="lineno">  465</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> count = 0; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> != <span class="keyword">nullptr</span>; <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a> = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next) {</div>
<div class="line"><span class="lineno">  466</span>    <span class="keywordflow">if</span> (count + <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;length() &gt;= <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_len</a>) {</div>
<div class="line"><span class="lineno">  467</span>      <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;next = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  468</span>      <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;resize(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_len</a> - count);</div>
<div class="line"><span class="lineno">  469</span>      ctrl_blk_ptr-&gt;segments.tail = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>;</div>
<div class="line"><span class="lineno">  470</span>      ctrl_blk_ptr-&gt;pkt_len       = <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">new_len</a>;</div>
<div class="line"><span class="lineno">  471</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  472</span>    }</div>
<div class="line"><span class="lineno">  473</span>    count += <a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">seg</a>-&gt;length();</div>
<div class="line"><span class="lineno">  474</span>  }</div>
<div class="line"><span class="lineno">  475</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="abc458560f59e4ddd2f7a3913f7986c24" name="abc458560f59e4ddd2f7a3913f7986c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc458560f59e4ddd2f7a3913f7986c24">&#9670;&#160;</a></span>operator!= <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> T &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  384</span>  {</div>
<div class="line"><span class="lineno">  385</span>    <span class="keywordflow">return</span> !(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">lhs</a> == r);</div>
<div class="line"><span class="lineno">  386</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab399a14c39e6fa6b9fc84328273100b3" name="ab399a14c39e6fa6b9fc84328273100b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab399a14c39e6fa6b9fc84328273100b3">&#9670;&#160;</a></span>operator!= <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> T , std::enable_if_t&lt; std::is_convertible&lt; T, <a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; &gt;::value, <a class="el" href="../../d1/da0/classint.html">int</a> &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> T &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  389</span>  {</div>
<div class="line"><span class="lineno">  390</span>    <span class="keywordflow">return</span> !(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">rhs</a> == r);</div>
<div class="line"><span class="lineno">  391</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a02c6cbc753f5908a4e21237c5001c939" name="a02c6cbc753f5908a4e21237c5001c939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c6cbc753f5908a4e21237c5001c939">&#9670;&#160;</a></span>operator== <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">R</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">R</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between byte buffer view and another range. </p>
<div class="fragment"><div class="line"><span class="lineno">  374</span>  {</div>
<div class="line"><span class="lineno">  375</span>    <span class="keywordflow">return</span> detail::compare_byte_buffer_range(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">lhs</a>, r);</div>
<div class="line"><span class="lineno">  376</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a322a5da9c84a7238d19d91a0a2f8094f" name="a322a5da9c84a7238d19d91a0a2f8094f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322a5da9c84a7238d19d91a0a2f8094f">&#9670;&#160;</a></span>operator== <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">typename</a> T , std::enable_if_t&lt; std::is_convertible&lt; T, <a class="el" href="../../de/d4c/classsrsran_1_1span.html">span</a>&lt; <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d4/dff/classuint8__t.html">uint8_t</a> &gt; &gt;::value, <a class="el" href="../../d1/da0/classint.html">int</a> &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/db9/classbool.html">bool</a> <a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> T &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">const</a> <a class="el" href="../../d0/d87/classsrsran_1_1byte__buffer.html">byte_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  379</span>  {</div>
<div class="line"><span class="lineno">  380</span>    <span class="keywordflow">return</span> detail::compare_byte_buffer_range(<a class="code hl_function" href="../../d9/def/namespacesrsran.html#a58e7c9f2c51a9ad6a0899b46d5315723">rhs</a>, r);</div>
<div class="line"><span class="lineno">  381</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/srsran/adt/<a class="el" href="../../d0/dfd/byte__buffer_8h_source.html">byte_buffer.h</a></li>
<li>lib/support/<b>byte_buffer.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
